<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第四章 文件管理</title>
      <link href="/myblog/2022/08/18/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-08-18-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/myblog/2022/08/18/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-08-18-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="文件系统的概念">文件系统的概念</h2><h3 id="文件的属性">文件的属性</h3><ul><li><code>文件名</code>：由创建文件的用户决定文件名，主要是为了方便用户找到文件；</li><li><code>标识符</code>：一个系统内的各文件标识符唯一，但对用户毫无可读性；</li><li><code>类型</code>：指明文件类型；</li><li><code>位置</code>：文件存放的路径；</li><li><code>大小</code>：文件大小；</li><li><code>保护信息</code>：对文件进行保护的访问控制信息；</li><li><code>创建时间</code></li><li><code>上次修改时间</code></li><li><code>文件所有者信息</code></li></ul><h3 id="文件的逻辑结构">文件的逻辑结构</h3><p>按逻辑结构，文件可划分为：无结构文件、有结构文件；</p><p><img src="https://img.lishangcc.top//img/image-20220818210953047.png" alt="image-20220818210953047"></p><p><strong>①无结构文件（流式文件）</strong></p><p><img src="https://img.lishangcc.top//img/image-20220818211209037.png" alt="image-20220818211209037"></p><p><strong>②有结构文件（记录式文件）</strong></p><p><img src="https://img.lishangcc.top//img/image-20220818211407417.png" alt="image-20220818211407417"></p><h3 id="操作系统向上提供的功能">操作系统向上提供的功能</h3><ul><li>创建文件（create系统调用）</li><li>删除文件（delete系统调用）</li><li>读文件（read系统调用）</li><li>写文件（write系统调用）</li><li>打开文件（open系统调用）</li><li>关闭文件（close系统调用）</li></ul><h2 id="文件的逻辑结构-2">文件的逻辑结构</h2><p><code>无结构文件</code>：文件内部的数据就是一系列二进制流或字符流组成，又称流式文件，如txt文本文件；</p><p><code>有结构文件</code>：由一组相似的记录组成，又称记录式文件，每条记录又由若干个数据项组成，如数据库表文件；根据每条记录的长度是否相等，又分为定长记录和可变长记录；</p><p><img src="https://img.lishangcc.top//img/image-20220818212419322.png" alt="image-20220818212419322"></p><h3 id="顺序文件">顺序文件</h3><p>文件中的记录一个接一个的顺序排列，记录是定长或可变长的，各个记录在物理上可以顺序存储或链式存储；</p><p><img src="https://img.lishangcc.top//img/image-20220818213340255.png" alt="image-20220818213340255"></p><p><img src="https://img.lishangcc.top//img/image-20220818213534997.png" alt="image-20220818213534997"></p><blockquote><p>定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取，若能再保证记录的顺序结构，则可实现快速检索（根据关键字快速找到对应记录）；</p></blockquote><h3 id="索引文件">索引文件</h3><p>索引表：定长记录的顺序文件，因此可以快速找到第i个记录对应的索引项；</p><p><img src="https://img.lishangcc.top//img/image-20220818224837028.png" alt="image-20220818224837028"></p><blockquote><p>缺点：每个记录对应一个索引表项，因此索引表可能会很大，比如：文件的每个记录平均只占8B，而每个索引表项占32B，那么索引表都比文件内容本身大4倍；</p></blockquote><h3 id="索引顺序文件">索引顺序文件</h3><p>索引顺序文件是索引文件和顺序文件思想的结合，同样是建立一张索引表，不同的是，一组记录会对应一个索引表项；</p><p><img src="https://img.lishangcc.top//img/image-20220818225304762.png" alt="image-20220818225304762"></p><blockquote><p>索引顺序文件VS顺序文件：</p><ul><li>若顺序文件有10000个记录，则根据关键字检索文件，只能从头开始顺序查找，平均查找5000次；</li><li>采用索引顺序结构，把10000个记录分为100组，每组100个记录，平均查找次数为50+50=100次；</li></ul></blockquote><h3 id="多级索引顺序文件">多级索引顺序文件</h3><p><img src="https://img.lishangcc.top//img/image-20220818225640562.png" alt="image-20220818225640562"></p><p><img src="https://img.lishangcc.top//img/image-20220818225711682.png" alt="image-20220818225711682"></p><p><strong>总结</strong></p><p><img src="https://img.lishangcc.top//img/image-20220818225843261.png" alt="image-20220818225843261"></p><h2 id="文件的物理结构">文件的物理结构</h2><h3 id="连续分配">连续分配</h3><p>要求每个文件在磁盘上占有一组连续的块；</p><p><img src="https://img.lishangcc.top//img/image-20220819001041053.png" alt="image-20220819001041053"></p><p>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快；</p><p>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片；</p><h3 id="链接分配——隐式链接">链接分配——隐式链接</h3><p>除文件的最后一个磁盘块外，每个盘块中都存有指向下一个盘块的指针，文件目录包括文件第一块的指针和最后一块的指针；</p><p><img src="https://img.lishangcc.top//img/image-20220819001313196.png" alt="image-20220819001313196"></p><p>优点：方便文件拓展；不会产生碎片问题；</p><p>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间；</p><h3 id="链接分配——显示链接">链接分配——显示链接</h3><p>把用于链接文件各物理块的指针，从每个物理块的末尾提取出来，显示存放在一张链表中，该表在磁盘中仅设置一张，称为<code>文件分配表（FAT）</code>；</p><p><img src="https://img.lishangcc.top//img/image-20220819002021876.png" alt="image-20220819002021876"></p><blockquote><p>如：aaa依次存放在磁盘块2—5—0—1；</p></blockquote><p>优点：方便文件拓展，不会有碎片问题，并且支持随机访问，相比于隐式，地址转换不需要访问磁盘，因此文件访问效率更高；</p><p>缺点：文件分配表需要占用一定的存储空间；</p><h3 id="索引分配">索引分配</h3><p>允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张<code>索引表</code>，索引表<code>记录了文件的各个逻辑块对应的物理块</code>，索引表存放的磁盘块称为<code>索引块</code>，文件数据存放的磁盘块称为<code>数据块</code>；</p><p><img src="https://img.lishangcc.top//img/image-20220819155535648.png" alt="image-20220819155535648"></p><p>如：文件aaa，7号磁盘块为其索引块，其数据存放在磁盘块2—5—13—9；</p><blockquote><p>注意：索引表与显式链接方式中的文件分配表FAT不同，FAT是一个磁盘对应一张，索引表是一个文件对应一张；</p></blockquote><h4 id="链接方案">链接方案</h4><p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放；</p><p><img src="https://img.lishangcc.top//img/image-20220819161103196.png" alt="image-20220819161103196"></p><p>缺点：若文件很大，索引表很长，就需要将多个索引块链接起来，想要找到第i号索引块，必须从0开始依次读入索引块，导致磁盘I/O次数过多，查找效率低；</p><h4 id="多层索引">多层索引</h4><p>建立多层索引（类似多级页表），使第一层索引块指向第二层索引块，还可以根据文件大小再建立更多层；</p><p><img src="https://img.lishangcc.top//img/image-20220819161134528.png" alt="image-20220819161134528"></p><p>缺点：即使是小文件，访问一个数据块依然需要K+1次读磁盘；</p><h4 id="混合索引">混合索引</h4><p>多种索引分配方式的结合；</p><p><img src="https://img.lishangcc.top//img/image-20220819161209945.png" alt="image-20220819161209945"></p><p>优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少；</p><blockquote><p>考点：</p><p>①根据多层索引、混合索引的结构计算出文件的最大长度（各级索引表最大不能超过一个块）；</p><p>②分析访问某个数据块所需要的读磁盘次数（注意顶级索引块是否调入内存）；</p></blockquote><h2 id="文件存储空间管理">文件存储空间管理</h2><h3 id="空闲表法">空闲表法</h3><p>适用于连续分配方式；</p><p><img src="https://img.lishangcc.top//img/image-20220819163807273.png" alt="image-20220819163807273"></p><p><strong>如何分配磁盘块</strong></p><blockquote><p>与内存管理中的动态分区分配类似，为一个文件分配连续的存储空间；同样可以采用首次适应、最佳适应等算法决定为文件分配哪个空间；</p></blockquote><p><strong>如何回收磁盘块</strong></p><blockquote><p>也是分那四种情况，①回收区前后没有相邻空闲区；②回收区前后都是空闲区；③回收区前是空闲区；④回收区后是空闲区；</p></blockquote><h3 id="空闲链表法">空闲链表法</h3><p>分两种：空闲盘块链、空闲盘区链；</p><p><strong>空闲盘块链</strong></p><p><img src="https://img.lishangcc.top//img/image-20220819192444062.png" alt="image-20220819192444062"></p><p><strong>空闲盘区链</strong></p><p><img src="https://img.lishangcc.top//img/image-20220819192509619.png" alt="image-20220819192509619"></p><h3 id="位示图法">位示图法</h3><p><img src="https://img.lishangcc.top//img/image-20220819180528299.png" alt="image-20220819180528299"></p><p><img src="https://img.lishangcc.top//img/image-20220819180559327.png" alt="image-20220819180559327"></p><p><code>位示图</code>：每个二进制对应一个盘块，在本例中，“0”表示盘块空闲，“1”表示盘块已分配，位示图一般用连续的“字”来表示；</p><blockquote><p>本例中一个字的字长为16位，字中每一位对应一个盘块，可用（字号，位号）对应一个盘块号；</p></blockquote><p>（字号，位号）=（i，j）的二进制对应盘块号b=ni+j；（本例中，盘块号、字号、位号从0开始，n表示字长）</p><p>b盘块对应的字号：i=b/n;</p><p>对应的位号：j=b%n；</p><blockquote><p><img src="https://img.lishangcc.top//img/image-20220819193311009.png" alt="image-20220819193311009"></p></blockquote><h3 id="成组链接法">成组链接法</h3><p>UNIX系统采用该方法，适合大型文件系统，自行了解；</p><h2 id="文件目录">文件目录</h2><p>一个文件对应一个文件控制块FCB，一个FCB就是一个目录项，多个FCB组成文件目录；</p><p><img src="https://img.lishangcc.top//img/image-20220818230320132.png" alt="image-20220818230320132"></p><p><strong>对目录的操作：</strong></p><p><img src="https://img.lishangcc.top//img/image-20220818230154859.png" alt="image-20220818230154859"></p><h3 id="单级目录结构">单级目录结构</h3><p>整个文件系统中只建立一张目录表，每个文件占一个目录项；</p><p><img src="https://img.lishangcc.top//img/image-20220818230425293.png" alt="image-20220818230425293"></p><p>单级目录实现了按名存取，但是不允许文件重名；</p><p>创建一个文件时，需要先检查目录表中是否有重名文件；</p><p>该结构不适用于多用户操作系统；</p><h3 id="两级目录结构">两级目录结构</h3><p>分为主文件目录和用户文件目录；</p><p><img src="https://img.lishangcc.top//img/image-20220818230626826.png" alt="image-20220818230626826"></p><p>用户文件目录项记录该用户文件的FCB信息；</p><p>优点：提高了检索速度，解决了多用户之间文件重名的问题，文件系统可以在目录上实现访问限制；</p><h3 id="多级目录结构-树形目录结构">多级目录结构(树形目录结构)</h3><p><img src="https://img.lishangcc.top//img/image-20220818231149500.png" alt="image-20220818231149500"></p><ul><li>明显提高了对目录的检索速度和文件系统性能；</li><li>理解一下相对路径和绝对路径；</li><li>该结构不便于文件的共享；</li></ul><h3 id="无环图目录结构">无环图目录结构</h3><p>针对多级目录结构不便于实现文件共享的问题，提出该结构；</p><p><img src="https://img.lishangcc.top//img/image-20220818231745428.png" alt="image-20220818231745428"></p><p><img src="https://img.lishangcc.top//img/image-20220818231837603.png" alt="image-20220818231837603"></p><h3 id="索引结点（FCB的改进）">索引结点（FCB的改进）</h3><ul><li>除文件名之外的所有信息都放到索引结点中，每个文件对应一个索引结点；</li><li>目录项值包含文件名、索引结点指针，因此每个目录项长度大幅减小；</li><li>由于目录项长度减小，每个磁盘块可以存放更多目录项，因此检索文件时磁盘I/O次数就少了很多（看例子理解）；</li></ul><p><img src="https://img.lishangcc.top//img/image-20220818232017373.png" alt="image-20220818232017373"></p><p><img src="https://img.lishangcc.top//img/image-20220818232035398.png" alt="image-20220818232035398"></p><h2 id="文件的基本操作">文件的基本操作</h2><p><strong>创建文件（create系统调用）</strong></p><p>提供参数：</p><ol><li>所需的外存空间大小；</li><li>文件存放路径；</li><li>文件名；</li></ol><p>主要事件：</p><ol><li>在外存找到文件所需的空间；</li><li>根据文件存放路径的信息找到该目录对应的目录文件，创建该文件对应的目录项；</li></ol><p><strong>删除文件（delete系统调用）</strong></p><p>提供参数：</p><ol><li>文件存放路径；</li><li>文件名；</li></ol><p>主要事件：</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项；</li><li>根据目录项记录的信息，回收文件占用的磁盘块；</li><li>从目录表中删除文件对应的目录项；</li></ol><p><strong>读文件（read系统调用）</strong></p><p>操作系统从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中；</p><p><strong>写文件（write系统调用）</strong></p><p>操作系统会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存；</p><p><strong>打开文件（open系统调用）</strong></p><p>提供参数：</p><ol><li>文件存放路径；</li><li>文件名；</li><li>对文件的操作类型（如：r只读，rw读写）；</li></ol><p>主要事件：</p><ol><li>也是找到文件名对应的目录项，并检查该用户是否有指定的操作权限；</li><li>将目录复制到内存中的&quot;打开文件表&quot;中，并将对应表目的编号返回给用户，之后用户使用打开文件表的编号来指明操作的文件；</li></ol><p><strong>关闭文件（close系统调用）</strong></p><p>主要事件：</p><ol><li>将进程打开文件表相应的表项删除；</li><li>回收分配给该文件的内存空间等资源；</li><li>系统打开文件表的打开计数器count减1，若count=0，则删除对应表项；</li></ol><h2 id="文件系统">文件系统</h2><h3 id="文件共享">文件共享</h3><h4 id="基于索引结点的共享方式（硬链接）">基于索引结点的共享方式（硬链接）</h4><p>索引结点回顾：检索文件时可能只需用到文件名，因此将除文件名之外的信息放到索引结点中；</p><p><img src="https://img.lishangcc.top//img/image-20220819200315742.png" alt="image-20220819200315742"></p><p>索引结点中设置一个链接计数变量count，用于表示链接到本索引结点上的用户目录项数；</p><p>若count=2，说明此时有两个用户目录项链接到该索引结点上，若某个用户决定删除该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1；</p><p>若count&gt;0，说明还有别的用户使用该文件，暂时不能把文件数据删除；</p><p>若count=0，系统负责删除文件；</p><h4 id="基于符号链的共享方式（软链接）">基于符号链的共享方式（软链接）</h4><p>为使用户B能共享用户A的一个文件F，由操作系统创建一个Link类型文件，也取名F，并将该文件写入B的目录中，实现用户B的目录与文件F的链接，这个新的F文件只包含了被链接文件F的路径名；</p><p><img src="https://img.lishangcc.top//img/image-20220819214109379.png" alt="image-20220819214109379"></p><p>当user3访问ccc时，操作系统判断ccc属于Link类型文件，会根据其中记录的路径层层查找目录，最终找到user1的目录表中的aaa表项，于是就找到了文件1的索引结点；</p><h3 id="文件保护">文件保护</h3><p><strong>口令保护</strong></p><p>为文件设置一个口令，用户请求访问该文件时必须提供口令；</p><p>优点：保存口令的空间开销不多，验证口令的时间开销也很小；</p><p>缺点：正确的口令存放在系统内部，不够安全；</p><p><strong>加密保护</strong></p><p>使用某个密码对文件进行加密，在访问文件时需要提供正确的密码才能对文件进行正确的解密；</p><p>如：异或加密：</p><p><img src="https://img.lishangcc.top//img/image-20220819215022524.png" alt="image-20220819215022524"></p><p>优点：保密性强，不需要再系统中存储密码；</p><p>缺点：加密或解密需要一定的时间；</p><p><strong>访问控制</strong></p><p>在每个文件的FCB（或索引节点）中增加一个访问控制列表（ACL），该表记录各个用户可以执行哪些操作；</p><blockquote><p>如果对某个目录进行了访问权限控制，那么也要对目录下的所有文件进行相同的访问权限控制；</p></blockquote><h3 id="文件系统全局结构">文件系统全局结构</h3><p><strong>文件系统在外存中的结构</strong></p><p>探究文件系统在外存是如何一步步建立的；</p><p>①物理格式化（低级格式化）：将磁盘划分为一个个扇区，并检查该磁盘是否有坏扇区，如果有，则用备用扇区替换；（坏扇区对操作系统是透明的）</p><p><img src="https://img.lishangcc.top//img/image-20220822010454691.png" alt="image-20220822010454691"></p><p>②逻辑格式化（高级格式化）：将磁盘划分为一个个的分区（如：C盘、D盘）；</p><p><img src="https://img.lishangcc.top//img/image-20220822010718214.png" alt="image-20220822010718214"></p><blockquote><p>分区表记录每个分区的大小、起始地址、地址范围等；</p><p>每个分区可用建立独立的文件系统；</p><p>（1）引导块：负责开机时初始化操作系统</p><p>（2）超级块：找到该分区中所有空闲磁盘块</p><p>（3）与空闲分区管理有关的数据结构：例如位示图，判断某个特定的磁盘块是否空闲</p><p>（4）i结点区：i结点即索引结点，一个文件对应一个索引结点，所有索引结点连续存放在i结点区（可以理解为超大的数组，该数组元素就是索引结点）</p><p>（5）根目录：逻辑格式化后，根目录被建立；任何文件都必须从根目录出发，建立新的下一级目录</p><p>（6）灰色部分此时已经有数据，白色部分还没有数据，只有新建文件或者目录时才会有数据</p></blockquote><p><strong>文件系统在内存中的结构</strong></p><p>内存分为用户区和内核区；</p><p><code>1.目录的缓存</code>：最近访问过的目录的数据会被暂时缓存在内存中。例如：最近查找过目录M，即将目录M中的FCB都读入主存，如果接下来又访问到目录M，就无需再从外存中读入</p><p><code>2.系统打开文件表</code>：记录整个系统打开了哪些文件</p><p>①整个系统只有一张系统打开文件表</p><p>②保存每个文件对应的FCB</p><p><code>3.进程（用）户打开文件表</code>：记录该进程当前打开了哪些文件</p><p>①一个进程对应一张进程打开文件表</p><p>②进程打开文件表包含于PCB中</p><p>③进程打开文件表并不会保存FCB，但会有一个指向系统打开文件表中该文件的索引，这样就能通过该索引找到系统打开文件表中该文件对应的FCB</p><p><img src="https://img.lishangcc.top//img/image-20220822011249240.png" alt="image-20220822011249240"></p><blockquote><p>示例：通过open系统调用打开目录M中的文件A</p><p>①根据路径读入目录：在外存中找到目录M→将目录M的数据读入主存（即将目录M缓存）</p><p>②找到目标文件FCB，复制到系统打开文件表：检查目录M的FCB，即逐一对比找到文件A的FCB→复制文件A的FCB到系统打开文件表中（表示文件A被打开），同时设置打开计数为1（表示当前有1个进程正在使用文件A）</p><p>③在进程打开文件表中新建一个条目，并返回文件描述符：发起OPEN系统调用的进程的进程打开文件表中新建一个条目，该条目记录对该文件的打开方式（读/写、只读等）；返回文件描述符，即返回指向该文件在系统打开文件表的位置的指针</p><p>④OPEN系统调用打开文件后，将返回一个文件描述符，可以通过该文件描述符对打开的文件进行操作（例如：操作系统收到READ系统调用后，根据文件描述符在进程打开文件表中找到对应的条目，然后根据索引信息找到系统打开文件表中对应的条目，即找到该文件的FCB，最后根据FCB找到该文件在外存中的位置）</p></blockquote><h3 id="虚拟文件系统">虚拟文件系统</h3><h4 id="虚拟文件系统概念">虚拟文件系统概念</h4><p><code>不同的外部存储设备内部的文件系统格式可能不同</code>（如：磁盘——UFS文件系统、移动硬盘——NTFS文件系统等）；</p><p>不同的文件系统所定义的函数接口可能不同（比如：打开文件的系统调用有：open、fopen、openf等）；</p><p><img src="https://img.lishangcc.top//img/image-20220822004442931.png" alt="image-20220822004442931"></p><p><strong>虚拟文件系统特点</strong></p><ol><li><p><code>向上层用户进程提供统一标准的系统调用接口</code>，屏蔽底层具体文件系统的实现差异；</p></li><li><p>要求下层的文件系统必须实现某些规定的函数功能，如：read/open/write；</p></li><li><p>每打开一个文件，虚拟文件系统就在主存中新建一个vnode，用统一的数据结构表示文件，无论该文件存储在哪个系统；</p><blockquote><p>vnode只存于主存中，而inode即会被调入主存，也会存在外存中；</p></blockquote></li></ol><p><img src="https://img.lishangcc.top//img/image-20220822005327620.png" alt="image-20220822005327620"></p><p>不同文件系统所对应的数据结构不同（例如：FAT文件系统的目录项包含其所有信息；UFS文件系统的目录项由指向索引结点的指针组成，具体的信息存放在该索引结点中），在虚拟文件系统中，通过open系统调用打开一个文件后就会给这个文件在主存中新建一个包含该文件的所有信息的VNODE（也称V结点），即将不用的文件系统的文件信息的数据结构通过复制到VONDE的方法形成统一的数据结构</p><p>（1）VNODE只会存在于主存中（由虚拟文件系统创建），而INODE（索引结点）存放在外存中，在使用时调入主存</p><p>（2）VNODE中的函数功能指针指向的是该文件所属文件系统的函数功能列表（write、read、open等）：对该文件进行的任何操作时，先找到该文件的VNODE，根据VNODE中的函数功能指针找到对应的文件系统的函数功能列表，再去执行具体函数，从而实现从上至下逐层函数调用</p><h4 id="文件系统挂载">文件系统挂载</h4><p>即文件系统的安装，如：U盘插入电脑，U盘的文件系统就需要挂载到操作系统上（挂载到虚拟文件系统）；</p><p><strong>挂载过程</strong></p><p>①在虚拟文件系统中注册新挂载的文件系统：虚拟文件系统管理一个名为<code>挂载表</code>的数据结构，新增一个文件系统时候就要在挂载表中增加一个相应的表项，即让虚拟文件系统发现这个文件系统。例如图中的虚拟文件系统管理的挂载表中有三个表项，分别指向UFS、NTFS和FAT</p><p>②新挂载的文件系统需要向虚拟文件系统提供一个<code>函数地址列表</code>：每一个文件系统实现系统调用的方式可能不同，即告诉系统调用自己的每个系统调用存放在哪个地址（VNODE中的函数功能指针），使得虚拟文件系统能够实现这些系统调用</p><p>③将新文件系统加到挂载点：例如Windows操作系统中，插入一个U盘，在我的电脑中将会增加一个可移动硬盘H（跟C盘、D盘平级），这样才能够被我们所访问和使用</p><h2 id="磁盘">磁盘</h2><p>磁盘属于一种I/O设备，第五章会更详细也可参考组成原理第三章；</p><p><img src="https://img.lishangcc.top//img/image-20220819224726522.png" alt="image-20220819224726522"></p><p><img src="https://img.lishangcc.top//img/image-20220819224456681.png" alt="image-20220819224456681"></p><h3 id="磁盘调度算法">磁盘调度算法*</h3><p>平均存取时间 = 寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁头定位到所在扇区）+ 传输时间（传输数据所花费的时间）</p><p><strong>寻道时间Ts</strong></p><p>①启动磁头臂时间s；</p><p>②移动磁头臂的时间，假设磁头匀速移动，每跨越一个磁道耗时m，总共跨越n条磁道；</p><blockquote><p>Ts=s+m*n;</p></blockquote><p><strong>延迟时间Tr</strong></p><p>通过旋转转盘，使磁头定位到目标扇区所需要的时间，设磁盘转速为r（单位：转/秒or转/分）；</p><blockquote><p>Tr=（1/2）*（1/r）= 1/（2r）；</p></blockquote><p><strong>传输时间Tt</strong></p><p>传输数据的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N；</p><blockquote><p>Tt = (1/r) * (b/N) = b / (rN)；</p></blockquote><p><strong>平均存取时间Ta</strong></p><p><code>Ta = Ts + 1/2r + b/(rN)</code></p><h4 id="先来先服务算法（FCFS）">先来先服务算法（FCFS）</h4><p>根据进程请求访问磁盘的先后顺序进行调度；</p><p><img src="https://img.lishangcc.top//img/image-20220819230307169.png" alt="image-20220819230307169"></p><p><img src="https://img.lishangcc.top//img/image-20220819230336363.png" alt="image-20220819230336363"></p><h4 id="最短寻找时间优先（SSTF）">最短寻找时间优先（SSTF）</h4><p>优先处理的磁道是与当前磁头最近的磁道，保证每次的寻道时间最短，但并不能保证总的寻道时间最短；（贪心算法思想，眼前最优未必总体最优）</p><p><img src="https://img.lishangcc.top//img/image-20220819230520489.png" alt="image-20220819230520489"></p><p><img src="https://img.lishangcc.top//img/image-20220819230539285.png" alt="image-20220819230539285"></p><h4 id="扫描算法（SCAN）">扫描算法（SCAN）</h4><p>为解决SSTF可能产生饥饿的问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道时才能往外移动；</p><p><img src="https://img.lishangcc.top//img/image-20220819230723378.png" alt="image-20220819230723378"></p><p><img src="https://img.lishangcc.top//img/image-20220819230745113.png" alt="image-20220819230745113"></p><h4 id="LOOK调度算法">LOOK调度算法</h4><p>上述SCAN算法例子中，处理184号磁道后其实可以不再往右移动，LOOK算法就是为解决该问题；</p><p>如果在磁头移动方向上已经没有别的请求，就立即改变磁头移动方向（边移动边观察）；</p><p><img src="https://img.lishangcc.top//img/image-20220819231056592.png" alt="image-20220819231056592"></p><p>优点：比起SCAN算法，使寻道时间进一步缩短；</p><h4 id="循环扫描算法（C-SCAN）">循环扫描算法（C-SCAN）</h4><p>规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回直接快速移动至另一端位置；</p><p><img src="https://img.lishangcc.top//img/image-20220819231409379.png" alt="image-20220819231409379"></p><p>优点：比起SCAN算法，对于各个位置磁道的响应频率很平均；</p><p>缺点：只有到达最边上的磁道才能改变磁头移动方向，并且返回时实际只需要返回到18号即可，比起SCAN算法，平均寻道时间更长；</p><h4 id="C-LOOK算法">C-LOOK算法</h4><p>解决C-SCAN算法的缺点，规定，如果磁头移动的方向上已经没有请求了，可以立即让磁头返回，并且只需要返回到有访问请求的位置即可；</p><p><img src="https://img.lishangcc.top//img/image-20220819231739398.png" alt="image-20220819231739398"></p><p>优点：比起C-SCAN算法，进一步缩短寻道时间；</p><blockquote><p>本节注意：若无特别说明，SCAN就是LOOK，C-SCAN就是C-LOOK；</p></blockquote><h3 id="减少延迟时间的方法">减少延迟时间的方法</h3><p><img src="https://img.lishangcc.top//img/image-20220819232354521.png" alt="image-20220819232354521"></p><h3 id="磁盘的管理">磁盘的管理</h3><h4 id="磁盘初始化">磁盘初始化</h4><p>步骤：</p><p>①进行低级格式化（物理格式化），将磁盘的各个磁道划分扇区，一个扇区通常分为 头、数据区域、尾三个部分（头尾存一些管理扇区的数据）；</p><p>②将磁盘分区，每个分区由若干柱面组成，（即C盘、D盘这些）；</p><p>③逻辑格式化，创建文件系统，包括创建文件系统的根目录，初始化存储空间管理所用的数据结构（如：位示图、空闲分区表）；</p><h4 id="引导块">引导块</h4><blockquote><p>计算机开机时需要进行一系列初始化工作，这些工作通过初始化程序（自举程序）完成；</p></blockquote><p><code>自举装入程序</code>通常放在ROM中，ROM中的数据出厂时就写入了，并且不能再修改；</p><p><code>完整的自举程序</code>放在磁盘的启动块上，启动块位于磁盘的固定位置（拥有启动分区的磁盘称为启动磁盘or系统磁盘）；</p><p>开机时，计算机先运行<code>自举装入程序</code>，通过该程序找到引导块，将<code>完整的自举程序</code>读入内存，完成初始化；</p><h4 id="坏块的管理">坏块的管理</h4><blockquote><p>无法使用的扇区属于硬件故障，操作系统无法修复，应该将其标记处理；</p></blockquote><p>对于简单的磁盘，可以在逻辑格式化时，对整个磁盘进行坏块检查，标明哪些扇区是坏扇区（比如：在FAT表上标明），这种方式，坏块对操作系统不透明；</p><p>对于复杂的磁盘，磁盘控制器（磁盘设备的一个硬件）会维护一个坏块链表，会保留一些备用扇区用于替换坏块，这种方法称为<code>扇区备用</code>，此方法中的坏块对操作系统透明；</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 内存管理</title>
      <link href="/myblog/2022/08/15/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-08-15-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/myblog/2022/08/15/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-08-15-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="内存概念">内存概念</h2><h3 id="基础知识">基础知识</h3><p>创建进程首先要将程序和数据装入内存，将用户源程序变为可在内存中执行的程序，通常需要以下三步：</p><ol><li><code>编译</code>：由编译程序将用户源代码翻译成若干目标模块；</li><li><code>链接</code>：由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块；</li><li><code>装入</code>：有装入程序将装入模块装入内存运行；</li></ol><h4 id="三种链接方式">三种链接方式</h4><p><strong>①静态链接</strong></p><p>在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开；</p><p><strong>②装入时动态链接</strong></p><p>将用户源程序编译后所得的一组目标模块，在装入内存时，采用边装入边链接的方式，其优点是便于修改和更新，实现对目标模块的共享；</p><p><strong>③运行时动态链接</strong></p><p>在程序执行中需要该目标模块时，才对它进行链接，优点是加快装入进程，还可节省内存空间；</p><h4 id="三种装入方式">三种装入方式</h4><p><strong>①绝对装入</strong></p><p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码，</p><p>只适用于<code>单道程序环境</code>；</p><p><strong>②静态重定位(可重定位装入)</strong></p><p>多道程序环境下，多个目标模块的起始地址通常都从0开始，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址；装入内存时根据内存情况装入合适的位置，装入时对地址进行<code>重定位</code>，逻辑地址变换为物理地址；</p><p><img src="https://img.lishangcc.top//img/image-20220818145322025.png" alt="image-20220818145322025"></p><p><strong>③动态重定位(动态运行时重定位)</strong></p><p>程序在内存中若发生移动，则需要采用动态的装入方式，装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行；（因此，装入内存后的所有地址均为相对地址，所以需要一个重定位寄存器）</p><h3 id="内存管理">内存管理</h3><h4 id="进程的内存映像">进程的内存映像</h4><p>不同于存放在硬盘上的可执行文件，当一个程序调入内存运行时，就构成了进程的内存映像，包括以下几个要素：</p><ul><li><code>代码段</code>：程序的二进制代码；该段是只读的，可被多个进程共享；</li><li><code>数据段</code>：程序运行时加工处理的对象，包括全局变量和静态变量；</li><li><code>进程控制块(PCB)</code>：存放在系统区，用来控制和管理进程；</li><li><code>堆</code>：由程序员分配与释放，若不释放，程序结束时由操作系统回收，如：malloc、free；（分配方式：低地址→高地址）</li><li><code>栈</code>：编译器自动分配释放，用于实现函数调用；（分配方式：高地址→低地址）</li></ul><p><img src="https://img.lishangcc.top//img/image-20220818150955770.png" alt="image-20220818150955770"></p><h4 id="内存保护">内存保护</h4><p>确保每个进程都有一个单独的内存空间，内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响；一般有以下两种方法：</p><ul><li>在CPU中设置一对上、下限寄存器，存放进程的上、下限地址，进程的指令要访问某个地址时，CPU检查是否越界；</li><li>采用<code>重定位寄存器</code>（基址寄存器）和<code>界地址寄存器</code>进行越界检查，重定位寄存器存放进程的<code>起始物理地址</code>，界地址寄存器存放进程的<code>最大逻辑地址</code>；</li></ul><h3 id="覆盖与交换">覆盖与交换</h3><p><strong>覆盖技术</strong></p><p><code>设计思想</code>：将程序分为多个段（多个模块），常用的段常驻内存中，不常用的段在需要时调入内存；</p><p><img src="https://img.lishangcc.top//img/image-20220815171457942.png" alt="image-20220815171457942"></p><p>固定区中的程序段在运行过程中不会调入调出；</p><p>覆盖区中的程序段在运行过程中会根据需要调入调出；</p><blockquote><p>一个例子</p><p><img src="https://img.lishangcc.top//img/image-20220815171646011.png" alt="image-20220815171646011"></p><p>设A(main)为常用函数，B和C函数不同时调用，D只有在调用B函数时才能调用，E和F只有在调用C时才能调用，且E和F不能同时调用；</p><p>此时，可以为A函数占用的8K内存设定固定区，B和C中取内存空间最大值设置覆盖区（10K），D、E和F也一样取最大的值设置覆盖区（12K），这样总的物理内存仅需要30K；</p><p>分区依据：不能被同时访问的程序段共享一个覆盖区；覆盖区大小取决于这些程序段占用空间的最大值；</p></blockquote><p>缺点：对用户不透明，增加了用户编程负担；</p><p><strong>交换技术</strong></p><p><code>设计思想</code>：内存空间紧张时，系统将内存中某些进程暂时换出外存（进程的PCB会常驻内存，不会被换出外存，而是会加入到挂起队列中），把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）；</p><blockquote><p>换出外存等待的进程状态为<code>挂起状态</code>；</p><p>内存调度（中级调度），就是要决定哪个挂起状态的进程重新调入内存；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220815172831127.png" alt="image-20220815172831127"></p><ul><li><p><strong>Q：应该在外存(磁盘)的什么位置保持被换出的进程？</strong></p><p>A：具有交换功能的操作系统，通常把磁盘空间分为<code>文件区</code>和<code>对换区</code>两部分；<code>文件区</code>用于存放文件，主要追求<code>存储空间的利用率</code>，因此对文件区空间的管理采用<code>离散分配方式</code>；<code>对换区</code>空间只占磁盘空间一小部分，<code>被换出的进程存放在对换区</code>，由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要<code>追求换入换出速度</code>，通常采用<code>连续分配方式</code>，所以对换区的I/O速度比文件区的更快；</p></li><li><p><strong>Q：什么时候应该交换？</strong></p><p>A：交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停，如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程，如果缺页率下降，就可以暂停换出；</p></li><li><p><strong>Q：应该换出哪些进程？</strong></p></li><li><p>A：可以优先换出阻塞进程、优先级低的进程等；</p></li></ul><h3 id="连续分配管理方式">连续分配管理方式</h3><p>连续分配：用户进程分配的必须是一个连续的内存空间；</p><p>内部碎片：分配给某进程的内存空间中，有些部分没用上；</p><p>外部碎片：内存中某些空闲分区因太小而难以使用；</p><h4 id="单一连续分配">单一连续分配</h4><p>该方式中，内存分为系统区和用户区，内存中只能有一道用户程序，用户程序独占整个用户区空间；</p><p><img src="https://img.lishangcc.top//img/image-20220815183941542.png" alt="image-20220815183941542"></p><p>优点：实现简单，无外部碎片，可采用覆盖技术扩充内存；</p><p>缺点：只能用于单用户、单任务的操作系统，有内部碎片，存储器利用率极低；</p><h4 id="固定分区分配">固定分区分配</h4><p>将整个用户空间划分为若干个固定大小的分区，在每个分区中只能装入一道作业；</p><blockquote><p>两种方式：</p><p><code>分区大小相等</code>：缺乏灵活性，但很适用于用一台计算机控制多个相同对象的场合；</p><p><code>分区大小不同</code>：增加了灵活性，可以满足不同大小的进程的需求；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220815184345346.png" alt="image-20220815184345346"></p><p>需要建立<code>分区说明表</code>，实现各个分区的分配和回收，每个表项应包含：大小、起始地址、状态（是否已分配）；</p><p><img src="https://img.lishangcc.top//img/image-20220815184611367.png" alt="image-20220815184611367"></p><p>优点：实现简单，无外部碎片；</p><p>缺点：当用户程序太大时，可能所有分区均无法满足（可用覆盖技术解决）；依然会产生内部碎片，内存利用率低；</p><h4 id="动态分区分配">动态分区分配</h4><p>不会预先划分内存分区，而是进程装入内存时，根据进程大小动态地建立分区</p><p><img src="https://img.lishangcc.top//img/image-20220815200158122.png" alt="image-20220815200158122"></p><p>Q：系统用什么样的数据结构记录内存使用情况？</p><p><img src="https://img.lishangcc.top//img/image-20220815200413715.png" alt="image-20220815200413715"></p><p>无内部碎片，但有外部碎片（可通过&quot;紧凑&quot;技术解决）；</p><h3 id="动态分区分配算法">动态分区分配算法</h3><p>解决当很多个空闲分区都满足需求时，应该选择哪个分区进行分配。</p><h4 id="首次适应算法-First-Fit">首次适应算法(First Fit)</h4><p><code>算法思想</code>：每次从低地址开始查找，找到第一个满足大小的空闲分区；</p><p><code>实现</code>：空闲分区以<code>地址递增次序</code>排序；</p><h4 id="最佳适应算法-Best-Fit">最佳适应算法(Best Fit)</h4><p><code>算法思想</code>：优先使用小的内存空间，尽可能留下更多的大片空间；</p><p><code>实现</code>：空闲分区按<code>容量递增次序</code>排序；</p><p><code>缺点</code>：①会产生很多外部碎片；②算法开销大，回收分区后可能要对空闲分区队列重新排序；</p><h4 id="最坏适应算法-Worst-Fit">最坏适应算法(Worst Fit)</h4><p><code>算法思想</code>：优先使用最大的连续空闲区；</p><p><code>实现</code>：空闲分区按<code>容量递减次序</code>排序；</p><p><code>缺点</code>：①大的内存的空间被用完，导致大进程到来可能没有可用的内存分区；②算法开销大；回收分区后，可能要对空闲分区队列重新排序；</p><h4 id="邻近适应算法-Next-Fit">邻近适应算法(Next Fit)</h4><p><code>算法思想</code>：每次都从上次查找结束的位置开始检索，找到第一个满足大小的空闲分区；（首次适应算法的改进）</p><p><code>实现</code>：空闲分区按<code>地址递增次序</code>排列；</p><p><code>缺点</code>：可能使小进程占用大空间，从而减少大空间区域，使得大进程到来可能无可用空间；</p><h3 id="基本分页存储管理">基本分页存储管理</h3><h4 id="分页存储概念">分页存储概念</h4><p><code>页框</code>：将内存分为一个个大小相等的分区，每个分区就是一个&quot;页框&quot;（页框=内存块=物理块=物理页面=页帧）；</p><p><code>页框号</code>：每个页框都有一个编号，<code>页框号从0开始</code>；</p><p><code>页面</code>：将<code>进程的逻辑地址空间</code>也分为与<code>页框大小相等</code>的一个个部分，每个部分称为一个 “页面” 或 “页”，每个页面也有一个编号，即&quot;页号&quot;，页号也是从0开始；</p><p><img src="https://img.lishangcc.top//img/image-20220815205228393.png" alt="image-20220815205228393"></p><blockquote><p>操作系统以页框为单位为各个进程分配内存空间，进程的每个页面分别让入一个页框中，也就是说，<code>进程的页面与内存的页框有一一对应的关系</code>；</p><p>注：进程的最后一个页面可能没有一个页框那么大，所以分页存储可能产生内部碎片，所以页框不用设得太大；</p></blockquote><p><code>页表</code>：为了使操作系统能够知道进程每个页面在内存中的存放位置；</p><blockquote><ol><li>一个进程对应一张页表；</li><li>进程的每个页面对应一个页表项；</li><li>每个页表项由 页号 和 块号 组成；</li><li>页表记录进程页面和实际存放的内存块之间的映射关系；</li><li>每个页表项的长度是相同的；</li></ol></blockquote><p><img src="https://img.lishangcc.top//img/image-20220815205723511.png" alt="image-20220815205723511"></p><blockquote><p><strong>Eg：假如某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少为多少字节？</strong></p><p><img src="https://img.lishangcc.top//img/image-20220815205942385.png" alt="image-20220815205942385"></p><p>注：页号是隐含的，不占用空间；</p></blockquote><p><strong>如何实现地址的转换？</strong></p><p>页号 = 逻辑地址 / 页面长度；</p><p>页内偏移量 = 逻辑地址 % 页面长度；</p><p>物理地址 = 页面地址 + 页内偏移量；</p><blockquote><p>Q：如何访问逻辑地址A？</p><p>A：①确定逻辑地址A对应的页号P；②找到P号页面在内存中的起始地址（查页表）；③确定逻辑地址A的页内偏移量W；④逻辑地址A对应的物理地址 = P号页面在内存中的起始地址 + 页面偏移量W；</p><p>Eg：某计算机系统中，页面大小是50B，某进程逻辑地址空间大小为200B，逻辑地址110对应的页号、页内偏移量是多少？</p><p>答：页号 =110 / 50 = 2；页内偏移量 = 110 % 50 =10；</p></blockquote><p>使用二进制表示：</p><p><img src="C:/Users/LS/AppData/Roaming/Typora/typora-user-images/image-20220815211850182.png" alt="image-20220815211850182"></p><p>逻辑地址结构：</p><p><img src="https://img.lishangcc.top//img/image-20220815212039596.png" alt="image-20220815212039596"></p><h4 id="基本地址变换机构">基本地址变换机构</h4><p><code>页表寄存器（PTR）</code>：存放页表在内存中的<code>起始地址F</code>和<code>页表长度M</code>（这两个信息进程未执行时，存放在进程控制块PCB中，进程被调度时，放在页表寄存器中）；</p><p><strong>逻辑地址转换物理地址过程：</strong></p><p><img src="https://img.lishangcc.top//img/image-20220816221405387.png" alt="image-20220816221405387"></p><p>①计算页号P和页内偏移地址W；</p><p>②比较页号P和页表长度M，若P&gt;=M，则产生越界中断，否则继续执行；（页号从0开始，而页表长度至少是1，所以P=M也会越界）；</p><p>③页号P对应的页表项地址 = 页表起始地址F + 页号P * 页表项长度；取出该页表项内容b；</p><p>④计算 E = b * L + W，L为页面大小，用得到的物理地址E去访存；（如果内存块号、页面偏移量是用二进制表示，那么把二者拼接起来就是最终的物理地址）；</p><blockquote><p>例：若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E；</p><p>（等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位，页号2对应的内存块号为b = 8，将逻辑地址A=2500转换为物理地址E）</p><p><img src="https://img.lishangcc.top//img/image-20220817000357460.png" alt="image-20220817000357460"></p></blockquote><blockquote><p>形象理解：</p><p>一个进程可以理解为一行行文字的集合，存放在一本书中（内存），你要查找某一行，你得查找他在哪一页，并且自己记住在哪一行（偏移量），此时根据页号去翻目录找内存中的地址（页表），找到那一页（页框），根据偏移量定位那句话；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220817003703146.png" alt="image-20220817003703146"></p><h4 id="具有快表的地址变换机构">具有快表的地址变换机构</h4><p><code>快表(TLB)</code>：是一种访问速度比内存速度快很多的高速缓存（cache），用来存放最近访问的页表项的副本，可以加速地址变换的速度；</p><p><strong>引入快表的地址的变换过程</strong>：</p><p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较；</p><p>②如果找到匹配的页号，说明访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，将内存块号与页内偏移量拼接成物理地址，最后访问该物理地址对应的内存单元；（仅需一次访存）</p><p>③如果没有找到匹配页号，则需要访问内存中的页表；（需要两次访存）</p><blockquote><p><img src="https://img.lishangcc.top//img/image-20220817161055400.png" alt="image-20220817161055400"></p><p><img src="https://img.lishangcc.top//img/image-20220817161156935.png" alt="image-20220817161156935"></p></blockquote><p><strong>局部性原理</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817161332442.png" alt="image-20220817161332442"></p><p><strong>总结</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817161400323.png" alt="image-20220817161400323"></p><h4 id="两级页表">两级页表</h4><p><strong>单级页表存在的问题</strong></p><p>①页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框；</p><p>②没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某个特定的页面；</p><p><strong>两级页表结构</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817162646480.png" alt="image-20220817162646480"></p><p>（页表也会占用内存块，所以一级页表记录二级页表的内存块号）</p><blockquote><p>注意：</p><p>1.若采用多级页表机制，则各个页表的大小不能超过一个页面；</p><p><img src="https://img.lishangcc.top//img/image-20220817175807643.png" alt="image-20220817175807643"></p><p>2.多级页表的访存次数（假设没有快表机构）：N级页表访问一个逻辑地址需要N+1次访存；</p></blockquote><p><strong>总结</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817180559579.png" alt="image-20220817180559579"></p><h3 id="基本分段存储管理">基本分段存储管理</h3><blockquote><p>与分页最大的区别就是：离散分配时所分配地址空间的基本单位不同；</p></blockquote><p><strong>分段</strong></p><p>段式管理方式按照用户进程中的自然段划分逻辑空间；</p><p><img src="https://img.lishangcc.top//img/image-20220817203455318.png" alt="image-20220817203455318"></p><p><strong>段表</strong></p><p>每个进程都有一张逻辑空间与内存空间映射的段表，其中每个段表项对应进程的一段，段表项纪录该段在内存中的起始地址和段长；</p><p><img src="https://img.lishangcc.top//img/image-20220817203715894.png" alt="image-20220817203715894"></p><p><strong>地址转换</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817204052190.png" alt="image-20220817204052190"></p><p><strong>分页与分段的对比</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817204206213.png" alt="image-20220817204206213"></p><p><img src="https://img.lishangcc.top//img/image-20220817204630598.png" alt="image-20220817204630598"></p><h3 id="段页式管理方式">段页式管理方式</h3><p>段页式管理 = 分段 + 分页；</p><p><img src="https://img.lishangcc.top//img/image-20220817212312012.png" alt="image-20220817212312012"></p><p><strong>逻辑地址结构</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817212401799.png" alt="image-20220817212401799"></p><p><strong>段表和页表</strong></p><p>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成；</p><p>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成；</p><p><img src="https://img.lishangcc.top//img/image-20220817212642922.png" alt="image-20220817212642922"></p><p><strong>地址转换</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817212731502.png" alt="image-20220817212731502"></p><p><strong>总结</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817212754275.png" alt="image-20220817212754275"></p><h2 id="虚拟内存">虚拟内存</h2><h3 id="虚拟内存基本概念">虚拟内存基本概念</h3><p>虚拟存储技术基于局部性原理（时间局部性、空间局部性）；</p><blockquote><p>虚拟内存三个特征：</p><ul><li>多次性：</li><li>对换性：</li><li>虚拟性：</li></ul></blockquote><p><img src="https://img.lishangcc.top//img/image-20220817214147495.png" alt="image-20220817214147495"></p><h3 id="请求分页管理方式">请求分页管理方式</h3><blockquote><p>请求分页与基本分页的区别：</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行；</p><p>若内存不够，由操作系统负责将内存中暂时用不到的信息换出到外存；</p></blockquote><p><strong>页表机制</strong></p><p>在请求分页管理中，为了实现请求调页，操作系统需要知道每个页面是否调入内存；</p><p>当内存空间不够，要实现页面置换；</p><p><strong>请求分页存储管理页表</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817232513540.png" alt="image-20220817232513540"></p><p><strong>缺页中断机构</strong></p><p>在请求分页系统中，每当要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存；</p><p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再唤醒放回就绪队列；</p><p>如果内存中有空闲块，则直接为进程分配一个空闲块，将所缺页面装入，并修改页表中相应的页表项；</p><p>如果没有空闲块，则由页面置换算法淘汰一个页面；</p><blockquote><p>缺页中断属于内中断（内部异常）；</p><p>一条指令执行期间，可能产生多次缺页中断；</p></blockquote><p><strong>地址变换机构</strong></p><ol><li>找到页表项检查页面是否在内存中；</li><li>若页面不在内存中，请求调页；</li><li>若内存空间不够，则需要换出页面；</li><li>页面调入内存后，需要修改相应页表项；</li></ol><blockquote><p>补充：</p><ul><li>只有写命令才需要修改 “修改位”，并且，一般只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表，这样以减少访存次数；</li><li>和普通中断处理一样，缺页中断也要保留CPU现场；</li><li>换入 换出页面都需要启动慢速的I/O操作；</li><li>页面调入内存后，需要修改慢表，同时也要将表项复制到快表中；</li></ul></blockquote><h3 id="页面置换算法">页面置换算法</h3><h4 id="最佳置换算法-OPT">最佳置换算法(OPT)</h4><p><code>算法思想</code>：每次选择淘汰的页面将是<code>以后再也不使用的</code>，或者`在最长时间内不再被访问的页面``，以保证最低的缺页率；</p><p><img src="https://img.lishangcc.top//img/image-20220817235128079.png" alt="image-20220817235128079"></p><blockquote><p>实际上，操作系统无法提前预判页面访问序列，因此这个算法是无法实现的；</p></blockquote><h4 id="先进先出置换算法-FIFO">先进先出置换算法(FIFO)</h4><p><code>算法思想</code>：淘汰的页面是<code>最早进入内存的页面</code>；</p><p><img src="https://img.lishangcc.top//img/image-20220817235518863.png" alt="image-20220817235518863"></p><blockquote><p>注意：若分配四个内存块时，上述序列会产生10次缺页次数；（Belady异常）</p><p><code>Belady异常</code>：当为进程分配的物理块数增大时，缺页次数不减反增的现象；</p><p>只有FIFO算法会产生Belady异常；</p><p>因为先进入的页面也有可能被经常访问，因此此算法性能比较差；</p></blockquote><h4 id="最近最久未使用置换算法-LRU">最近最久未使用置换算法(LRU)</h4><p><code>算法思想</code>：每次淘汰的页面是<code>最近最久未使用的页面</code>；</p><p><img src="https://img.lishangcc.top//img/image-20220818000147369.png" alt="image-20220818000147369"></p><blockquote><p>该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大；</p></blockquote><h4 id="时钟置换算法-CLOCK">时钟置换算法(CLOCK)</h4><p><code>算法思想</code>：为每个页面设置一个访问位，将内存中的页面都通过链接指针链接成一个循环队列，当某页被访问时，访问位置1，当需要淘汰一个页面时，只需检查页的访问位，是0，则该页换出，是1，则将其置0，并且暂不换出，继续检查下一个页面；若第一轮扫描中所有页面都是1，则进行第二轮检查（这一轮一定会有访问位为0的页面，因此该算法淘汰一个页面最多经过两轮扫描）；</p><h4 id="改进型时钟置换算法">改进型时钟置换算法</h4><p><img src="https://img.lishangcc.top//img/image-20220818001647270.png" alt="image-20220818001647270"></p><h4 id="算法总结">算法总结</h4><p><img src="https://img.lishangcc.top//img/image-20220818001729637.png" alt="image-20220818001729637"></p><h2 id="页面分配策略">页面分配策略</h2><p><code>驻留集</code>：指请求分页存储管理中给进程分配物理块的集合；</p><blockquote><p>在采用虚拟存储技术系统中，驻留集一般小于进程的总大小；</p><p>若驻留集太小，会导致缺页频繁；若驻留集太大，又会导致多道程序并发度下降；</p></blockquote><p><code>固定分配(驻留集大小不变)</code>：操作系统为每个进程分配一组固定数目的物理块，进程运行期间不变；</p><p><code>可变分配(驻留集大小可变)</code>：先为每个进程分配一定数目的物理块，进程运行期间，可根据情况增加或减少；</p><p><code>局部置换</code>：发生缺页时只能选择进程自己的物理块进行置换；</p><p><code>全局置换</code>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程；</p><p><img src="https://img.lishangcc.top//img/image-20220818123140889.png" alt="image-20220818123140889"></p><p><code>固定分配局部置换</code>：进程运行前就分配一定数量的物理块，缺页时只能换出进程自己的某一页；</p><p><code>可变分配全局置换</code>：只要缺页就分配新物理块，可能来自空闲物理块，也可能需要换出别的进程页面；</p><p><code>可变分配局部置换</code>：频繁缺页的进程，多分配一些物理块，缺页率很低的进程，回收一些物理块，直到缺页率合适；</p><p><code>抖动现象</code>：刚换出的页面又马上换入内存，刚刚换入的页面又马上换出外存，这种频繁的页面调度称为抖动；</p><blockquote><p>抖动的主要原因：进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块数不够）；</p></blockquote><p><code>工作集</code>：某段时间间隔内，进程实际访问页面的集合；一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页；</p><p><img src="https://img.lishangcc.top//img/image-20220818142416018.png" alt="image-20220818142416018"></p><h2 id="内存映射文件">内存映射文件</h2><p>内存映射文件——操作系统向上层程序员提供功能（系统调用）；</p><p>内存映射文件与虚拟内存相似，将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，而不必执行I/O操作，也无需对文件内容进行缓存处理，适合用来管理大尺寸文件；</p><p><img src="https://img.lishangcc.top//img/image-20220818143550104.png" alt="image-20220818143550104"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 进程与线程(下)</title>
      <link href="/myblog/2022/08/04/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-08-04-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B2/"/>
      <url>/myblog/2022/08/04/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-08-04-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<h2 id="调度的概念">调度的概念</h2><p><strong>高级调度（作业调度）</strong></p><p>按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程，每个作业只调入一次，调出一次；作业调入时会建立PCB，调出时才撤销PCB；</p><p><strong>中级调度（内存调度）</strong></p><blockquote><p>背景：内存不够时，可将某些进程的数据调出到外存，等内存空闲或者进程需要运行时再重新调入内存；展示调到外存等待的进程的状态为挂起状态，被挂起的进程PCB会被组织成挂起队列；</p></blockquote><p>按照某种策略决定将哪个处于挂起状态的进程重新调入内存，一个进程肯会多次调出、调入内存，因此中级调度发生的频率比高级调度高；</p><p><strong>初级调度（进程调度/处理机调度）</strong></p><p>按照某种策略从就绪队列中选取一个进程，将处理机分配给它；</p><p>进程调度是操作系统中<code>最基本的一种调度</code>，在一般的操作系统中都必须配置进程调度；</p><p>进程调度的频率很高；</p><p><strong>三者对比</strong></p><p><img src="https://img.lishangcc.top//img/image-20220804210956975.png" alt="image-20220804210956975"></p><h2 id="进程调度的时机">进程调度的时机</h2><p><strong>需要进行进程调度与切换的情况</strong></p><blockquote><p>当前运行的进程<code>主动放弃</code>处理机：</p><ul><li>进程正常终止；</li><li>运行过程中发生异常而终止；</li><li>进程主动请求阻塞（如：等待I/O）；</li></ul><p>当前运行的进程<code>被动放弃</code>处理机：</p><ul><li>分给进程的时间片用完；</li><li>有更紧急的事需要处理（如：I/O中断）；</li><li>有更高优先级的进程进入就绪队列；</li></ul></blockquote><p><strong>不能进行进程调度与切换的情况</strong></p><blockquote><ul><li>处理中断过程中；</li><li>进程在操作系统内核程序临界区中；</li><li>在原子操作过程中；</li></ul></blockquote><blockquote><p><strong>临界资源</strong>：一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源；</p><p><strong>临界区</strong>：访问临界资源的那段代码；</p></blockquote><h2 id="调度程序-调度器">调度程序(调度器)</h2><p>用于调度和分派CPU的组件称为调度程序，通常由三部分组成：排队器、分派器、上下文切换器；</p><p>就绪态与运行态之间的相互切换由调度程序引起；</p><p>调度程序决定：让谁运行（通过调度算法），运行多长时间（通过时间片大小）。</p><p>触发调度程序的事件：创建新进程、进程退出、运行进程阻塞、I/O中断发生（可能唤醒某些阻塞进程）。</p><p><strong>闲逛进程</strong>：调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程（idle）；</p><blockquote><p>闲逛进程特征：①优先级最低，②可以是0地址指令，占一个完整的指令周期，③能耗低；</p></blockquote><h2 id="调度算法">调度算法*</h2><blockquote><p>非剥夺调度方式（非抢占方式）：只允许进程主动放弃处理机，实现简单，系统开销小，但是无法及时处理紧急任务，适用于早期的批处理系统；</p><p>剥夺调度方式（抢占方式）：当一个进程正在处理机上执行时，如果有一个更重要的进程需要使用处理机，则立即暂停当前正在执行的进程，将处理机及时分配出去；适用于分时操作系统、实时操作系统；</p></blockquote><p>周转时间 = 完成时间 - 到达时间</p><p>带权周转时间 = 周转时间 / 运行时间</p><p>等待时间 = 周转时间 - 运行时间</p><h3 id="先来先服务（FCFS）">先来先服务（FCFS）</h3><p><strong>算法思想</strong>：出于&quot;公平&quot;角度考虑，类似于生活中排队买东西；</p><p><strong>算法规则</strong>：按照作业/进程到达的先后顺序进行服务；</p><p><strong>是否可抢占</strong>：非抢占式算法；</p><p><strong>优点</strong>：公平，算法实现简单；</p><p><strong>缺点</strong>：排在长进程(或作业)后面的短进程需要等待很长时间，<code>带权周转时间很大</code>，对长作业有利，对短作业不利；</p><p><strong>是否导致饥饿</strong>：不会；</p><h3 id="短作业优先（SJF）">短作业优先（SJF）</h3><blockquote><p>短作业优先（SJF）<br>短进程优先（SPF）<br>最短剩余时间优先（SRTN）</p></blockquote><p><strong>算法思想</strong>：追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间；</p><p><strong>算法规则</strong>：最短的作业/进程优先得到服务（所谓最短，指要求服务时间最短）；</p><p><strong>是否可抢占</strong>：SJF和SPF默认非抢占（SRTN抢占）；</p><p><strong>优点</strong>：<code>在所有进程同时可运行时</code>或<code>所有进程几乎同时到达</code>，最短的平均等待时间、平均周转时间；</p><p><strong>缺点</strong>：不公平，对短作业有利，对长作业不利，可能产生饥饿现象；另外运行时间由用户提供，不一定能做到真正的短作业优先；</p><p><strong>是否导致饥饿</strong>：会，如果不停有短作业到来，可能使长作业长时间得不到服务；</p><h3 id="高响应比优先（HRRN）">高响应比优先（HRRN）</h3><p><strong>算法思想</strong>：要综合考虑作业/进程的等待时间和要求服务时间；</p><p><strong>算法规则</strong>：在每次调度时，先计算各个作业/进程的响应比，选择响应比最高的服务；</p><blockquote><p>响应比 = (等待时间+要求服务时间) / 要求服务时间；</p></blockquote><p><strong>是否可抢占</strong>：非抢占；</p><p><strong>特点</strong>：综合考虑了等待时间和运行时间；</p><blockquote><ol><li>等待时间相同，要求服务时间短的优先；</li><li>要求服务时间相同，等待时间长的优先；</li><li>对于长作业，其响应比随着时间增加而增加，避免了饥饿现象；</li></ol></blockquote><p><strong>是否导致饥饿</strong>：不会；</p><h3 id="时间片轮转调度算法（RR）">时间片轮转调度算法（RR）</h3><p><strong>算法思想</strong>：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都得到响应；</p><p><strong>算法规则</strong>：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms），若进程未在一个时间片内执行完，则剥夺处理机，将进程放入就绪队列队尾；</p><blockquote><p>一般仅用于进程调度（因为只有作业放入内存并建立相应进程后，才能被分配处理机时间片）。</p></blockquote><p><strong>是否可抢占</strong>：抢占式；</p><p><strong>优点</strong>：公平，响应快，适用于分时操作系统；</p><p><strong>缺点</strong>：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度；</p><p><strong>是否导致饥饿</strong>：不会；</p><h3 id="优先级调度算法">优先级调度算法</h3><p><strong>算法思想</strong>：许多应用场景需要根据任务的紧急程度来决定处理顺序；</p><p><strong>算法规则</strong>：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程；</p><p><strong>是否可抢占</strong>：两者均有；</p><p><strong>优点</strong>：区分紧急程度，适用于实时操作系统；</p><p><strong>缺点</strong>：如果不停有优先级高的进程到来，可能导致饥饿；</p><p><strong>是否导致饥饿</strong>：会；</p><h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3><p><strong>算法思想</strong>：对其他调度的算法的折中权衡；</p><p><strong>算法规则</strong>：</p><ol><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大；</li><li>新进程到达时，先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程未结束，则进程进入下一级队列队尾，如果此时已在最后一级，则直接放入队尾；</li><li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片；</li></ol><p><strong>是否可抢占</strong>：抢占式；</p><p><strong>特点</strong>：综合了FCFS、RR、SPF的优点；</p><p><strong>是否导致饥饿</strong>：会；</p><h3 id="多级队列调度算法">多级队列调度算法</h3><p>设置多个就绪队列，将不同类型或性质的进程固定分配到不同的就绪队列，每个队列可以实施不同的调度算法。</p><h2 id="进程同步与互斥">进程同步与互斥</h2><p><strong>进程同步概念</strong>：进程同步是用来解决异步问题的，在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的制约关系，为了协调进程之间的相互制约关系，引入进程同步的概念；</p><blockquote><p>简单点理解：两个或多个进程需要按照某种顺序执行；</p></blockquote><p><strong>进程互斥概念</strong>：A进程访问某种临界资源，此时B也想访问该临界资源，进程B必须等待A访问完成后才能访问该临界资源；</p><blockquote><p>对临界资源的访问，必须互斥地进行，每个进程中，访问临界资源的那段代码称为<code>临界区</code>，临界资源的访问过程通常分为4个部分；</p><ol><li><code>进入区</code>：检查是否可以进入临界区，若可进入，则设置正在啊访问临界区的标志（即上锁）；</li><li><code>临界区</code>：访问临界资源的那段代码；</li><li><code>退出区</code>：负责解除正在访问临界资源的标志（即解锁）；</li><li><code>剩余区</code>：代码中的其余部分；</li></ol></blockquote><p>为禁止两个进程同时进入临界区，进程互斥应遵循以下原则：</p><ul><li><code>空闲让进</code>：临界区空闲时，可以允许一个请求进入临界区的进程立即进入；</li><li><code>忙则等待</code>：当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li><code>有限等待</code>：对请求访问的进程，应保证能在有限时间内进入临界区（防止饥饿）；</li><li><code>让权等待</code>：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待；</li></ul><h2 id="进程互斥的软件实现方式">进程互斥的软件实现方式</h2><h3 id="单标志法">单标志法</h3><p>两个进程在访问完临界区后会把该临界区的使用权转交给另一个进程（临界区的使用权只能由另一个进程赋予）；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：违背&quot;空闲让进&quot;原则（临界区的使用权只能由另一个进程赋予，若P0想访问临界区，必须在P1访问完临界区将turn改为0，但P1可能不打算进入临界区）；</p></blockquote><h3 id="双标志先检查法（先检查后上锁）">双标志先检查法（先检查后上锁）</h3><p>算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，在各个进程访问临界区前，先检查临界区资源是否被访问，若正在被访问则该进程需等待；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><blockquote><p>优点：不用交替进入，可连续使用；</p><p>缺点：Pi和Pj进程可能同时进入临界区，违背&quot;忙则等待&quot;原则（在Pi进程检查完后，可能会切换到Pj进程，此时两边的标志位均为上锁）；</p></blockquote><h3 id="双标志后检查法（先上锁后检查）">双标志后检查法（先上锁后检查）</h3><p>算法思想：先将自己的标志设置为true，再检查对方进程的状态标志；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：违背&quot;空闲让进&quot;和&quot;有限等待&quot;原则，会导致饥饿现象；即两个进程都争着访问临界资源，结果谁都进不了临界区；</p></blockquote><h3 id="Peterson算法">Peterson算法</h3><p>算法思想：如果双方都争着进入临界区，则让对方先访问；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：未遵循&quot;让权等待&quot;原则；若想要进入临界区的进程无法进入临界区，则会卡在while循环；</p></blockquote><h2 id="进程互斥的硬件实现">进程互斥的硬件实现</h2><h3 id="中断屏蔽方法">中断屏蔽方法</h3><p>利用&quot;开/关中断指令&quot;实现，在访问临界区前关中断，在访问临界区后开中断；</p><blockquote><p>优点：简单高效；</p><p>缺点：只适用于单处理机；只适用于操作系统内核进程，不适用于用户进程；</p></blockquote><h3 id="TestAndSet指令">TestAndSet指令</h3><p>这条指令用硬件实现，执行期间不允许被中断；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布尔型共享变量lock表示当前临界区是否被加锁；</span></span><br><span class="line"><span class="comment">//true已加锁，false未加锁；</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span> *lock)</span>&#123;</span><br><span class="line"><span class="type">bool</span> old;</span><br><span class="line">old = *lock;<span class="comment">//old存放lock原来的值；</span></span><br><span class="line">*lock = <span class="literal">true</span>;<span class="comment">//无论之前是否加锁，都将lock设为true；</span></span><br><span class="line"><span class="keyword">return</span> old;<span class="comment">//返回lock原来的值；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TestAndSet(&amp;lock));</span><br><span class="line">critical section;</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>通过old变量记录之前是否上锁，无论上锁与否都将进行上锁操作，若之前已上锁，TestAndSet上锁操作不影响当前状态，若之前未上锁，则TestAndSet上锁表示自己将要访问临界区；</p><h3 id="Swap指令">Swap指令</h3><p>这条指令也是用硬件实现，执行期间不允许被中断；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换两个变量的值</span></span><br><span class="line">Swap(<span class="type">bool</span> *a, <span class="type">bool</span> *b)&#123;</span><br><span class="line">    <span class="type">bool</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lock表示当前临界资源是否上锁</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(old == <span class="literal">true</span>)</span><br><span class="line">    Swap(&amp;lock, &amp;old);</span><br><span class="line">critical section;</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>Swap指令与TestAndSet指令逻辑上基本相同，通过old变量记录当前是否上锁，若old为true再将lock设置为true，最后再检查old，此时old为false则说明之前没有别的进程对临界区上锁，则跳出循环进入临界区；</p><blockquote><p>以上两种指令适用于多处理机环境，但不满足&quot;让权等待&quot;（若有进程正在访问临界区，则其他想要访问该临界区的进程会一直卡在while循环）；</p></blockquote><h2 id="互斥锁">互斥锁</h2><p>可以简单理解为一个布尔型的变量，表示当前已上锁或未上锁，进入临界区通过aquire()获得锁，退出临界区通过release()释放锁；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;<span class="comment">//获得锁</span></span><br><span class="line"><span class="keyword">while</span>(!available);<span class="comment">//判断当前所是否可用；</span></span><br><span class="line">available = <span class="literal">false</span>;<span class="comment">//修改为不可用状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">release()&#123;<span class="comment">//释放锁</span></span><br><span class="line">available = <span class="literal">true</span>;<span class="comment">//修改为可用状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：违反&quot;让权等待&quot;原则；</p></blockquote><h2 id="信号量机制">信号量机制</h2><p><code>信号量</code>：一个变量，用来表示系统中某种资源的数量；</p><p><code>原语</code>：一种特殊程序段，一气呵成执行，有开/关中断指令实现；</p><p><code>wait(S)和signal(S)原语</code>：也可分别写为P(S)、V(S)，信号量S作为传入参数；</p><h3 id="整型信号量">整型信号量</h3><p>对信号量的操作只有三种：①初始化；②P操作；③V操作；</p><p><img src="https://img.lishangcc.top//img/image-20220809152955572.png" alt="image-20220809152955572"></p><p><code>wait原语作用</code>：①循环检查当前资源是否够用，够用则跳出循环，不够用则循环到够用为止（违反&quot;让权等待&quot;原则）；②将资源分配给当前进程，即<code>系统资源数 - 1</code>;</p><p><code>signal原语作用</code>：将进程占用的系统资源归还，即<code>系统资源数 + 1</code>；</p><h3 id="记录型信号量">记录型信号量*</h3><blockquote><p>用于解决整型信号量中存在忙等待的问题；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220809154108883.png" alt="image-20220809154108883"></p><ul><li><strong>执行wait原语时</strong>，意味着<code>进程请求一个单位的资源</code>，资源数减1，若剩余资源不够分配（即S.value&lt;0），调用block原语，将会把进程从运行态变为阻塞态，并且把该进程挂到信号量S对应的等待队列中；</li><li><strong>执行signal原语时</strong>，意味着<code>释放一个单位的资源</code>，并且多了一个<code>当前剩余资源的判断</code>，资源数加1后若当前剩余资源&lt;=0，说明此时有其他进程正在等待使用该资源，则从信号量S对应的等待队列中<code>唤醒一个进程</code>，并将该进程<code>从阻塞态变为就绪态</code>；</li></ul><h2 id="用信号量实现进程互斥、同步、前驱关系">用信号量实现进程互斥、同步、前驱关系</h2><h3 id="信号量实现进程互斥">信号量实现进程互斥</h3><ol><li>分析并发进程关键活动，划定临界区；</li><li>设置<code>互斥信号量 mutex = 1</code>；</li><li>P、V操作成对出现，进入区P(mutex)，退出区V(mutex)；</li></ol><h3 id="信号量实现进程同步">信号量实现进程同步</h3><blockquote><p>进程同步：让各并发进程按要求有序推进；</p></blockquote><ol><li>分析需要同步的活动，即必须保证一前一后执行两个操作；</li><li>设置<code>同步信号量 S = 0</code>；</li><li>前V后P，在前操作之后执行V(S)，在后操作之前执行P(S)；</li></ol><h3 id="信号量实现前驱关系">信号量实现前驱关系</h3><p>本质即：多级同步问题；</p><p>如图，进程P1中有局代码S1，P2中有句代码S2…P6中有句代码S6，按如下前驱图执行（如S2要在S1后执行）；</p><p><img src="https://img.lishangcc.top//img/image-20220809171440391.png" alt="image-20220809171440391"></p><ol><li>分析问题，画出前驱图，每一对前驱关系看成一个同步问题；</li><li>为每一对前驱关系设置同步信号量，初值为0；</li><li>前V后P；</li></ol><p><strong>总结</strong></p><p><img src="https://img.lishangcc.top//img/image-20220809171921077.png" alt="image-20220809171921077"></p><h2 id="生产者-消费者">生产者-消费者</h2><p><code>问题描述</code>：系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品使用（产品可以理解为某种数据）；</p><p>生产者、消费者共享一个初始为空、大小为n的缓冲区；</p><p>缓冲区没满→生产者生产；</p><p>缓冲区没空→消费者消费；</p><p>缓冲区是临界资源，各进程必须<code>互斥访问</code>；</p><p><img src="https://img.lishangcc.top//img/image-20220809180423314.png" alt="image-20220809180423314"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥信号量，实现对缓冲区的互斥访问；</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//同步信号量，表示空闲缓冲区数量；</span></span><br><span class="line">semaphore empty = n;</span><br><span class="line"><span class="comment">//同步信号量，表示产品数量，也即非空缓冲区数量；</span></span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">producer()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">生产一个产品;</span><br><span class="line">P(empty);</span><br><span class="line">P(mutex);</span><br><span class="line">把产品放入缓冲区;</span><br><span class="line">V(mutex);</span><br><span class="line">V(full);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(full);</span><br><span class="line">P(mutex);</span><br><span class="line">从缓冲区取出产品;</span><br><span class="line">V(mutex);</span><br><span class="line">V(empty);</span><br><span class="line">使用产品;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少；</p><p>实现互斥P操作一定要在同步P操作之后，防止死锁；</p></blockquote><h2 id="多生产者-多消费者">多生产者-多消费者</h2><p><code>问题描述</code>：桌面上有一个盘子，每次只能放入一个水果，爸爸放苹果，妈妈放橘子，儿子只吃橘子，女儿只吃苹果，只有盘子空时，爸妈才能放一个水果，仅当盘子有自己需要的水果时，儿子或女儿可以取出水果；</p><p><img src="https://img.lishangcc.top//img/image-20220809233413458.png" alt="image-20220809233413458"></p><ul><li>互斥关系：对盘子（缓冲区）的访问是互斥的；</li><li>同步关系：父亲→女儿；母亲→儿子；女儿/儿子→父亲/母亲；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore plate = <span class="number">1</span>;</span><br><span class="line">semaphore apple = <span class="number">0</span>;</span><br><span class="line">semaphore orange = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dad()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">准备一个苹果;</span><br><span class="line">P(plate);</span><br><span class="line">P(mutex);</span><br><span class="line">将苹果放入盘子;</span><br><span class="line">V(mutex);</span><br><span class="line">V(apple);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mom()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">准备一个橘子;</span><br><span class="line">P(plate);</span><br><span class="line">P(mutex);</span><br><span class="line">将橘子放入盘子;</span><br><span class="line">V(mutex);</span><br><span class="line">V(orange);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">son()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(orange);</span><br><span class="line">P(mutex);</span><br><span class="line">取出盘子中的橘子;</span><br><span class="line">V(mutex);</span><br><span class="line">V(plate);</span><br><span class="line">吃橘子;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(apple);</span><br><span class="line">P(mutex);</span><br><span class="line">取出盘子中的苹果;</span><br><span class="line">V(mutex);</span><br><span class="line">V(plate);</span><br><span class="line">吃苹果;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析同步问题时，不能单从单个进程行为角度判断，而是应把&quot;一前一后&quot;发生的事情看成是事件的前后关系，如下图中间部分可以合成一个事件；</p><p><img src="https://img.lishangcc.top//img/image-20220810000815750.png" alt="image-20220810000815750"></p></blockquote><h2 id="吸烟者问题">吸烟者问题</h2><p><code>问题描述</code>：假设一个系统有<code>三个抽烟者进程</code>和<code>一个供应者进程</code>，每个抽烟者不停卷烟并抽掉它，卷起一支烟抽烟者需要三种材料：烟草、纸、胶水；三个抽烟者中，第一个拥有烟草，第二个有纸，第三个有胶水；供应者无限提供三种材料，每次将两种材料放桌子上，拥有足够材料的抽烟者卷一根烟并抽掉，此时向供应者发出完成信号，供应者会放另外两种材料在桌上，过程重复，使三个抽烟者轮流抽烟；</p><p><img src="https://img.lishangcc.top//img/image-20220810001329462.png" alt="image-20220810001329462"></p><ul><li>互斥关系：供应者与抽烟者访问桌子是互斥的(因为缓存容量为1，所以可以不单独设置mutex)；</li><li>同步关系：桌子组合1→第一个抽烟者；桌子组合2→第二个抽烟者；桌子组合3→第三个抽烟者；发出完成信号→供应者；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;</span><br><span class="line">semaphore offer2 = <span class="number">0</span>;</span><br><span class="line">semaphore offer3 = <span class="number">0</span>;</span><br><span class="line">semaphore finish = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;<span class="comment">//用于实现轮流抽烟</span></span><br><span class="line"></span><br><span class="line">provide()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            放组合<span class="number">1</span>;</span><br><span class="line">V(offer1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">            放组合<span class="number">2</span>;</span><br><span class="line">V(offer2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">            放组合<span class="number">3</span>;</span><br><span class="line">V(offer3);</span><br><span class="line">&#125;</span><br><span class="line">P(finish);</span><br><span class="line">i = (i+<span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(offer1);</span><br><span class="line">拿走组合<span class="number">1</span>;</span><br><span class="line">卷烟;</span><br><span class="line">抽烟;</span><br><span class="line">V(finish);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker2()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(offer2);</span><br><span class="line">拿走组合<span class="number">2</span>;</span><br><span class="line">卷烟;</span><br><span class="line">抽烟;</span><br><span class="line">V(finish);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker3()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(offer3);</span><br><span class="line">拿走组合<span class="number">3</span>;</span><br><span class="line">卷烟;</span><br><span class="line">抽烟;</span><br><span class="line">V(finish);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读者写者问题">读者写者问题</h2><p><code>问题描述</code>：有读者和写者两组并发进程，共享一个文件，要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件写信息；③任一写者完成操作前不允许其他读者或写者工作；④写者执行写操作前，应让已有读者或写者全部退出；</p><blockquote><p>与消费者进程不同，读者进程在读数据后并不会将数据清空，不会改变数据；因此多个读者可以同时访问数据；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220810002224226.png" alt="image-20220810002224226"></p><p>互斥关系：写进程—写进程；写进程—读进程；</p><p><code>count变量</code>：用于记录当前需要访问文件的<code>读进程</code>，因为只有第一个读进程进入需要加锁，最后一个读进程退出才会释放锁；</p><p><code>mutex信号量</code>：用于实现对count变量的互斥访问，因为如果两个读进程并发执行，则两个读进程可能均满足count=0，造成进程阻塞；</p><p><code>w信号量</code>：用于实现&quot;写优先&quot;，类似如果读进程一直在读或者发生阻塞，则也会造成写进程阻塞，可能导致饿死（但并不是真正的写优先，只是类似先来先服务原则，如果写进程来了，后面的读进程就别来了，先给写进程，原有的读进程还可以接着读，读完自己悄悄溜走）；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;<span class="comment">//互斥信号，实现对文件互斥访问；</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore w = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(w);</span><br><span class="line">P(rw);</span><br><span class="line">写文件;</span><br><span class="line">V(rw);</span><br><span class="line">V(w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(w);</span><br><span class="line">P(mutex);</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">P(rw);</span><br><span class="line">count++;</span><br><span class="line">V(w);</span><br><span class="line">读文件;</span><br><span class="line">P(mutex);</span><br><span class="line">count --;</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">V(rw);</span><br><span class="line">V(mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哲学家进餐问题">哲学家进餐问题</h2><p><code>问题描述</code>：一张圆桌坐着5名哲学家，每两个哲学家之间摆一根筷子，桌子中间有一碗米饭，哲学家要么思考要么进餐；思考时，并不影响他人；哲学家饥饿时，才试图拿起左、右两根筷子（一根一根拿起），如果筷子已在他人手上，则需要等待，哲学家只有同时拿起两根筷子才可以开始进餐，进餐完毕继续思考；</p><p><img src="https://img.lishangcc.top//img/image-20220809183928280.png" alt="image-20220809183928280"></p><p>该问题只有互斥关系；5位哲学家与左右临界对中间筷子的访问是互斥的；可以对哲学家和筷子分别编号；</p><p><code>方案一</code>：允许最多4个哲学家同时拿筷子，这样至少可以保证有一个哲学家是可以拿到左右两根筷子的；</p><p><code>方案二</code>：奇数号哲学家先拿左边再拿右边，偶数则相反，这样可以保证相邻两个哲学家想吃饭，一个能从吃，一个阻塞；</p><p><code>方案三</code>：自己看吧，难说，总之设置一个互斥信号量mutex，当拥有拿筷子的权利（获得锁），尽量此时拿到左右两支筷子，如有一支别人用，就等一下，别人用完马上拿过来，这时把锁释放了谁要吃谁拿，自己先吃着了；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案三</span></span><br><span class="line">semaphore chopsticks[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//互斥地取筷子</span></span><br><span class="line"></span><br><span class="line">Pi()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(mutex);</span><br><span class="line">P(chopstick[i]);</span><br><span class="line">P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">V(mutex);</span><br><span class="line">吃饭;</span><br><span class="line">V(chopstick[i]);</span><br><span class="line">V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">思考;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果遇到一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题思想；</p></blockquote><h2 id="管程">管程</h2><p>管程是一种特殊的软件模块，由以下部分组成：</p><ol><li>局部于管程的共享数据说明；（如生产者与消费者模型中的缓冲区，可以通过数据结构表示该缓冲区）</li><li>对该数据结构进行操作的一组过程；（过程可以理解为函数，即管程中需要有一组对1中数据结构进行操作的函数）</li><li>对局部于管程的共享数据设置初始值的语句；</li><li>管程需要有一个名字；</li></ol><p><strong>管程的基本特征</strong></p><ol><li>局部于管程的数据只能被局部于管程的过程所访问；</li><li>一个进程只能通过调用管程内的过程才能进入管程访问共享数据；</li><li>每次仅允许一个进程在管程内执行某个内部过程；</li></ol><p><img src="https://img.lishangcc.top//img/image-20220814223304127.png" alt="image-20220814223304127"></p><h2 id="死锁">死锁</h2><h3 id="死锁的概念">死锁的概念</h3><p><code>死锁</code>：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进现象；</p><p><code>饥饿</code>：由于长期得不到想要的资源，某进程无法向前推进的现象；</p><p><code>死循环</code>：某进程执行过程中一直跳不出某个循环的现象；</p><p><img src="https://img.lishangcc.top//img/image-20220814224450116.png" alt="image-20220814224450116"></p><p><strong>死锁产生条件</strong></p><p>必须同时满足以下四个条件：</p><ol><li><code>互斥条件</code>：只有对必须互斥使用的资源的争抢才会导致死锁；（如哲学家的筷子、打印机设备）（像内存、扬声器这种可以同时运行多个进程使用的资源不会导致死锁）；</li><li><code>不剥夺条件</code>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放；</li><li><code>请求和保持条件</code>：进程已经保持了至少一个资源，但又提出新的资源请求，而该资源有被其他进程占有，此时请求进程被阻塞，但又对自己已有资源保持不放；</li><li><code>循环等待条件</code>：存在一种进程资源的循环等待链，链中的每个进程已获得的资源同时被下一个进程所请求；</li></ol><blockquote><p>注意：发生死锁时一定有循环等待，但发生循环等待未必死锁；</p><p>如果同类资源数大于1，则即使有循环等待也未必死锁，但如果每类资源都资源1，那么循环等待必然死锁；</p></blockquote><p><strong>发生死锁的情况</strong></p><p>①对系统资源的竞争；②进程推进顺序非法；③信号量使用不当等；</p><h3 id="死锁的处理策略">死锁的处理策略</h3><ol><li>预防死锁：破坏死锁产生条件的一个或多个；</li><li>避免死锁：用某种方法防止系统进入不安全状态，如银行家算法；</li><li>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁；</li></ol><h4 id="预防死锁">预防死锁</h4><p><strong>1.破坏互斥条件</strong></p><p><img src="https://img.lishangcc.top//img/image-20220814234323245.png" alt="image-20220814234323245"></p><p>缺点：并不是所有的资源都可以改造成共享使用的资源，并且为了系统安全，往往需要保护这种互斥性，因此<code>很多时候无法破坏互斥条件</code>；</p><p><strong>2.破坏不剥夺条件</strong></p><p><img src="https://img.lishangcc.top//img/image-20220814234631296.png" alt="image-20220814234631296"></p><p>缺点：①实现复杂；②释放已获得资源可能造成前一阶段工作失效；③反复申请和释放资源会增加系统开销，降低系统吞吐量；④方案一意味着只要暂时等不到某个资源，之前获得的资源都需要放弃，以后再重新申请，如果一直发生则可能导致进程饥饿；</p><p><strong>3.破坏请求和保持条件</strong></p><p>可以采用静态分配方法，即进程在运行前，一次申请完所需的全部资源，在它的资源未满足前，不让它投入运行，一旦投入运行，这些资源就一直归它所要，该进程就不会请求别的资源了；</p><p>缺点：有些资源可能只需要用很短的时间，如果进程的整个运行期间都一直保持所有资源，就会造成严重的资源浪费，<code>资源利用率极低</code>，另外，该策略也可能<code>导致某些进程饥饿</code>；</p><p><strong>4.破坏循环等待条件</strong></p><p><img src="https://img.lishangcc.top//img/image-20220814235657281.png" alt="image-20220814235657281"></p><blockquote><p>①第二点缺点的解释：假设在实际使用过程中进程P3是先使用7号后使用5号，但根据编号递增顺序的要求，P3必须先申请使用5号，再申请使用7号，则在P3实际运行中5号某些时间是空闲的</p><p>②用户编程麻烦的原因：不同主机对不同设备的编号可能不同，但编号的不同会影响申请资源的顺序，即程序需要根据编号的不同而变化</p></blockquote><h4 id="避免死锁">避免死锁</h4><p><code>安全序列</code>：指系统如果按照这种序列分配资源，则每个进程都能顺利完成；只要能找出一个安全序列，系统就是安全状态，安全序列可能有多个；</p><blockquote><p>如果分配资源后，系统找不出任何一个安全序列，则系统进入不安全状态，意味着之后可能所有进程都无法顺利执行下去；</p><p>处于安全状态一定不会发生死锁，不安全状态未必发生死锁，但发生死锁一定在不安全状态；</p></blockquote><p><code>银行家算法</code>：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态；如果会进入不安全状态，则暂时不答应这次请求，让该进程阻塞等待；</p><p><img src="https://img.lishangcc.top//img/image-20220815132305555.png" alt="image-20220815132305555"></p><p>①已分配资源总和为{7,2,5}，用总数减去已分配的，剩余{3,3,2}，最多还需要资源满足的有P1和P3，因此加入安全序列；（先满足P1，而后P1归还资源（包括已分配的）再满足P3，P3又归还资源）此时剩余(2,0,0)+(2,1,1)+(3,3,2)=(7,4,3)</p><p>②此时还剩进程P0,P2,P4，按P0→P2→P4排序即可；</p><p>③最终安全序列{P1，P3，P0，P2，P4}；</p><p>下面为具体实现，慢慢看：</p><p><img src="https://img.lishangcc.top//img/image-20220815133455482.png" alt="image-20220815133455482"></p><p><img src="https://img.lishangcc.top//img/image-20220815133509205.png" alt="image-20220815133509205"></p><h4 id="死锁的检测和解除">死锁的检测和解除</h4><p><strong>1.死锁检测</strong></p><p>①用某种数据结构来保存资源的请求和分配信息；</p><blockquote><p><img src="https://img.lishangcc.top//img/image-20220815134547241.png" alt="image-20220815134547241"></p></blockquote><p>②提供一种算法，利用上述信息检测系统是否进入死锁状态；</p><blockquote><p>依次消除与不阻塞进程相连的边，直到无边可消；（不阻塞进程：其申请资源数还足够的进程）</p><p>死锁定理：若资源分配图是不可完全简化的，说明发生了死锁；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220815135035750.png" alt="image-20220815135035750"></p><blockquote><p>解释一下：</p><ol><li>P2向R1申请1个资源，而此时R1没有多余资源；</li><li>P1向R2申请一个资源，此时R2仍剩余1个资源，则分配出去，P1执行完后归还全部占有资源，此时R1拥有2个资源；</li><li>R1剩余的2个资源可以满足P2的1个资源申请请求，P2执行完也归还占有资源；</li><li>至此，全部边消除，所以P1和P2不会发生死锁；</li></ol></blockquote><p><img src="https://img.lishangcc.top//img/image-20220815135719090.png" alt="image-20220815135719090"></p><blockquote><p>该图中，仅有P3的线可以消除，归还R2一个资源后，其他P1和P2进程依然阻塞，所以必然发生死锁；</p></blockquote><p><strong>2.死锁的解除</strong></p><p><code>①资源剥夺法</code>：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程；但是应防止被挂起的进程长时间得不到资源而饿死；</p><p><code>②撤销进程法</code>：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源；实现简单，但付出代价也大；</p><p><code>③进程回退法</code>：让一个或多个死锁进程回退到足以避免死锁的地步，这要求系统记录进程历史信息，设置还原点；</p><blockquote><p>如何决定对哪个进程&quot;动手&quot;：</p><p>进程优先级；已执行多长时间；还要多久完成；进程已使用多少资源；进程是交互式还是批处理式的；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 进程与线程(上)</title>
      <link href="/myblog/2022/07/31/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-07-31-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B1/"/>
      <url>/myblog/2022/07/31/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-07-31-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<h2 id="进程简述">进程简述</h2><blockquote><p>区别一下程序与进程：</p><p>程序：静态的，就是存放在磁盘里的可执行文件，如：QQ.exe；</p><p>进程：动态的，是程序一次执行过程，如：同时打开多个QQ程序（同一个程序多次执行会对应多个进程）；</p></blockquote><h3 id="进程实体的组成">进程实体的组成</h3><p>进程由<code>PCB</code>、<code>程序段</code>、<code>数据段</code>三部分组成；</p><p>PCB：介绍见下面；</p><p>程序段：程序的代码（指令序列）；</p><p>数据段：运行过程中产生的各种数据（如：程序中定义的变量）；</p><blockquote><p>PCB是给操作系统用的，程序段、数据段是给进程自己用的；</p><p>程序可被多个进程共享，即多个进程可以运行同一个程序；</p></blockquote><h3 id="进程控制块PCB">进程控制块PCB</h3><p>PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，回收其PCB；</p><p><strong>PCB保存的信息</strong></p><p><img src="https://img.lishangcc.top//img/image-20220801214628303.png" alt="image-20220801214628303"></p><h3 id="进程的特征">进程的特征</h3><ul><li><code>动态性（最基本特征）</code>：进程是程序的一次执行过程，动态地产生、变化和消亡；</li><li><code>并发性</code>：内存中有多个进程实体，各进程可并发执行；</li><li><code>独立性</code>：进程能独立运行、独立获得资源、独立接受调度的基本单位；</li><li><code>异步性</code>：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供进程同步机制解决异步问题；</li><li><code>结构性</code>：每个进程都会配置PCB，结构上看，进程由程序段、数据段、PCB组成；</li></ul><h2 id="进程的状态与转换">进程的状态与转换</h2><h3 id="进程的状态">进程的状态</h3><p>进程在其生命周期内，由于系统中各进程之间的相互制约及系统的运行环境的变化，使得进程的状态也在不断变化，一般认为进程有以下5种状态，其中中间三种为基本状态；</p><ul><li>创建态：程序正在被创建，尚未转到就绪态，创建进程需要多个步骤：</li><li>就绪态：进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行，系统中同一时间处于就绪状态的进程可能有多个，通常将它们排成一个队列；</li><li>运行态：进程正在处理机上运行，在单处理机中，每个时刻只有一个进程处于运行态；</li><li>阻塞态：又称等待态，进程执行过程中，可能因等待某一事件而暂停运行；</li><li>结束态：也称终止态，进程正在从系统中消失，可能是进程正常结束或其他原因退出运行；</li></ul><h3 id="状态的转换">状态的转换</h3><p>一般认为存在6种状态转换形式；</p><p><img src="https://img.lishangcc.top//img/image-20220801235933386.png" alt="image-20220801235933386"></p><p>**就绪态→运行态：**处于就绪态的进程被调度后，获得处理机资源，进程由就绪态转换为运行态；</p><p>**运行态→就绪态：**处于运行态的进程在时间片用完后，不得不让出处理机，从而进程由运行态转换为就绪态；</p><p>**运行态→阻塞态：**进程请求某一资源（如外设）的使用或等待某一事件的发生（如等待I/O操作的完成）时，运行态转换为阻塞态；</p><p>**阻塞态→就绪态：**进程等待的事件到来时，中断处理程序必须把相应进程的状态由阻塞态转换为就绪态；</p><h2 id="进程控制">进程控制</h2><p>进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能；</p><p>一般把进程控制的程序段称为原语，执行具有原子性，即执行期间不允许被中断；</p><p>可以用<code>关中断指令</code>和<code>开中断指令</code>这两个特权指令实现原子性；</p><h3 id="进程的创建">进程的创建</h3><p><img src="https://img.lishangcc.top//img/image-20220802100109849.png" alt="image-20220802100109849"></p><h3 id="进程的终止">进程的终止</h3><p><img src="https://img.lishangcc.top//img/image-20220802100148461.png" alt="image-20220802100148461"></p><h3 id="进程的阻塞和唤醒">进程的阻塞和唤醒</h3><p><img src="https://img.lishangcc.top//img/image-20220802100226334.png" alt="image-20220802100226334"></p><h3 id="进程的切换">进程的切换</h3><p><img src="https://img.lishangcc.top//img/image-20220802100315037.png" alt="image-20220802100315037"></p><h2 id="进程通信">进程通信</h2><p>进程间通信（IPC）：两个进程之间产生数据交互；</p><p>进程是分配系统资源的单位，因此各进程拥有的内存地址空间相互独立；</p><h3 id="共享存储">共享存储</h3><p>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换；一般有两种方式；</p><blockquote><p>为避免出错，各进程对共享空间的访问应该是互斥的，即如果一个进程正在访问共享空间，则其他进程不能访问；</p><p>各个进程可使用操作系统内核提供的同步互斥工具（如P、V操作）；</p></blockquote><p><strong>1.基于存储区共享</strong></p><p><img src="https://img.lishangcc.top//img/image-20220802104554051.png" alt="image-20220802104554051"></p><p>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统，这种方式速度很快，是一种高级通信方式；</p><p><strong>2.基于数据结构共享</strong></p><p><img src="https://img.lishangcc.top//img/image-20220802120252857.png" alt="image-20220802120252857"></p><p>比如共享空间里只能放一个长度为10的数组，这种方式速度慢，限制多，是一种低级通信方式；</p><h3 id="消息传递">消息传递</h3><p>进程间的数据交换以<code>格式化的消息</code>（Message）为单位，进程通过操作系统提供的<code>发送消息/接收消息</code>两个原语进行数据交换；一般也有两种方式；</p><p><strong>1.直接通信方式</strong></p><p>点名道姓的形式说明我是谁，我要发给谁；</p><p><img src="https://img.lishangcc.top//img/image-20220802121001891.png" alt="image-20220802121001891"></p><p><strong>2.间接通信方式</strong></p><p>以&quot;信箱&quot;作为中间实体进行消息传递；</p><p><img src="https://img.lishangcc.top//img/image-20220802120800991.png" alt="image-20220802120800991"></p><h3 id="管道通信">管道通信</h3><p>&quot;管道&quot;是一个特殊的共享文件，又名pipe文件，用于连接一个读进程一个写进程，以实现它们之间的通信；</p><p><img src="https://img.lishangcc.top//img/image-20220802190017105.png" alt="image-20220802190017105"></p><ul><li>管道只能采用半双工通信，即某一时间段内只能实现单向的传输，如果要实现双向同时通信，则需要设置两个管道；</li><li>各进程要互斥地访问管道（由操作系统实现）；</li><li>当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程；</li><li>当管道读空时，读进程将阻塞，直到写进程往管道写入新数据，即可唤醒读进程；</li><li>管道中的数据一旦读出，就彻底消失，因此当多个进程读同一个管道时，可能会错乱，对此一般有两种解决方案：①一个管道运行多个写进程，一个读进程（这里只说一种）；</li><li>只要管道没空，读进程就可以从管道读数据；只要管道没满，写进程就可以往管道写数据；</li></ul><h2 id="线程简述">线程简述</h2><h3 id="线程的概念">线程的概念</h3><p>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐率；</p><p>引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能；</p><p><img src="https://img.lishangcc.top//img/image-20220802191538760.png" alt="image-20220802191538760"></p><p>可以把线程理解为轻量级进程；</p><p>线程是一个基本的CPU的执行单元，也是程序执行流的最小单位；</p><p>引入线程后，不仅是进程之间可以并发，进程内的各线程自己也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务；</p><p>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间都是分配给进程的），线程则作为处理机的分配单元；</p><h3 id="线程带来的变化">线程带来的变化</h3><p><img src="https://img.lishangcc.top//img/image-20220802191755499.png" alt="image-20220802191755499"></p><blockquote><p>理解一下运行环境：</p><p>假设去图书馆看书，桌子=处理机，人=进程，看不同的书=线程；<br>切换进程运行环境：有一个不认识的人要用桌子，此时你需要把书搬走，他把自己的书放到桌子上；<br>同一进程内线程切换：你的舍友要用你的桌子，而你们所学相同，则你不用把书搬走；</p></blockquote><h3 id="线程的属性">线程的属性</h3><ul><li>线程是处理机调度的单位；</li><li>多CPU计算机中，各个线程可占用不同的CPU；</li><li>每个线程都有一个线程ID、线程控制块（TCB）；</li><li>线程也有就绪、阻塞、运行三种基本状态；</li><li>线程几乎不拥有系统资源；</li><li>同一线程的不同线程间共享进程的资源；</li><li>由于共享内存地址空间，同一进程中的线程通信甚至不需要系统干预；</li><li>同一进程中的线程切换，不会引起进程切换；</li><li>不同进程中的线程切换，会引起进程切换；</li><li>切换同进程内的线程，系统开销很小；</li><li>切换进程，系统开销较大；</li></ul><h3 id="线程的实现方式">线程的实现方式</h3><p>分两类：用户级线程（ULT）、内核级线程（KLT）；</p><p><strong>1.用户级线程(ULT)</strong></p><p>在用户级线程中，有关线程管理（创建、撤销、切换等）的所有工作都由应用程序在用户空间中完成，内核意识不存在；</p><p>对于设置了用户级线程的系统，其调度仍以进程为单位进行；</p><p><img src="https://img.lishangcc.top//img/image-20220803150841465.png" alt="image-20220803150841465"></p><p>从代码角度看，线程就是一段代码逻辑，此段代码可看作三个&quot;线程&quot;，这个循环体就是一个简易的&quot;线程库&quot;；</p><p><img src="https://img.lishangcc.top//img/image-20220803151952517.png" alt="image-20220803151952517"></p><blockquote><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高；</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度并不高，多个线程不可在多核处理机上并行运行；</p></blockquote><p><strong>2.内核级线程(KLT)</strong></p><p>大多数现代操作系统都实现了内核级线程，如：Windows、Linux；</p><p>内核级线程的管理工作由操作系统内核完成，包括线程调度、切换；操作系统会为每个内核级线程建立相应TCP（线程控制块），通过TCP对线程进行管理；</p><p><img src="https://img.lishangcc.top//img/image-20220803153019916.png" alt="image-20220803153019916"></p><blockquote><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可在多核处理机上并行执行；</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理成本高，开销大；</p></blockquote><h3 id="多线程模型">多线程模型</h3><p>有些系统同时支持用户线程和内核线程，由于用户线程和内核线程连接方式的不同，从而形成三种不同的多线程模型；</p><blockquote><p>可以这么理解：</p><p>用户级线程是&quot;代码逻辑&quot;的载体；<br>内核级线程是&quot;运行机会&quot;的载体；<br>一段&quot;代码逻辑&quot;只有获得&quot;运行机会&quot;才能被CPU执行；</p></blockquote><p><strong>一对一模型</strong></p><p>一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程；</p><p><img src="https://img.lishangcc.top//img/image-20220803172111702.png" alt="image-20220803172111702"></p><blockquote><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可在多核处理机上并行执行；</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大；</p></blockquote><p><strong>多对一模型</strong></p><p>多个用户级线程映射到一个内核级线程，且一个进程只被分配一个内核级线程；</p><p><img src="https://img.lishangcc.top//img/image-20220803172349524.png" alt="image-20220803172349524"></p><blockquote><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高；</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行；</p><p><strong>注意：操作系统只看得见内核级线程，因此只有内核级线程才是处理机分配的单位；</strong></p></blockquote><p><strong>多对多模型</strong></p><p>n个用户级线程映射到m个内核级线程(n&gt;=m)，每个用户进程对应m个内核级线程；</p><p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销大的缺点；</p><p><img src="https://img.lishangcc.top//img/image-20220803172729910.png" alt="image-20220803172729910"></p><h3 id="线程的状态与转换">线程的状态与转换</h3><p>与进程一样，各线程之间也存在共享资源和相互合作的制约关系，致使线程在运行时也具有间断性，相应的，线程在运行时，也具有下面三种基本状态：</p><ul><li><code>执行状态</code>：线程已获得处理机而正在运行；</li><li><code>就绪状态</code>：线程已具备各种执行条件，只需再获得CPU便可立即执行；</li><li><code>阻塞状态</code>：线程在执行中因某事件受阻而处于暂停状态；</li></ul><p><img src="https://img.lishangcc.top//img/image-20220803183231274.png" alt="image-20220803183231274"></p><blockquote><p>线程三种基本状态的转换与进程的状态转换一样，参考上面的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章总线</title>
      <link href="/myblog/2022/07/27/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-27-%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%80%BB%E7%BA%BF/"/>
      <url>/myblog/2022/07/27/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-27-%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="总线概述">总线概述</h2><p>总线是一组能为多个部件<code>分时</code> <code>共享</code>的公共信息传送线路；</p><p><img src="https://img.lishangcc.top//img/image-20220729134130819.png" alt="image-20220729134130819"></p><blockquote><p>为什么要用总线？</p><p>早期计算机外部设备少时大多采用分散连接方式，不易实现随时增减外部设备；<br>为了更好解决I/O设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接</p></blockquote><p>分时：同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时的向总线发送信息；</p><p>共享：总线上可以挂接多个部件，各个部件之间互相交换信息都快通过这组线路分时共享，多个部件可同时从总线上接收相同的信息；</p><h3 id="总线的特性">总线的特性</h3><ul><li>机械特性：尺寸、形状、管脚数、排列顺序；</li><li>电气特性：传输方向和有效的电平范围；</li><li>功能特性：每根传输线的功能（地址、数据、控制）；</li><li>时间特性：信号的时序关系；</li></ul><h3 id="总线的数据传输格式">总线的数据传输格式</h3><h4 id="串行总线">串行总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729134955144.png" alt="image-20220729134955144"></p><p>优点：只需要一个条传输线，成本低廉，广泛应用于长距离传输；应用于计算机内部时，可以节省布线空间；</p><p>缺点：在数据发送和接收时，要进行拆卸和装配，要考虑串行-并行转换的问题；</p><h4 id="并行总线">并行总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729135144434.png" alt="image-20220729135144434"></p><p>优点：总线的逻辑时序比较简单，电路实现起来比较容易；</p><p>缺点：信号线数量多，占用更多的布线空间；远距离传输成本高；</p><h3 id="总线按功能分类">总线按功能分类</h3><h4 id="片内总线">片内总线</h4><p>片内总线是芯片内部的总线，它是CPU芯片内部<code>寄存器</code>和<code>寄存器</code>、<code>寄存器</code>与<code>ALU</code>之间的公共连接线；</p><h4 id="系统总线">系统总线</h4><p>是计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线；</p><p>按系统总线传输信息内容的不同，又可分为3类：<code>数据总线</code>、<code>地址总线</code>、<code>控制总线</code>；</p><p><strong>数据总线（DB）</strong>：传输各功能部件之间的数据信息，包括指令、操作数；位数（根数）与<code>机器字长</code>、<code>存储字长</code>有关，<code>双向</code>；</p><p><strong>地址总线（AB）</strong>：传输地址信息，包括主存单元或I/O端口的地址，位数（根数）与<code>主存地址空间大小</code>及<code>设备数量</code>有关，<code>单向</code>；</p><p><strong>控制总线（CB）</strong>：传输控制信息，一根控制线传输一个信号，有出：CPU送出的控制命令；有入：主存（或外设）返回CPU的反馈信号；</p><h4 id="通信总线">通信总线</h4><p>通信总线用于计算机系统之间或计算机系统与其他系统（如：远程通信设备、测试设备）之间信息传递的总线，也称外部总线；</p><h3 id="系统总线的结构">系统总线的结构</h3><h4 id="单总线">单总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729140252228.png" alt="image-20220729140252228"></p><p>单总线结构将CPU、主存、I/O设备（通过I/O接口）都挂载一组总线上，运行I/O设备之间、I/O设备与主存之间交换信息；</p><blockquote><p>优点：结构简单，成本低，易于接入新设备；</p><p>缺点：带宽低，负载重，多个部件只能争用唯一总线，且不支持并发传送操作；</p></blockquote><h4 id="双总线">双总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729140722038.png" alt="image-20220729140722038"></p><p>双总线结构有两条总线，一条是<code>主存总线</code>，用于CPU、主存和通道之间进行数据传送；另一条是<code>I/O总线</code>，用于多个设备与通道之间进行数据传送；</p><blockquote><p>一些概念</p><p>通道：具有特殊功能的处理器，能对I/O设备进行统一管理，通道程序存放在主存中；</p></blockquote><blockquote><p>优点：将较低速的I/O设备从单总线上分离出来，实现存储器总线和I/O总线的分离；</p><p>缺点：需要增加通道等硬件设备；</p></blockquote><h4 id="三总线">三总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729141117455.png" alt="image-20220729141117455"></p><p>三条总线结构是计算机系统各部件之间采用3条各自独立的总线来构成信息通路，3条总线分别为：<code>主存总线</code>、<code>I/O总线</code>、<code>直接内存访问DMA总线</code>；</p><blockquote><p>优点：提高了I/O设备的性能，使其更快响应命令，提高系统的吞吐量；</p><p>缺点：系统工作效率较低；</p></blockquote><h2 id="总线性能指标">总线性能指标</h2><p><strong>总线传输周期（总线周期）</strong></p><p>一次总线操作所需的时间（包括<code>申请阶段</code>、<code>寻址阶段</code>、<code>传输阶段</code>和<code>结束阶段</code>），通常由若干个总线时钟周期构成；</p><p><strong>总线时钟周期</strong></p><p>即机器的时钟周期；计算机系统有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制；</p><p><strong>总线的工作频率</strong></p><p>总线上各种操作的频率，为总线周期的倒数；理解：1秒内传送几次数据；</p><p><strong>总线的时钟频率</strong></p><p>即机器的时钟频率，为时钟周期的倒数；</p><p><strong>总线宽度</strong></p><p>又称总线位宽，它是总线上同时能够传输的数据位数，通常指数据总线的根数，如32根又称32位总线；</p><p><strong>总线带宽</strong></p><p>可理解为总线的最大数据传输率，即单位时间内总线上最多可传输数据的位数；通常以每秒传送信息的字节数来衡量，即 字节/秒（B/s）表示；</p><blockquote><p>总线带宽 = 总线工作频率 × （总线宽度/8）（B/s）</p></blockquote><p><strong>总线复用</strong></p><p>指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息；</p><p><strong>信号线数</strong></p><p>地址总线、数据总线、控制总线，3种总线数的总和称为信号线数；</p><h2 id="总线操作和定时">总线操作和定时</h2><p><strong>总线周期的四个阶段</strong></p><ol><li><code>申请分配阶段</code>：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者，也可将此阶段细分为传输请求和总线仲裁两个阶段；</li><li><code>寻址阶段</code>：获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，启动参与本次传输的从模块；</li><li><code>传输阶段</code>：主模块和从模块进行数据交换，可单向或双向进行数据传送；</li><li><code>结束阶段</code>：主模块的有关信息均从系统总线上撤除，让出总线使用权；</li></ol><h3 id="总线定时">总线定时</h3><p>指总线在双方交换数据的过程中，需要时间上配合关系的控制，这种控制称为总线定时，它的实质是一种协议；</p><h4 id="同步通信">同步通信</h4><p>也叫同步定时方式，由采用一个<code>统一时钟</code>来协调发送和接收双方的传送定时关系；</p><blockquote><p>假设：CPU作为主设备，某个输入设备作为从设备；</p><p><img src="https://img.lishangcc.top//img/image-20220729164450433.png" alt="image-20220729164450433"></p><ol><li>CPU在T1时刻的上升沿给出地址信息；</li><li>在T2上升沿给出读命令（低电平有效），与地址信息相符合的输入设备按命令进行一系列的内部操作，且必须在T3的上升沿之前将CPU所需的数据送到数据总线上；</li><li>CPU在T3时钟周期内，将数据线上的信息传送到其内部寄存器中；</li><li>CPU在T4上升沿撤销读命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动；</li></ol><p>注：如果从设备跟不上节奏，在T3给不出数据，就哦豁了；</p></blockquote><p>若干个时钟产生相等的时间间隔，每个间隔构成一个总线周期；</p><p>在一个总线周期中，发送方和接收方可进行一次数据传送；</p><p>因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始；</p><blockquote><p>优点：传送速度快快，具有较高的传输速率，总线控制逻辑简单；</p><p>缺点：自从设备属于强制性同步，不能及时进行数据通信的有效性检验，可靠性较差；</p><p>适用：同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统；</p></blockquote><h4 id="异步通信">异步通信</h4><p>也叫异步定时方式，其没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方制约的&quot;握手&quot;信号来实现定时控制；</p><p>主设备提出交换信息的请求信号，经接口传送到从设备，从设备接到主设备的请求后，通过接口想主设备发出回答信号；</p><p>根据&quot;请求&quot;和&quot;回答&quot;信号的撤销是否互锁，分为以下3种类型：</p><p><strong>1.不互锁方式</strong></p><blockquote><p>特点：速度最快，可靠性最差；</p></blockquote><p>主设备发出&quot;请求&quot;信号后，不必等到接收设备的&quot;回答&quot;信号，而是经过一段时间后，便撤销&quot;请求&quot;信号；</p><p>而从设备在接到&quot;请求&quot;信号后，发出&quot;回答&quot;信号，并经过一段时间，自动撤销&quot;回答&quot;信号，双方不存在互锁关系；</p><p><strong>2.半互锁方式</strong></p><p>主设备发出&quot;请求&quot;信号后，必须待接到从设备的&quot;回答&quot;信号后，才撤销&quot;请求&quot;信号，有互锁关系；</p><p>而从设备在接到&quot;请求&quot;信号后，发出&quot;回答&quot;信号，但不必等待主设备&quot;请求&quot;信号撤销，而是隔一段时间后自动撤销&quot;回答&quot;信号，这里不存在互锁关系；</p><p><strong>3.全互锁方式</strong></p><blockquote><p>特点：最可靠，速度最慢；</p></blockquote><p>主设备发出&quot;请求&quot;信号后，必须待从设备&quot;回答&quot;后，才撤销&quot;请求&quot;信号；</p><p>从设备发出&quot;回答&quot;信号后，必须待获知主设备&quot;请求&quot;信号已撤销后，在撤销其&quot;回答&quot;信号；</p><blockquote><p>异步定时方式</p><p>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠的进行信息交换，自动适应时间的配合；</p><p>缺点：比同步控制方式复杂，速度也比同步定时方式慢；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章中央处理器</title>
      <link href="/myblog/2022/07/22/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-22-%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/myblog/2022/07/22/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-22-%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="CPU概述">CPU概述</h2><p>CPU由<code>运算器</code>和<code>控制器</code>组成；</p><p>运算器：对数据进行加工；</p><p>控制器：协调并控制计算机各部件执行程序的指令序列，包括：取指令、分析指令、执行指令；</p><h3 id="运算器基本结构">运算器基本结构</h3><ol><li><strong>算术逻辑单元（ALU）</strong>：进行算术/逻辑运算；</li><li><strong>暂存寄存器</strong>：暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏原有内容；暂存寄存器对程序员是透明的（即不可见）；</li><li><strong>累加寄存器（ACC）</strong>：一个通用寄存器，用于暂时存放ALU的运算结果信息，可以作为加法运算的一个输入端；</li><li><strong>通用寄存器</strong>：用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息；</li><li><strong>程序状态寄存器（PSW）</strong>：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如：溢出标志OF、符号标志SF、零标志ZF、进位标志CF；</li><li><strong>移位器</strong>：对操作数或运算结果进行移位操作运算；</li><li><strong>计数器（CT）</strong>：控制乘除运算的操作步数（乘除结果也是由多次加减得来）；</li></ol><h3 id="控制器基本结构">控制器基本结构</h3><ol><li><strong>程序计数器（PC）</strong>：用于指出下一条指令在主存中的存放地址，PC有自增的功能；</li><li><strong>指令寄存器（IR）</strong>：保存当前正在执行的那条指令；</li><li><strong>指令译码器</strong>：仅对操作码字段进行译码，向控制器提供特定的操作信号；</li><li><strong>存储器地址寄存器（MAR）</strong>：存放要访问的主存单位的地址；</li><li><strong>存储器数据寄存器（MDR）</strong>：存放向主存写入的信息或从主存读出的信息；</li><li><strong>时序系统</strong>：用于产生各种时序信号，由统一时钟（CLOCK）分频得到；</li><li><strong>微操作信号发生器</strong>：根据IR的内容（指令）、PSW的状态信息及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种；</li></ol><h3 id="CPU基本结构">CPU基本结构</h3><p><img src="https://img.lishangcc.top//img/image-20220723000539085.png" alt="image-20220723000539085"></p><p>红框：用户可见；</p><p>灰框：用户不可见；</p><h3 id="CPU功能">CPU功能</h3><ol><li>指令控制</li><li>操作控制</li><li>时间控制</li><li>数据加工</li><li>中断处理</li></ol><h2 id="指令的执行">指令的执行</h2><h3 id="指令周期数据流">指令周期数据流</h3><p>CPU从主存中每取出并执行一条指令所需的全部时间；</p><p>指令周期常常用<code>若干机器周期</code>表示，机器周期又叫CPU周期；</p><p>一个机器周期又包含<code>若干时钟周期</code>（CPU操作的最基本单位）；</p><p>每个指令周期内机器周期可以不相等，每个机器周期内的时钟周期也可以不相等；</p><p><img src="https://img.lishangcc.top//img/image-20220724002535067.png" alt="image-20220724002535067"></p><h3 id="指令周期流程">指令周期流程</h3><p><img src="https://img.lishangcc.top//img/image-20220723185713352.png" alt="image-20220723185713352"></p><ul><li>取指周期：取指令；</li><li>间址周期：取有效地址，只在间接寻址有；</li><li>执行周期：取操作数；</li><li>中断周期：保存程序断点；</li></ul><blockquote><p>每个周期都有CPU访存操作；</p><p>为判断指令处于哪个周期，可设置相应触发器：FE（置1，取指周期）、IND（置1，间址周期）、EX（置1，执行周期）、INT（置1，中断周期）；</p></blockquote><h4 id="取指周期">取指周期</h4><ol><li>当前指令地址送至存储器地址寄存器，记：（PC）→MAR；</li><li>控制单元（CU）发出控制信号，经控制总线传到主存，读信号为例，记：1→R；</li><li>将MAR所指主存中的内容经数据总线送入MDR，记：M（MAR）→MDR；</li><li>将MDR中的内容（此时是指令）送入IR，记：（MDR）→IR；</li><li>CU发出控制信号，形成下一条指令地址，记：（PC）+1→PC；</li></ol><p><img src="https://img.lishangcc.top//img/image-20220723092248358.png" alt="image-20220723092248358"></p><h4 id="间址周期">间址周期</h4><p>指令采用间接寻址才有；</p><ol><li>将指令的地址码送入MAR，记：Ad（IR）→MAR 或 Ad（MDR）→MAR；</li><li>CU发出控制信号，启动主存做读操作，记：1→R；</li><li>将MAR所指主存中的内容经数据总线送入MDR，记：M（MAR）→MDR；</li><li>将有效地址送至指令的地址码字段，记：（MDR）→Ad（IR）；</li></ol><p><img src="https://img.lishangcc.top//img/image-20220723093028670.png" alt="image-20220723093028670"></p><h4 id="执行周期">执行周期</h4><p>根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果，不同指令的执行周期不同，因此没有统一的数据流向；</p><h4 id="中断周期">中断周期</h4><p>中断：暂停当前任务去完成其他任务，为了能够恢复当前任务，需保存断点；</p><p>一般使用堆栈来保存断点，<strong>这里用SP表示栈顶地址</strong>，假设SP指向栈顶元素，进栈操作是先修改指针，后存入数据；</p><ol><li>CU控制将SP减1，修改后的地址送入MAR，记：（SP）-1→SP，（SP）→MAR；（本质上是将断点存入某个存储单元，假设其地址为a，记：a→MAR）；</li><li>CU发出控制信号，启动主存做<code>写操作</code>，记：1→W；</li><li>将断点（PC的内容）送入MDR，记：（PC）→MDR；</li><li>CU控制将终端服务程序的入口地址（由向量地址形成部件产生）送入PC，记：向量地址→PC；</li></ol><blockquote><p>理解一下：若某程序发生中断，之后将会执行新程序，执行完新程序后，根据中断时压入堆栈的栈顶元素恢复PC的值以找到之前的程序；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220723184459107.png" alt="image-20220723184459107"></p><h2 id="数据通路">数据通路</h2><p>即数据在功能部件之间传送的路径；</p><p>考法：给一条指令，分析各阶段的微操作序列和控制信号；</p><h3 id="CPU内部单总线方式">CPU内部单总线方式</h3><blockquote><p>扩展一下：</p><p><strong>内部总线</strong>：指同一部件，如CPU内部连接各寄存器及运算部件之间的总线；</p><p><strong>系统总线</strong>：指同一台计算机系统的各部件，如CPU、内存、通道、各类I/O接口之间相互连接的总线；</p></blockquote><ol><li><p><strong>寄存器之间数据传送</strong></p><p><code>比如把PC内容送至MAR</code>，实现传送操作的流程及控制信号为：</p><ul><li><p><code>(PC)→Bus</code>PCout有效，PC内容送总线（Bus为总线的意思）；</p></li><li><p><code>Bus→MAR</code>MARin有效，总线内容送MAR；</p></li></ul></li><li><p><strong>主存与CPU之间数据传送</strong></p><p><code>比如CPU从主存读取指令</code>，实现传送操作的流程及控制信号为：</p><ul><li><code>(PC)→Bus→MAR</code>PCout和MARin有效，现行指令地址传给MAR；</li><li><code>1→R </code>                            CU发出读命令（通过控制总线发出）；</li><li><code>MEM（MAR）→MDR</code>     MDRin有效；</li><li><code>MDR→Bus→IR </code>           MDRout和IRin有效，现行指令传给IR；</li></ul></li><li><p><strong>执行算术或逻辑运算</strong></p><p><code>比如一条加法指令</code>，微操作序列及控制信号为：</p><ul><li><p><code>Ad(IR)→Bus→MAR</code>MDRout和MARin有效；</p></li><li><p><code>1→R</code>CU发出读命令；</p></li><li><p><code>MEN(MAR)→数据线→MDR</code>MDRin有效；</p></li><li><p><code>MDR→Bus→Y</code>MDRout和Yin有效，操作数传给Y；</p></li><li><p><code>(ACC)+(Y)→Z</code>ACCout和ALUin有效，CU向ALU发送加命令；</p></li><li><p><code>Z→ACC</code>Zout和ACCin有效，结果传给ACC；</p></li></ul><blockquote><p>例题</p><p>如图所示的单总线结构，分析指令ADD（R0），R1的指令流程和控制信号；</p><p><img src="https://img.lishangcc.top//img/image-20220724100852572.png" alt="image-20220724100852572"></p><p><strong>取指周期</strong>：公共操作</p><table><thead><tr><th style="text-align:center">时序</th><th style="text-align:center">微操作</th><th style="text-align:center">有效控制信号</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">(PC)→MAR</td><td style="text-align:center">PCout，MARin</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">M(MAR)→MDR<br />(PC)+1→PC</td><td style="text-align:center">MemR，MARout，MDRinE</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">(MDR)→IR</td><td style="text-align:center">MDRout，IRin</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">指令译码</td><td style="text-align:center">-</td></tr></tbody></table><p><strong>间址周期</strong>：完成取数操作，被加数在主存中，加数已放在寄存器R1中；（题目中R0带括号，表示存的是一个地址，即采用间接寻址，被加数在其所指向的地址中，而R1不带括号，即加数直接存在寄存器R1中）</p><table><thead><tr><th style="text-align:center">时序</th><th style="text-align:center">微操作</th><th style="text-align:center">有效控制信号</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">(R0)→MAR</td><td style="text-align:center">R0out，MARin</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">M(MAR)→MDR</td><td style="text-align:center">MemR，MARout，MDRinE</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">(MDR)→Y<br /># Y为暂存寄存器</td><td style="text-align:center">MDRout，Yin</td></tr></tbody></table><p><strong>执行周期</strong>：最终结果放在主存中，即R0所指地址中；</p><table><thead><tr><th style="text-align:center">时序</th><th style="text-align:center">微操作</th><th style="text-align:center">有效控制信号</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">(R1)+(Y)→Z</td><td style="text-align:center">R1out，ALUin，CU向ALU发ADD控制信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">(Z)→MDR</td><td style="text-align:center">Zout，MDRin</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">(MDR)→M(MAR)</td><td style="text-align:center">MemW，MDRoutE，MARout</td></tr></tbody></table></blockquote></li></ol><h3 id="专用数据通路方式">专用数据通路方式</h3><h2 id="控制器设计">控制器设计</h2><h3 id="硬布线控制器">硬布线控制器</h3><p><img src="https://img.lishangcc.top//img/image-20220724111051638.png" alt="image-20220724111051638"></p><p>取指周期微操作时序安排</p><p>间址周期微操作时序安排</p><p>执行周期微操作时序安排</p><h3 id="微程序控制器">微程序控制器*</h3><p><code>微程序</code>设计思想：将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令；</p><p>这些微程序可以存放在一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的命令；</p><blockquote><p><code>程序</code>：由指令序列组成；</p><p><code>微程序</code>：由微指令序列组成，每一种指令对应一个微程序；</p><p>指令是对程序执行步骤的描述；</p><p>微指令是对指令执行步骤的描述；</p><p>指令是对微指令功能的封装；</p><p>微命令与微操作一一对应；</p><p>微指令中可能包含多个微命令；</p></blockquote><h4 id="微指令的设计">微指令的设计</h4><blockquote><p>探讨：①微指令的具体格式应该怎么设计？②如何根据微指令发出相应的微命令？</p></blockquote><ul><li><p><strong>水平型微指令</strong>*</p><p>一条微指令能定义多个可并行的微命令；</p><blockquote><p>优点：微程序短，执行速度快；</p><p>缺点：微指令长，编写微程序麻烦；</p></blockquote></li><li><p><strong>垂直型微指令</strong></p><p>一条微指令只能定义一个微命令，由微操作码字段规定具体功能；</p></li><li><p><strong>混合型微指令</strong></p></li></ul><h4 id="微指令的编码方式">微指令的编码方式</h4><h5 id="直接编码">直接编码</h5><p>控制字段中每一位代表一个微操作命令；</p><p><img src="https://img.lishangcc.top//img/image-20220725102750205.png" alt="image-20220725102750205"></p><blockquote><p>优点：简单、直观，执行速度快，操作并行性好；</p><p>缺点：微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控存容量极大；</p></blockquote><h5 id="字段直接编码">字段直接编码</h5><p>将微指令的控制字段分成若干段，把互斥性微命令组合在同一个字段中，把相容性微命令组合在不同字段中，每个字段独立编码，每种编码代表一个微命令，且各字段编码含义单独定义，与其他字段无关；</p><blockquote><p>微指令字段分段原则：</p><ol><li>互斥性微命令分在同一段内，相容性微命令分在不同段内；</li><li>每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性；</li><li>一般每个小段还要留出一个状态，表示本字段不发出任何微命令；<br>如：某字段长度为3位，最多只能表示7个互斥的微命令，通常留000表示不操作；</li></ol></blockquote><p><img src="https://img.lishangcc.top//img/image-20220725103700386.png" alt="image-20220725103700386"></p><blockquote><p>优点：可以缩短微指令字长；</p><p>缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢；</p></blockquote><blockquote><p>例题：某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用<code>字段直接编码法</code>，共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有多少位?</p><p>答：3+2+4+3+3=15位</p><p>（若采用直接编码发誓，则需要控制字段33位）</p></blockquote><h5 id="字段间编码">字段间编码</h5><p>一个字段的某些微命令需要另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，因此称为字段间编码，又称隐式编码；</p><h4 id="微程序控制单元的设计">微程序控制单元的设计</h4><p>设计步骤：</p><ol><li>分析每个阶段的微操作序列</li><li>写出对应机器指令的微操作命令及节拍</li><li>确定微指令格式</li><li>编写微指令码点</li></ol><h2 id="指令流水线">指令流水线</h2><blockquote><p>为什么引入流水线结构？</p><p>有哪些结构？</p><p>会产生什么问题？</p></blockquote><p>一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成，如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线；</p><h3 id="流水线的表示方法">流水线的表示方法</h3><p><strong>指令执行过程图</strong></p><p><img src="https://img.lishangcc.top//img/image-20220725114055994.png" alt="image-20220725114055994"></p><p><strong>时空图</strong>*</p><p><img src="https://img.lishangcc.top//img/image-20220725114203623.png" alt="image-20220725114203623"></p><blockquote><p>横坐标：时间，分割成长度相等的时间段T；</p><p>纵坐标：空间，表示当前指令所处的功能部件；</p></blockquote><h3 id="流水线的性能指标">流水线的性能指标</h3><p><code>吞吐率TP</code>：在单位时间内流水线所完成的任务数量，或是输出结构的数量；</p><blockquote><p>设任务数为n，处理完n个任务所用时间为Tk；</p><p>TP=n / TK；</p></blockquote><p><code>加速比S</code>：完成同一批任务，不使用流水线所用时间与使用流水线所用时间之比；</p><blockquote><p>设T0表示不使用流水线时的执行时间，即顺序执行所用时间，Tk表示使用流水线时的执行时间；</p><p>S=T0 / Tk；</p></blockquote><p><code>效率E</code>：流水线的设备利用率；</p><blockquote><p>时空图上，效率为：完成n个任务占用的时空区有效面积与n个任务所用时间与k个流水段所围成的时空区总面积之比；</p><p>E = n个任务占用的时空区有效面积 / n个任务所用时间与k个流水段所围成的时空区总面积 = T0 / (k*Tk)；</p><p><img src="https://img.lishangcc.top//img/image-20220725115310781.png" alt="image-20220725115310781"></p></blockquote><h3 id="流水线影响因素">流水线影响因素</h3><p><strong>结构相关（资源冲突）</strong></p><p>由于多条指令在同一时刻争用同一资源而形成的冲突；</p><blockquote><p>解决办法：</p><ol><li>后一相关指令暂停一周期；</li><li>资源重复配置：数据存储器+指令存储器；</li></ol></blockquote><p><strong>数据相关（数据冲突）</strong>*</p><p>在一个程序中，存在必须等前一条指令执行完成才能执行后一条指令的情况，这两条指令即为数据相关；</p><blockquote><p>解决办法：</p><ol><li>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行；可分为<code>硬件阻塞</code>和<code>软件插入“NOP”</code>两种方法；</li><li>数据旁路技术（转发机制）；</li><li>编译优化：通过编译器调整指令顺序来解决数据相关；</li></ol></blockquote><p><strong>控制相关（控制冲突）</strong></p><p>当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关；</p><p>（理解：当程序执行一条判断语句时，条件满足PC值发生改变，而在判断条件执行过程中，程序会继续顺序取指令，而结果又没有用到）</p><blockquote><p>解决办法：</p><ol><li>转移指令分支预测：简单预测（永远才true或false）、动态预测（根据历史情况动态调整）；</li><li>预取转移成功和不成功两个控制流方向上的目标指令；</li><li>加快和提前形成条件码；</li><li>提高转移方向的猜准率；（第一种的优化）</li></ol></blockquote><h3 id="五段式指令流水线">五段式指令流水线</h3><p>一条指令执行过程分为如下5个阶段：</p><ol><li>IF：取指</li><li>ID：译码&amp;取数</li><li>EX：执行</li><li>MEM：访存</li><li>WB：写回寄存器</li></ol><p><img src="https://img.lishangcc.top//img/image-20220725154525714.png" alt="image-20220725154525714"></p><p>流水线每一个功能段部件后面都有一个<code>缓冲寄存器</code>，或称为<code>锁存器</code>，作用是保存本流水段的执行结果，供下一流水段使用；</p><blockquote><p>考试中常见的五类指令：</p><p>运算类指令、LOAD指令、STORE指令、条件转移指令、无条件转移指令；</p><p>通常，RISC处理器只有<code>取数LOAD</code>和<code>存数STORE</code>指令才能访问主存；</p></blockquote><p><strong>运算类指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：取出操作数至ID段锁存器；</li><li>EX：运算，将结果存入EX段锁存器；</li><li>M：空段；</li><li>WB：将运算结果写回指定寄存器；</li></ol><table><thead><tr><th style="text-align:center">指令举例</th><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">加法指令（两个寄存器相加）</td><td style="text-align:center">ADD Rs，Rd</td><td style="text-align:center">(Rs)+(Rd)→Rd</td></tr><tr><td style="text-align:center">加法指令（寄存器与立即数相机）</td><td style="text-align:center">ADD #996，Rd</td><td style="text-align:center">996+(Rd)→Rd</td></tr><tr><td style="text-align:center">算术左移指令</td><td style="text-align:center">SHL Rd</td><td style="text-align:center">(Rd)&lt;&lt;&lt;2→Rd</td></tr></tbody></table><p><strong>取数LOAD指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：将基址寄存器的值放到锁存器A，将偏移量的值放到Imm；</li><li>EX：运算，得到有效地址；</li><li>M：从数据Cache中取数并放入锁存器；</li><li>WB：将取出的数写回寄存器；</li></ol><table><thead><tr><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">LOAD Rd，996(Rs)</td><td style="text-align:center">(996+(Rs))→Rd</td></tr><tr><td style="text-align:center">LOAD Rd，mem</td><td style="text-align:center">(mem)→Rd</td></tr></tbody></table><p><strong>存数STORE指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：将基址寄存器的值放到锁存器A，将偏移量的值放到Imm，将要存的数放到B；</li><li>EX：运算，得到有效地址，并将锁存器B的内容放到锁存器Store；</li><li>M：写入数据Cache；</li><li>WB：空段；</li></ol><table><thead><tr><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">STORE Rs，996(Rd)</td><td style="text-align:center">Rs→(996+(Rd))</td></tr><tr><td style="text-align:center">STORE Rs，mem</td><td style="text-align:center">Rs→(mem)</td></tr></tbody></table><p><strong>条件转移指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：进行比较的两个数放入锁存器A、B；偏移量放入Imm；</li><li>EX：运算，比较两个数；</li><li>M：将目标PC值写回PC；</li><li>WB：空段；</li></ol><table><thead><tr><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">beq Rs，Rt，#偏移量</td><td style="text-align:center">若(Rs)==(Rt)，则(PC)+指令字长+(偏移量×指令字长)→PC；否则(PC)+指令字长→PC；</td></tr><tr><td style="text-align:center">bne Rs，Rt，#偏移量</td><td style="text-align:center">若(Rs)!=(Rt)，则(PC)+指令字长+(偏移量×指令字长)→PC；否则(PC)+指令字长→PC；</td></tr></tbody></table><p><strong>无条件转移指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：偏移量放入Imm；</li><li>EX：将目标PC值写回PC；</li><li>M：空段；</li><li>WB：空段；</li></ol><table><thead><tr><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">jmp #偏移量</td><td style="text-align:center">(PC)+指令字长+(偏移量×指令字长)→PC；</td></tr></tbody></table><blockquote><p>例题：假设某指令流水线采用“按序发射，按序完成”方式，没有采用转发技术处理数据相关，并且同一寄存器的读和写操作不能在同一个时钟周期内进行。若高级语言程序中某赋值语句为x=a+b，x、a和b均为int型变量，它们的存储单元地址分别表示为[x]、[a]和[b]。该语句对应的指令序列及其在指令流中的执行过程如下图所示。</p><p><img src="https://img.lishangcc.top//img/image-20220725173148839.png" alt="image-20220725173148839"></p><p><img src="https://img.lishangcc.top//img/image-20220725173202613.png" alt="image-20220725173202613"></p><p><strong>分析这4条指令执行过程中I3的ID段和I4的IF段被阻塞的原因各是什么？</strong></p><p>答：①I3与I1和I2存在数据相关；②I4的IF段必须在I3进入ID段后才能开始，否则会覆盖IF段锁存器的内容；</p><p>记住：只有上一条指令进入ID段后，下一条指令才能开始IF段，否则会覆盖IF段锁存器的内容；</p></blockquote><h2 id="多处理器系统">多处理器系统</h2><p>基于指令流的数量和数据流的数量，将计算机体系结构分为SISD、SIMD、MISD和MIMD四类；常规单处理器属于SISD，常规多处理器属于MIMD；</p><p><strong>单指令流单数据流（SISD）结构</strong></p><p>SISD是传统的串行计算机结构，这种计算机通常仅包含一个处理器，一个存储器；处理器在一段时间内仅执行一条指令，按指令流规定的顺序串行执行指令流中的若干条指令；</p><p><strong>多指令多数据流（MIMD）结构</strong></p><p>同时执行多条指令分别处理多个不同的数据，MIMD分为<code>多计算机系统</code>和<code>多处理器系统</code>；</p><p><code>多计算机系统</code>中，每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，不能通过存取指令来访问不同节点的私有存储器，而要通过消息传递进行数据传送，也称<code>消息传递MIMD</code>；</p><p><code>多处理器系统</code>是共享存储多处理器（SMP）系统的简称，他具有共享的单一地址空间，通过存取指令访问系统中所有存储器，也称<code>共享存储MIMD</code>；</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章指令系统</title>
      <link href="/myblog/2022/07/12/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-12-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/myblog/2022/07/12/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-12-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="指令概念">指令概念</h2><h3 id="指令基本格式">指令基本格式</h3><p>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码，一条指令包括**操作码字段（OP）<strong>和</strong>地址码字段（A）**两部分，一条指令可能包含多个地址码，<strong>根据地址码数目不同</strong>，可以将指令分为零地址指令、一地址指令、二地址指令……</p><blockquote><p>理解一下：</p><p>操作码：用户要干什么；地址码：对谁进行操作；</p></blockquote><p><strong>零地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712165522481.png" alt="image-20220712165522481"></p><ol><li>不需要操作数，如空操作、停机、关中断等指令；</li><li>堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果可压回栈顶；</li></ol><p><strong>一地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712165859828.png" alt="image-20220712165859828"></p><ol><li><p>只需要操作数，如加1、减1、取反、求补等；</p><blockquote><p>指令含义：OP(A1)→A1；</p><p>完成一条指令需要3次访存：取指→读A1→写A1；</p></blockquote></li><li><p>需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC）；</p><blockquote><p>指令含义：(ACC)OP(A1)→ACC；</p><p>完成一条指令需要2次访存：取指→读A1；</p></blockquote><blockquote><p>注：A1指某个主存地址（类比C语言指针）；（A1）表示A1所指向的地址中的内容（指针所指位置的内容）。</p></blockquote></li></ol><p><strong>二地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712203945428.png" alt="image-20220712203945428"></p><p>常用于需要两个操作数的算术运算、逻辑运算相关指令；</p><blockquote><p>指令含义：（A1）OP（A2）→A1；</p><p>完成一条指令需要4次访存：取指→读A1→读A2→写A1；</p></blockquote><p><strong>三地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712204145875.png" alt="image-20220712204145875"></p><p>常用于需要两个操作数的算术运算、逻辑运算相关指令；</p><blockquote><p>指令含义：（A1）OP（A2）→A3</p><p>完成一条指令需要4次访存：取指→读A1→读A2→写A3；</p></blockquote><p><strong>四地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712204325040.png" alt="image-20220712204325040"></p><p>正常情况下：取指令之后PC+1，指向下一条指令；</p><p>四地址指令：执行指令后，将PC的值修改为A4所指地址（与前面不同的是PC不是简单的+1，而是可以跳着指向其他地址）；</p><blockquote><p>指令含义：（A1）OP（A2）→A3，A4=下一条将要执行指令的地址；</p><p>完成一条指令需要4次访存：取指→读A1→读A2→写A3；</p></blockquote><h3 id="指令分类">指令分类</h3><p><strong>按指令长度分类</strong></p><ul><li>定长指令字结构：指令系统中所有指令的长度都相等；</li><li>变长指令字结构：指令系统中各种指令的长度不等；</li></ul><blockquote><p>一些概念：</p><p>指令字长：一条指令的总长度；</p><p>机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（与ALU相关）；</p><p>存储字长：一个存储单元中的二进制代码位数（与MDR位数同）；</p><p><strong>指令字长会影响取指令所需时间</strong>，如：机器字长=存储字长=16bit，则存取一条双字长指令需要2次访存；</p></blockquote><p><strong>按操作码长度分类</strong></p><ul><li>定长操作码：指令系统中所有指令的操作码长度相同；</li><li>可变长（扩展）操作码：指令系统中各指令的操作码长度可变；</li></ul><p><strong>按操作类型分类</strong></p><ul><li>数据传送类：CPU、主存之间的数据传送；</li><li>运算类：算数逻辑操作、移位操作；</li><li>程序控制类：改变程序执行流；</li><li>输入输出类：CPU、IO设备之间的数据传送；</li></ul><h3 id="扩展操作码指令格式">扩展操作码指令格式</h3><blockquote><p>定长指令字结构+可变长操作码；</p><p>不同地址数的指令使用不同长度的操作码；</p></blockquote><p>在扩展操作码指令格式时，需注意：</p><ol><li>不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分相同；（类比哈夫曼树）</li><li>各指令的操作码一定不能重复；</li><li>通常情况下，使用频率较高的指令，分配较短的操作码；使用频率较低的指令，分配较长的操作码；</li></ol><p>例：设指令字长固定为16位，试设计一套指令系统满足：</p><ol><li>有15条三地址指令</li><li>有12条二地址指令</li><li>有62条一地址指令</li><li>有32条零地址指令</li></ol><p><img src="https://img.lishangcc.top//img/image-20220713203433455.png" alt="image-20220713203433455"></p><p>设地址长度为n，上一层留出m种状态，下一层可扩展出<strong>m×2^n</strong>种状态；</p><p><img src="https://img.lishangcc.top//img/image-20220713203911765.png" alt="image-20220713203911765"></p><h2 id="指令寻址">指令寻址</h2><p>指令地址：下一条欲执行指令的地址（由程序计数器PC给出），分为顺序寻址、跳跃寻址；</p><h2 id="数据寻址">数据寻址*</h2><p>数据寻址：确定<strong>本条指令</strong>的<strong>地址码指明的真实地址</strong>；</p><h3 id="直接寻址">直接寻址</h3><p>指令字中的形式地址A就是操作数的真实地址EA，即EA=A；</p><p><strong>指令执行过程</strong>：</p><ol><li>取指令，访存1次；</li><li>执行指令：访存1次；</li></ol><blockquote><p>优点：简单，指令执行阶段进访问一次主存，不需专门计算操作数的地址；</p><p>缺点：A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改；</p></blockquote><h3 id="间接寻址">间接寻址</h3><p>指令的地址字段给出的形式地址不是操作数的真实地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=（A）；</p><p><img src="https://img.lishangcc.top//img/image-20220713213733162.png" alt="image-20220713213733162"></p><blockquote><p>优点：可扩大寻址范围（有效地址EA的位数大于形式地址A的位数）；便于编址程序；</p><p>缺点：指令的执行阶段要多次访存（一次间址需要两次访存，多次寻址需根据存储字的最高位确定几次访存）；</p></blockquote><h3 id="寄存器寻址">寄存器寻址</h3><p>在指令字中直接给出操作数所在的寄存器编号，即EA=Ri，其操作数在由Ri所指的寄存器内；</p><p><img src="https://img.lishangcc.top//img/image-20220713214909570.png" alt="image-20220713214909570"></p><p><strong>指令执行过程</strong>：</p><ol><li>取指令：访存1次；</li><li>执行指令：访存0次；</li></ol><blockquote><p>优点：指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快，支持向量/矩阵运算；</p><p>缺点：寄存器价格昂贵，计算机中寄存器个数有限；</p></blockquote><h3 id="寄存器间接寻址">寄存器间接寻址</h3><p>寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=（Ri）；</p><p><img src="https://img.lishangcc.top//img/image-20220713215413969.png" alt="image-20220713215413969"></p><p><strong>指令执行过程</strong>：</p><ol><li>取指令：访存1次；</li><li>执行指令：访存1次；</li></ol><blockquote><p>特点：与一般间接寻址相比，速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）；</p></blockquote><h3 id="隐含寻址">隐含寻址</h3><p>不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址；</p><p><img src="https://img.lishangcc.top//img/image-20220713215714829.png" alt="image-20220713215714829"></p><blockquote><p>优点：有利于缩短指令字长；</p><p>缺点：需增加存储操作数或隐含地址的硬件；</p></blockquote><h3 id="立即寻址">立即寻址</h3><p>形式地址A就是操作数本身，又称为立即数，一般采用补码形式；</p><p><strong>指令执行过程</strong>：</p><ol><li>取指令：访存1次；</li><li>执行指令：访存0次；</li></ol><blockquote><p>优点：指令执行阶段不访问只存，指令执行时间最短；</p><p>缺点：A的位数限制了立即数的范围，如果A的位数为n，且立即数采用补码时，可表示数据的范围为：<img src="https://img.lishangcc.top//img/image-20220713220248342.png" alt="image-20220713220248342"></p></blockquote><p><img src="C:/Users/LS/AppData/Roaming/Typora/typora-user-images/image-20220713220329465.png" alt="image-20220713220329465"></p><h3 id="偏移寻址">偏移寻址</h3><ul><li>基址寻址：以程序的起始存放地址作为 “起点”；EA=(BR)+A</li><li>变址寻址：程序员自己决定从哪里作为 “起点”；EA=(IX)+A</li><li>相对寻址：以程序计数器PC所指地址作为 “起点”；EA=(PC)+A</li></ul><blockquote><p>区别在于偏移的起点不一样；</p></blockquote><h4 id="基址寻址">基址寻址</h4><p>将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=（BR）+A；</p><p><img src="https://img.lishangcc.top//img/image-20220718000025191.png" alt="image-20220718000025191"></p><h4 id="变址寻址">变址寻址</h4><p>有效地址EA等于 指令字中的形式地址A与变址寄存器IX的内容相加之和，即 EA=（IX）+A，其中IX可为变址寄存器（专用），也可用通用寄存器作为变址寄存器；</p><p>变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）；</p><blockquote><p>数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序；</p></blockquote><h4 id="相对地址">相对地址</h4><p>把程序计数器PC的内容加上指令格式的形式地址A而形成操作数的有效地址，即EA=（PC）+A，其中A是相对于PC所指地址的位移量，可正可负，补码表示；</p><p><img src="https://img.lishangcc.top//img/image-20220719203907752.png" alt="image-20220719203907752"></p><h3 id="堆栈寻址">堆栈寻址</h3><p>操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址；</p><p>堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）；</p><h3 id="总结">总结</h3><p><img src="https://img.lishangcc.top//img/image-20220719220113005.png" alt="image-20220719220113005"></p><h2 id="高级语言与机器级代码">高级语言与机器级代码</h2><blockquote><p>考法：</p><ol><li>给出某段简单程序的C语言、汇编语言、机器语言的表示，能结合C语言看懂汇编语言关键语句（常见指令、选择结构、循环结构、函数调用）；</li><li>汇编语言、机器语言一一对应，要能结合汇编语言分析机器语言指令的格式、寻址方式；</li></ol></blockquote><h3 id="X86汇编语言指令">X86汇编语言指令</h3><p>指令的作用：1.改变程序执行流；2.处理数据；</p><p>指令的格式：操作码 + 地址码；</p><p><img src="https://img.lishangcc.top//img/image-20220720000851416.png" alt="image-20220720000851416"></p><p><strong>mov指令</strong></p><p>mov 目的操作数d，源操作数s</p><p>mov指令功能：将源操作数s复制到目的操作数d所指的位置；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax, ebx#将寄存器ebx的值复制到寄存器eax</span><br><span class="line">mov eax, 5#将立即数5复制到寄存器eax</span><br><span class="line">mov eax，dword ptr[af996h]#将内存地址af996h所指的32bit值复制到寄存器eax</span><br><span class="line">mov byte ptr[af996h]，5#将立即数5复制到内存地址af996h所指的一字节中</span><br></pre></td></tr></table></figure><blockquote><p><strong>1.如何指明内存的读写长度：</strong></p><p>dword ptr——双字，32bit<br>word ptr——单字，16bit<br>byte ptr——字节，8bit</p><p><strong>2.X86架构CPU有哪些寄存器：</strong></p><p><img src="https://img.lishangcc.top//img/image-20220719221038865.png" alt="image-20220719221038865"></p></blockquote><h3 id="循环语句的机器表示">循环语句的机器表示</h3><h2 id="CISC和RISC">CISC和RISC</h2><p><strong>CISC：Complex Instruction Set Computer</strong></p><p>一条指令完成一个复杂的基本功能；</p><p>代表：X86架构，主要用于笔记本、台式机等；</p><p>理解：程序+各种库和函数；</p><p><strong>RISC：Reduced Instruction Set Computer</strong></p><p>一条指令完成一个基本动作，多条指令组合完成一个复杂的基本功能；</p><p>代表：ARM架构，主要用于手机、平板；</p><p>理解：原生程序；</p><p><img src="https://img.lishangcc.top//img/image-20220722001624790.png" alt="image-20220722001624790"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章存储系统</title>
      <link href="/myblog/2022/07/04/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-04-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/myblog/2022/07/04/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-04-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><h3 id="存储器的层次化结构">存储器的层次化结构</h3><p><img src="https://img.lishangcc.top//img/image-20220704200541476.png" alt="image-20220704200541476"></p><p><img src="https://img.lishangcc.top//img/image-20220704200853790.png" alt="image-20220704200853790"></p><ul><li>辅存中的数据要调入主存后才能被CPU访问；</li><li><strong>主存—辅存</strong>：实现虚拟存储系统，解决主存容量不够的问题；</li><li><strong>Cache—主存</strong>：解决主存与CPU速度不匹配的问题；</li></ul><h3 id="存储器的分类">存储器的分类</h3><p><strong>按层次</strong></p><ul><li><strong>高速缓存</strong>（Cache）：可直接被CPU读写；</li><li><strong>主存储器</strong>（主存）：可直接被CPU读写；</li><li><strong>辅助存储器</strong>（辅存、外存）</li></ul><p><strong>按存储介质</strong></p><ul><li><strong>半导体存储器</strong>：主存、Cache；</li><li><strong>磁表面存储器</strong>：磁盘、磁带；</li><li><strong>光存储器</strong>：光盘；</li></ul><p><strong>按存取方式</strong></p><ul><li><strong>随机存储存储器（RAM）</strong>：读写任何一个存储单元所需时间都相同，与存储单元所在的物理位置无关；（如：内存条）</li><li><strong>顺序存储存储器（SAM）</strong>：读写一个存储单元所需时间取决于存储单元所在的物理位置；（如：磁带）</li><li><strong>直接存储存储器（DAM）</strong>：既有随机存取特性，也有顺序存取特性；先直接选取信息所在区域，然后按顺序方式存取；（如：机械硬盘）</li></ul><p><strong>按信息的可更改性</strong></p><ul><li><strong>读写存储器</strong>：即可读，也可写；（如：磁盘、内存、Cache）</li><li><strong>只读存储器（ROM）</strong>：只能读，不能写；（如：实体音乐专辑、电影光碟）（事实上现在很多ROM也可以多次读写，只是比较麻烦）</li></ul><p><strong>按信息的可保存性</strong></p><ul><li><strong>易失性存储器</strong>：断电后，存储信息消失的存储器；（主存、Cache）</li><li><strong>非易失性存储器</strong>：断电后，信息依然保持的存储器；（磁盘、光盘）</li><li><strong>破坏性读出</strong>：信息读出后，原存储信息被破坏；（如DRAM芯片）</li><li><strong>非破坏性读出</strong>：与上相反；（如SRAM芯片、磁盘、光盘）</li></ul><h3 id="存储器的性能指标">存储器的性能指标</h3><ol><li>存储容量：存储字数×字长（如1M×8位）（主存储器中的MDR反映存储字长）</li><li>单位成本：每位价格=总成本/中容量；</li><li>存储速度：数据传输率=数据的宽度/存储周期；（数据的宽度即存储字长）</li></ol><blockquote><p><strong>存取时间</strong>（Ta）：存储时间是指从启动一次存储器操作到完成该操作所经历的时间；分为读出时间和写入时间；</p><p><strong>存取周期</strong>（Tm）：又称<strong>读写周期</strong>或<strong>访问周期</strong>，他是指存储器进行一次完整的读写操作所需的全部时间，即<strong>连续两次独立地访问存储操作之间所需的最小时间间隔</strong>；</p><p><strong>主存带宽</strong>（Bm）：又称<strong>数据传输率</strong>，表示每秒从主存进出信息的最大数量，单位：字/秒、字节/秒（B/s）、位/秒（b/s）；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220704215754963.png" alt="image-20220704215754963"></p><h2 id="主存储器的基本组成">主存储器的基本组成</h2><blockquote><ul><li>存储体：也称存储矩阵，由多个存储单元组成，存储单元由存储元组成；</li><li>MAR：n位地址对应2^n个存储单元；</li><li>MDR</li></ul></blockquote><p><img src="https://img.lishangcc.top//img/image-20220705202715405.png" alt="image-20220705202715405"></p><p>总容量=存储单元个数×存储字长</p><p>片选线：一个内存条内可能含有多块存储芯片，由片选片选择哪块芯片；</p><p>金属引脚：地址线+数据线+片选线+读/写控制线；</p><h3 id="SRAM和DRAM">SRAM和DRAM</h3><blockquote><ul><li>DRAM（动态RAM）：用于主存；</li><li>SRAM（静态RAM）：用于Cache；</li></ul></blockquote><table><thead><tr><th style="text-align:center">类型特点</th><th style="text-align:center">SRAM</th><th style="text-align:center">DRAM</th></tr></thead><tbody><tr><td style="text-align:center">存储信息</td><td style="text-align:center">触发器</td><td style="text-align:center">电容</td></tr><tr><td style="text-align:center">破坏性读出</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">读出后是否需要重写</td><td style="text-align:center">不用</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">运行速度</td><td style="text-align:center">快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">集成度</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">发热量</td><td style="text-align:center">大</td><td style="text-align:center">小</td></tr><tr><td style="text-align:center">存储成本</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">易失/非易失性存储器</td><td style="text-align:center">易失</td><td style="text-align:center">易失</td></tr><tr><td style="text-align:center">是否需要刷新</td><td style="text-align:center">不需要（只要不断电，触发器状态就不会改变）</td><td style="text-align:center">需要（电容内的电荷一般只能维持2ms，因此需要刷新）</td></tr><tr><td style="text-align:center">送行列地址</td><td style="text-align:center">同时送</td><td style="text-align:center">分两次送</td></tr></tbody></table><h4 id="DRAM的刷新">DRAM的刷新</h4><p><strong>刷新周期</strong>：一般为2ms；</p><p><strong>每次刷新多少存储单元</strong>：以行为单位，每次刷新一行存储单元；</p><p><strong>存储器的简单模型</strong>（仅用行地址）：会产生有<strong>2^n</strong>根选通线；</p><p><strong>存储器的优化模型</strong>（用行列地址）：一半行地址，一半列地址；会产生**2×2^(n/2)**根选通线；</p><p><strong>如何刷新</strong>：有硬件支持，读出一行的信息后重新写入，占用一个存取周期；</p><p><strong>什么时候刷新</strong>：</p><blockquote><p>假设DRAM内部结构排列成128×128的形式，存取周期0.5us（微秒），2ms内共 2ms/0.5us=4000个周期；</p></blockquote><p>有以下三种思路，其中第三种好；</p><p><img src="https://img.lishangcc.top//img/image-20220705205604290.png" alt="image-20220705205604290"></p><h3 id="只读存储器ROM">只读存储器ROM</h3><blockquote><p>非易失性，断电后数据不会丢失，通常有以下5种，MROM、PROM、EPROM、闪存、SSD；</p></blockquote><p><strong>MROM——掩膜式只读存储器</strong>：由厂家直接写入，后期不可修改；</p><p>PROM——可编程只读存储器：用户可用专门的写入器写入信息，但也只可以写一次；</p><p><strong>EPROM——可擦除可编程只读存储器</strong>：允许用户写入信息，之后可用某种方法擦除数据，可进行多次重写；</p><p><strong>Flash Memory——闪存</strong>：如：U盘、SD卡，断电后也可保存信息，可多次擦除和重写；<br>注意：闪存的写速度要比读速度慢；</p><p><strong>SSD——固态硬盘</strong>：</p><p>由 <strong>控制单元</strong> + <strong>存储单元</strong> （Flash芯片）构成，与闪存的核心区别在于控制单元不一样，但存储介质都类似；</p><h3 id="主存储器与CPU连接">主存储器与CPU连接</h3><p>现在的计算机主要采用以下模式：</p><p><img src="https://img.lishangcc.top//img/image-20220705211324114.png" alt="image-20220705211324114"></p><h4 id="增加主存的存储字长——位扩展">增加主存的存储字长——位扩展</h4><p>主存的位数未用满CPU提供的接口，即MDR；</p><p><img src="https://img.lishangcc.top//img/image-20220705220444207.png" alt="image-20220705220444207"></p><h4 id="增加主存的存储字数——字扩展">增加主存的存储字数——字扩展</h4><p>主存的地址数未用满CPU提供的接口，即MAR；</p><p><img src="https://img.lishangcc.top//img/image-20220705215116296.png" alt="image-20220705215116296"></p><p><strong>线选法</strong>：如上图所示，A14和A13只能为01或10，不能为00或11，因此n条线只有n个选片信号；</p><p><img src="https://img.lishangcc.top//img/image-20220705215001799.png" alt="image-20220705215001799"></p><p><strong>译码片选法</strong>：n条线，2^n个选片信号；（如：1—2译码器（直接用一个非门即可）、2—4译码器、3—8译码器）</p><h4 id="主存容量扩展——字位同时扩展">主存容量扩展——字位同时扩展</h4><p><img src="https://img.lishangcc.top//img/image-20220705215604248.png" alt="image-20220705215604248"></p><p>如上图所示：16K×4位→64K×8位；</p><h2 id="双端口RAM和多模块存储器">双端口RAM和多模块存储器</h2><h3 id="双端口RAM">双端口RAM</h3><p><img src="https://img.lishangcc.top//img/image-20220706210343131.png" alt="image-20220706210343131"></p><blockquote><p>作用：优化多核CPU访问同一根内存条的速度；</p></blockquote><p>两个端口对同一主存的操作有4种情况，其中只有前2种可行（类似于操作系统中 “读者-写者问题” ）：</p><ul><li>两个端口同时对不同的地址单元存取数据；</li><li>两个端口同时对同一地址单元读出数据；</li><li>两个端口同时对同一地址单元写入数据；（写入错误）</li><li>两个端口同时对同一地址单元，一个写入，，一个读出；（读出错误）</li></ul><h3 id="多体并行存储器">多体并行存储器</h3><p>特点：每个模块都有相同的容量和存取速度；各模块都有独立的读写控制电路、地址寄存器和数据寄存器，他们既能并行工作，又能交叉工作；</p><p><strong>高位交叉编址的多体存储器</strong>：地址编号竖着编；</p><p><img src="https://img.lishangcc.top//img/image-20220706212435663.png" alt="image-20220706212435663"></p><p><strong>低位交叉编址的多体存储器</strong>：地址编号横着编；</p><p><img src="https://img.lishangcc.top//img/image-20220706212518149.png" alt="image-20220706212518149"></p><blockquote><p>例：假设每个存储体存取周期为T，存取时间为r，T=4r，若连续访问00000,00001,00010,00011,00100；</p><p><strong>高位交叉编址</strong>耗时如图所示：</p><p><img src="https://img.lishangcc.top//img/image-20220706212913484.png" alt="image-20220706212913484"></p><p>因为在同一存储体内，所以需要等一次存取之后需要等其恢复了才能进行下一次存取；<br>所以其耗时为5T；（若连续取n个存储字，耗时nT）</p><p><strong>低位交叉编址</strong>耗时如图所示：</p><p><img src="https://img.lishangcc.top//img/image-20220706213741018.png" alt="image-20220706213741018"></p><p>因为连续的存储字存储在不同的存储体中，所以在第一个存储体中取完数据后，其恢复期间便可向下一个存储体中的存储单元取数据；<br>耗时T+4r=2T；（连续取n个存储字，耗时T+（n-1）r）</p></blockquote><p>这种低位交叉编址应该取几个&quot;体&quot;呢？（两种说法，但结果一样）</p><blockquote><ol><li>存取周期为T，<strong>存取时间</strong>为r，为了使其工作不间断，应保证模块数 <strong>m&gt;=T/r</strong>；</li><li>存取周期为T，<strong>总线传输周期</strong>为r，为了使其工作不间断，应保证模块数 <strong>m&gt;=T/r</strong>；</li></ol></blockquote><h3 id="单体多字存储器">单体多字存储器</h3><p>相当于把上述多个体合成一整个，每次只能同时取m个字（一取取一整行），不能单独取其中某个字，这种方式灵活性比较差。</p><h2 id="磁盘存储器">磁盘存储器</h2><h3 id="磁盘设备组成">磁盘设备组成</h3><ol><li><p>存储区域</p><p>一块硬盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分若干个扇区（也称块），扇区是磁盘读写的最小单位，</p><p><img src="https://img.lishangcc.top//img/image-20220706222339850.png" alt="image-20220706222339850"></p></li><li><p>硬盘存储器</p><p>硬盘存储器有磁盘驱动器、磁盘控制器和盘片组成；</p><p>磁盘驱动器：核心部件是磁头组件和盘片组件；</p><p>磁盘控制器：是硬盘存储器和主机的接口；</p></li></ol><h3 id="磁盘的性能指标">磁盘的性能指标*</h3><ol><li><p><strong>磁盘的容量</strong>：一个磁盘所能存储的字节总数；</p></li><li><p><strong>记录密度</strong>：记录密度是指盘片单位面积上记录的二进制的信息量，通常以<strong>道密度</strong>、<strong>位密度</strong>和<strong>面密度</strong>表示；</p><blockquote><p>道密度：沿磁盘半径方向上单位长度的磁道数；</p><p>位密度：磁道单位长度上能记录的二进制代码位数；</p><p>面密度：位密度和道密度的乘积；</p><p>注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息量越多，故每个磁道的位密度都不同，越靠内侧的磁道位密度越大；</p></blockquote></li><li><p><strong>平均存取时间（常考）</strong>：</p><p>平均存取时间=寻道时间（磁头移动到目的磁道）+旋转延迟时间（磁头定位到所在扇区）+传输时间（传输数据所花费的时间）；</p><p><img src="https://img.lishangcc.top//img/image-20220707205658498.png" alt="image-20220707205658498"></p><blockquote><p>有的可能还要求加上磁盘控制器延迟时间；</p></blockquote></li><li><p><strong>数据传输率</strong>：磁盘存储器在单位时间内向主机传送数据的字节数；</p><blockquote><p>假设磁盘转数为r（转/秒），每条磁道容量为N个字节，则数据传输率为D=rN；</p></blockquote></li></ol><h3 id="磁盘地址">磁盘地址*</h3><p><img src="https://img.lishangcc.top//img/image-20220707210320188.png" alt="image-20220707210320188"></p><blockquote><p>若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码；</p><p>2bit驱动器号，8bit磁道号，4bit盘面号，4bit扇区号；</p></blockquote><h3 id="硬盘的工作工程">硬盘的工作工程</h3><p>主要操作有<strong>寻址</strong>、<strong>读盘</strong>、<strong>写盘</strong>，每个操作对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字；</p><p>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据；</p><h3 id="磁盘阵列（RAID）">磁盘阵列（RAID）*</h3><p>将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性；</p><p>RAID有以下分级，编号越大越可靠；</p><ul><li><p>RAID0：无冗余和无校验的磁盘阵列；</p><blockquote><p>RAID0把连续多个数据块交替存放在不同物理磁盘扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但<strong>RAID0没有容错能力</strong>；</p></blockquote></li><li><p>RAID1：镜像磁盘阵列；</p><blockquote><p>RAID1是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可从另一磁盘中读取数据；而两个磁盘当一个磁盘使用，意味着<strong>容量减少一半</strong>；</p></blockquote></li><li><p>RAID2：采用纠错的海明码的磁盘阵列；</p></li><li><p>RAID3：位交叉奇偶校验的磁盘阵列；</p></li><li><p>RAID4：块交叉奇偶校验的磁盘阵列；</p></li><li><p>RAID5：无独立校验的奇偶校验磁盘阵列；</p></li></ul><h2 id="固态硬盘SSD">固态硬盘SSD</h2><p><strong>固态硬盘的结构</strong></p><p><img src="https://img.lishangcc.top//img/image-20220707220032183.png" alt="image-20220707220032183"></p><p>块大小：16KB—512KB，页大小：512B—4KB；</p><p><img src="https://img.lishangcc.top//img/image-20220707215832601.png" alt="image-20220707215832601"></p><h2 id="Cache基本概念">Cache基本概念</h2><h3 id="局部性原理">局部性原理</h3><p><strong>空间局部性</strong>：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的；（如：数组元素、顺序执行的指令代码）</p><p><strong>时间局部性</strong>：在最近的未来要用到的信息，很可能是现在正在使用的信息；（循环结构的指令代码）</p><p>基础局部性原理，可以吧CPU目前访问的地址周围的部分数据放到Cache中。</p><blockquote><p>如何界定局部性原理中的“周围”呢？</p><p>将主存的存储空间分块，如：每1KB为一块；主存与Cache之间以“块”为单位进行数据交换；</p><p><img src="https://img.lishangcc.top//img/image-20220708213012930.png" alt="image-20220708213012930"></p></blockquote><h3 id="性能分析">性能分析</h3><p><img src="https://img.lishangcc.top//img/image-20220708205052300.png" alt="image-20220708205052300"></p><p>设tc为访问一次Cache所需时间，tm为访问一次主存所需时间；</p><p><strong>命中率H</strong>：CPU欲访问的信息已在Cache中的比率；</p><p><strong>缺失率</strong>：M=1-H；</p><p><strong>系统的平均访问时间</strong>：</p><p>1.先访问Cache，若Cache未命中再访问主存<img src="https://img.lishangcc.top//img/image-20220708205511524.png" alt="image-20220708205511524"></p><p>2.同时访问Cache和主存，若Cache命中则立即停止访问主存<img src="https://img.lishangcc.top//img/image-20220708205825593.png" alt="image-20220708205825593"></p><blockquote><p>例：假设Cache的速度是主存的5倍，且Cache的命中率为95%，则采用Cache后，存储器性能提高多少？</p><p>解：设Cache的存取周期为t，则主存的存取周期为5t；<br><strong>若Cache和主存同时访问</strong>，命中时访问时间为t，未命中时访问时间为5t；<br>平均访问时间：0.95×t+0.05×5t=1.2t；<br>性能提升：5t/1.2t=4.17倍；</p><p><strong>若先访问Cache再访问主存</strong>，命中时访问时间为t，未命中时访问时间为t+5t；<br>平均访问时间：0.95×t+0.05×6t=1.25t；<br>性能提升：5t/1.25t=4倍；</p></blockquote><h3 id="Cache与主存的映射方式">Cache与主存的映射方式</h3><blockquote><p>解决：如何区分Cache与主存的数据块的对应关系。</p></blockquote><blockquote><p>假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B；</p></blockquote><h4 id="全相联映射">全相联映射</h4><p>主存块可以放在Cache的任意位置；</p><p><img src="https://img.lishangcc.top//img/image-20220712114033399.png" alt="image-20220712114033399"></p><p><img src="https://img.lishangcc.top//img/image-20220712113050720.png" alt="image-20220712113050720"></p><p>主存地址共28位，其中主存块号22位，块内地址6位；</p><p>若CPU访问主存地址1…1101 001110：</p><ul><li>主存地址的前22位，对比Cache中所有块的标记；</li><li>若标记匹配且有效位为1，则Cache命中，访问块内地址为001110单元；</li><li>若未命中或有效位为0，则正常访问主存；</li></ul><blockquote><p>优点：Cache存储空间利用充分，命中率高；</p><p>缺点：查找标记最慢，有可能需要对比所有行的标记；</p></blockquote><h4 id="直接映射">直接映射</h4><p>每个主存块只能放到一个特定的位置；</p><p><strong>Cache块号=主存块号%Cache总块数</strong>；</p><p><img src="https://img.lishangcc.top//img/image-20220712115149596.png" alt="image-20220712115149596"></p><p>与上题一样，22位主存块号（其中19位标记，3位行号），6位块内地址；</p><p>（题目中Cache总块数为8，所以主存块号%2^3相当于留下主存块号后三位二进制数）</p><p>若CPU访问主存地址0…01000 001110：</p><ul><li>根据主存块号的后3位确定Cache行；</li><li>若主存块号的前19位与Cache标记匹配且有效位为1，则Cache命中，访问块内地址为001110的单元；</li><li>若为命中或有效位为0，则正常访问主存；</li></ul><blockquote><p>优点：对于任意一个地址，只需对比一个标记，速度最快；</p><p>缺点：Cache存储空间利用不充分，命中率低；</p></blockquote><h4 id="组相联映射">组相联映射</h4><p>Cache块分为若干组，每个主存块可放到特定分组中的任意一个位置；</p><p><strong>所属分组=主存块号%分组数</strong>；</p><p><img src="https://img.lishangcc.top//img/image-20220712142106447.png" alt="image-20220712142106447"></p><p>22位主存块号（20位标记，2位组号），6位块内地址；</p><p>CPU访问主存地址1…1101 001110：</p><ul><li>根据主存块号的后2位，确定所属分组号；</li><li>若主存块号的前20位与分组内的某个标记匹配，且有效位为1，则Cache命中，访问块内地址001110的单元；</li><li>若未命中或有效位为0，则正常访问主存；</li></ul><blockquote><p>优点：另外两种方式的折中，<strong>综合效果较好</strong>；</p><p>术语：n路组相联映射——每n个Cache行为一组；</p></blockquote><h3 id="Cache替换算法">Cache替换算法</h3><blockquote><p>解决：如果Cache满了怎么办？</p></blockquote><ul><li><strong>全相联映射</strong>：Cache完全满了才需要替换，需要在全局中选择替换哪一块；</li><li><strong>直接映射（无需考虑替换算法）</strong>：如果对应位置非空，则毫无选择地直接替换；</li><li><strong>组相联映射</strong>：分组内满了才需要替换，需要在分组内选择替换哪一块；</li></ul><h4 id="随机算法（RAND）">随机算法（RAND）</h4><p>若Cache已满，则随机选择一块替换；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p><img src="https://img.lishangcc.top//img/image-20220712142841936.png" alt="image-20220712142841936"></p><p>特点：实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定；</p></blockquote><h4 id="先进先出算法（FIFO）">先进先出算法（FIFO）</h4><p>若Cache已满，则替换最先被调入Cache的块；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p><img src="https://img.lishangcc.top//img/image-20220712143022549.png" alt="image-20220712143022549"></p><p>特点：也是实现简单，但依然没考虑局部性原理，最先被调入Cache的块也有可能是被频繁访问的，而且可能出现抖动现象；</p></blockquote><blockquote><p><strong>抖动现象</strong>：频繁的换入换出现象（刚被替换的块很快又被调入）；</p></blockquote><h4 id="近期最少使用（LRU）">近期最少使用（LRU）*</h4><p>为每一个Cache块设置一个计数器，用于记录每个Cache块已经有多久没被访问了，当Cache满后，<strong>替换计数器最大的</strong>；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p>步骤：</p><ol><li>命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变；</li><li>未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1；</li><li>未命中且无空闲行时，计数值最大的信息块被淘汰，新装行的块的计数器置0，其余全加1；</li></ol><p><img src="https://img.lishangcc.top//img/image-20220712143554578.png" alt="image-20220712143554578"></p><p>（Cache块的总数为2^n，则计数器只需n位）</p><p>特点：基于局部性原理，LRU算法的实际运行效果优秀，Cache命中率高；若被频繁访问的主存块数量 &gt; Cache行的数量，则可能发生抖动现象；</p></blockquote><h4 id="最不经常使用（LFU）">最不经常使用（LFU）</h4><p>为每一个Cache块设置一个计数器，用于记录每个Cache块被访问过几次，当Cache满后，<strong>替换计数器最小的</strong>；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p>步骤：<br>新调入的块计数器=0，之后每访问一次计数器+1，需要替换时，选择计数器最小的一行；</p><p><img src="https://img.lishangcc.top//img/image-20220712144015714.png" alt="image-20220712144015714"></p><p>特点：曾经被经常访问的主存块在未来不一定会用到，并没有很好的遵循局部性原理，因此实际效果不如LRU；</p></blockquote><h3 id="Cache写策略">Cache写策略</h3><blockquote><p>解决：CPU如果修改了Cache中的数据副本，如何确保主存中数据母本的一致性？</p></blockquote><h4 id="写命中">写命中</h4><p><strong>写回法</strong>：当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存；</p><blockquote><p>减少了访存次数，但存在数据不一致的隐患；</p></blockquote><p><strong>全写法</strong>：当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲；</p><blockquote><p>访存次数增加，速度变慢，但更能保证数据一致性；</p><p>使用写缓存，CPU写的速度很快，若写操作不频繁，则效果很好；若写操作频繁，则可能因为写缓存饱和而发生阻塞；</p></blockquote><h4 id="写不命中">写不命中</h4><p><strong>写分配法</strong>：当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改，通常<strong>搭配写回法使用</strong>；</p><p><strong>非写分配法</strong>：当CPU对Cache写不命中时，只写入内存，不调入Cache，通常<strong>搭配写全法使用</strong>；</p><blockquote><p>多级Cache</p><p>现代计算机通常采用多级Cache结构，各级Cache之间通常采用“全写法+非写分配法”，Cache和主存之间通常采用“写回法+写分配法”；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法</title>
      <link href="/myblog/2022/03/15/2022-03-15-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/myblog/2022/03/15/2022-03-15-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Java</button></li><li class="tab"><button type="button" data-href="#test-3">C</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/myblog/2022/03/02/hello-world/"/>
      <url>/myblog/2022/03/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
