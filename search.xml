<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第三章存储系统</title>
      <link href="/myblog/2022/07/04/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-04-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/myblog/2022/07/04/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-04-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><h3 id="存储器的层次化结构">存储器的层次化结构</h3><p><img src="https://img.lishangcc.top//img/image-20220704200541476.png" alt="image-20220704200541476"></p><p><img src="https://img.lishangcc.top//img/image-20220704200853790.png" alt="image-20220704200853790"></p><ul><li>辅存中的数据要调入主存后才能被CPU访问；</li><li><strong>主存—辅存</strong>：实现虚拟存储系统，解决主存容量不够的问题；</li><li><strong>Cache—主存</strong>：解决主存与CPU速度不匹配的问题；</li></ul><h3 id="存储器的分类">存储器的分类</h3><p><strong>按层次</strong></p><ul><li><strong>高速缓存</strong>（Cache）：可直接被CPU读写；</li><li><strong>主存储器</strong>（主存）：可直接被CPU读写；</li><li><strong>辅助存储器</strong>（辅存、外存）</li></ul><p><strong>按存储介质</strong></p><ul><li><strong>半导体存储器</strong>：主存、Cache；</li><li><strong>磁表面存储器</strong>：磁盘、磁带；</li><li><strong>光存储器</strong>：光盘；</li></ul><p><strong>按存取方式</strong></p><ul><li><strong>随机存储存储器（RAM）</strong>：读写任何一个存储单元所需时间都相同，与存储单元所在的物理位置无关；（如：内存条）</li><li><strong>顺序存储存储器（SAM）</strong>：读写一个存储单元所需时间取决于存储单元所在的物理位置；（如：磁带）</li><li><strong>直接存储存储器（DAM）</strong>：既有随机存取特性，也有顺序存取特性；先直接选取信息所在区域，然后按顺序方式存取；（如：机械硬盘）</li></ul><p><strong>按信息的可更改性</strong></p><ul><li><strong>读写存储器</strong>：即可读，也可写；（如：磁盘、内存、Cache）</li><li><strong>只读存储器（ROM）</strong>：只能读，不能写；（如：实体音乐专辑、电影光碟）（事实上现在很多ROM也可以多次读写，只是比较麻烦）</li></ul><p><strong>按信息的可保存性</strong></p><ul><li><strong>易失性存储器</strong>：断电后，存储信息消失的存储器；（主存、Cache）</li><li><strong>非易失性存储器</strong>：断电后，信息依然保持的存储器；（磁盘、光盘）</li><li><strong>破坏性读出</strong>：信息读出后，原存储信息被破坏；（如DRAM芯片）</li><li><strong>非破坏性读出</strong>：与上相反；（如SRAM芯片、磁盘、光盘）</li></ul><h3 id="存储器的性能指标">存储器的性能指标</h3><ol><li>存储容量：存储字数×字长（如1M×8位）（主存储器中的MDR反映存储字长）</li><li>单位成本：每位价格=总成本/中容量；</li><li>存储速度：数据传输率=数据的宽度/存储周期；（数据的宽度即存储字长）</li></ol><blockquote><p><strong>存取时间</strong>（Ta）：存储时间是指从启动一次存储器操作到完成该操作所经历的时间；分为读出时间和写入时间；</p><p><strong>存取周期</strong>（Tm）：又称<strong>读写周期</strong>或<strong>访问周期</strong>，他是指存储器进行一次完整的读写操作所需的全部时间，即<strong>连续两次独立地访问存储操作之间所需的最小时间间隔</strong>；</p><p><strong>主存带宽</strong>（Bm）：又称<strong>数据传输率</strong>，表示每秒从主存进出信息的最大数量，单位：字/秒、字节/秒（B/s）、位/秒（b/s）；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220704215754963.png" alt="image-20220704215754963"></p><h2 id="主存储器的基本组成">主存储器的基本组成</h2><blockquote><ul><li>存储体：也称存储矩阵，由多个存储单元组成，存储单元由存储元组成；</li><li>MAR：n位地址对应2^n个存储单元；</li><li>MDR</li></ul></blockquote><p><img src="https://img.lishangcc.top//img/image-20220705202715405.png" alt="image-20220705202715405"></p><p>总容量=存储单元个数×存储字长</p><p>片选线：一个内存条内可能含有多块存储芯片，由片选片选择哪块芯片；</p><p>金属引脚：地址线+数据线+片选线+读/写控制线；</p><h3 id="SRAM和DRAM">SRAM和DRAM</h3><blockquote><ul><li>DRAM（动态RAM）：用于主存；</li><li>SRAM（静态RAM）：用于Cache；</li></ul></blockquote><table><thead><tr><th style="text-align:center">类型特点</th><th style="text-align:center">SRAM</th><th style="text-align:center">DRAM</th></tr></thead><tbody><tr><td style="text-align:center">存储信息</td><td style="text-align:center">触发器</td><td style="text-align:center">电容</td></tr><tr><td style="text-align:center">破坏性读出</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">读出后是否需要重写</td><td style="text-align:center">不用</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">运行速度</td><td style="text-align:center">快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">集成度</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">发热量</td><td style="text-align:center">大</td><td style="text-align:center">小</td></tr><tr><td style="text-align:center">存储成本</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">易失/非易失性存储器</td><td style="text-align:center">易失</td><td style="text-align:center">易失</td></tr><tr><td style="text-align:center">是否需要刷新</td><td style="text-align:center">不需要（只要不断电，触发器状态就不会改变）</td><td style="text-align:center">需要（电容内的电荷一般只能维持2ms，因此需要刷新）</td></tr><tr><td style="text-align:center">送行列地址</td><td style="text-align:center">同时送</td><td style="text-align:center">分两次送</td></tr></tbody></table><h4 id="DRAM的刷新">DRAM的刷新</h4><p><strong>刷新周期</strong>：一般为2ms；</p><p><strong>每次刷新多少存储单元</strong>：以行为单位，每次刷新一行存储单元；</p><p><strong>存储器的简单模型</strong>（仅用行地址）：会产生有<strong>2^n</strong>根选通线；</p><p><strong>存储器的优化模型</strong>（用行列地址）：一半行地址，一半列地址；会产生**2×2^(n/2)**根选通线；</p><p><strong>如何刷新</strong>：有硬件支持，读出一行的信息后重新写入，占用一个存取周期；</p><p><strong>什么时候刷新</strong>：</p><blockquote><p>假设DRAM内部结构排列成128×128的形式，存取周期0.5us（微秒），2ms内共 2ms/0.5us=4000个周期；</p></blockquote><p>有以下三种思路，其中第三种好；</p><p><img src="https://img.lishangcc.top//img/image-20220705205604290.png" alt="image-20220705205604290"></p><h3 id="只读存储器ROM">只读存储器ROM</h3><blockquote><p>非易失性，断电后数据不会丢失，通常有以下5种，MROM、PROM、EPROM、闪存、SSD；</p></blockquote><p><strong>MROM——掩膜式只读存储器</strong>：由厂家直接写入，后期不可修改；</p><p>PROM——可编程只读存储器：用户可用专门的写入器写入信息，但也只可以写一次；</p><p><strong>EPROM——可擦除可编程只读存储器</strong>：允许用户写入信息，之后可用某种方法擦除数据，可进行多次重写；</p><p><strong>Flash Memory——闪存</strong>：如：U盘、SD卡，断电后也可保存信息，可多次擦除和重写；<br>注意：闪存的写速度要比读速度慢；</p><p><strong>SSD——固态硬盘</strong>：</p><p>由 <strong>控制单元</strong> + <strong>存储单元</strong> （Flash芯片）构成，与闪存的核心区别在于控制单元不一样，但存储介质都类似；</p><h3 id="主存储器与CPU连接">主存储器与CPU连接</h3><p>现在的计算机主要采用以下模式：</p><p><img src="https://img.lishangcc.top//img/image-20220705211324114.png" alt="image-20220705211324114"></p><h4 id="增加主存的存储字长——位扩展">增加主存的存储字长——位扩展</h4><p>主存的位数未用满CPU提供的接口，即MDR；</p><p><img src="https://img.lishangcc.top//img/image-20220705220444207.png" alt="image-20220705220444207"></p><h4 id="增加主存的存储字数——字扩展">增加主存的存储字数——字扩展</h4><p>主存的地址数未用满CPU提供的接口，即MAR；</p><p><img src="https://img.lishangcc.top//img/image-20220705215116296.png" alt="image-20220705215116296"></p><p><strong>线选法</strong>：如上图所示，A14和A13只能为01或10，不能为00或11，因此n条线只有n个选片信号；</p><p><img src="https://img.lishangcc.top//img/image-20220705215001799.png" alt="image-20220705215001799"></p><p><strong>译码片选法</strong>：n条线，2^n个选片信号；（如：1—2译码器（直接用一个非门即可）、2—4译码器、3—8译码器）</p><h4 id="主存容量扩展——字位同时扩展">主存容量扩展——字位同时扩展</h4><p><img src="https://img.lishangcc.top//img/image-20220705215604248.png" alt="image-20220705215604248"></p><p>如上图所示：16K×4位→64K×8位；</p><h2 id="双端口RAM和多模块存储器">双端口RAM和多模块存储器</h2><h3 id="双端口RAM">双端口RAM</h3><p><img src="https://img.lishangcc.top//img/image-20220706210343131.png" alt="image-20220706210343131"></p><blockquote><p>作用：优化多核CPU访问同一根内存条的速度；</p></blockquote><p>两个端口对同一主存的操作有4种情况，其中只有前2种可行（类似于操作系统中 “读者-写者问题” ）：</p><ul><li>两个端口同时对不同的地址单元存取数据；</li><li>两个端口同时对同一地址单元读出数据；</li><li>两个端口同时对同一地址单元写入数据；（写入错误）</li><li>两个端口同时对同一地址单元，一个写入，，一个读出；（读出错误）</li></ul><h3 id="多体并行存储器">多体并行存储器</h3><p>特点：每个模块都有相同的容量和存取速度；各模块都有独立的读写控制电路、地址寄存器和数据寄存器，他们既能并行工作，又能交叉工作；</p><p><strong>高位交叉编址的多体存储器</strong>：地址编号竖着编；</p><p><img src="https://img.lishangcc.top//img/image-20220706212435663.png" alt="image-20220706212435663"></p><p><strong>低位交叉编址的多体存储器</strong>：地址编号横着编；</p><p><img src="https://img.lishangcc.top//img/image-20220706212518149.png" alt="image-20220706212518149"></p><blockquote><p>例：假设每个存储体存取周期为T，存取时间为r，T=4r，若连续访问00000,00001,00010,00011,00100；</p><p><strong>高位交叉编址</strong>耗时如图所示：</p><p><img src="https://img.lishangcc.top//img/image-20220706212913484.png" alt="image-20220706212913484"></p><p>因为在同一存储体内，所以需要等一次存取之后需要等其恢复了才能进行下一次存取；<br>所以其耗时为5T；（若连续取n个存储字，耗时nT）</p><p><strong>低位交叉编址</strong>耗时如图所示：</p><p><img src="https://img.lishangcc.top//img/image-20220706213741018.png" alt="image-20220706213741018"></p><p>因为连续的存储字存储在不同的存储体中，所以在第一个存储体中取完数据后，其恢复期间便可向下一个存储体中的存储单元取数据；<br>耗时T+4r=2T；（连续取n个存储字，耗时T+（n-1）r）</p></blockquote><p>这种低位交叉编址应该取几个&quot;体&quot;呢？（两种说法，但结果一样）</p><blockquote><ol><li>存取周期为T，<strong>存取时间</strong>为r，为了使其工作不间断，应保证模块数 <strong>m&gt;=T/r</strong>；</li><li>存取周期为T，<strong>总线传输周期</strong>为r，为了使其工作不间断，应保证模块数 <strong>m&gt;=T/r</strong>；</li></ol></blockquote><h3 id="单体多字存储器">单体多字存储器</h3><p>相当于把上述多个体合成一整个，每次只能同时取m个字（一取取一整行），不能单独取其中某个字，这种方式灵活性比较差。</p><h2 id="磁盘存储器">磁盘存储器</h2><h3 id="磁盘设备组成">磁盘设备组成</h3><ol><li><p>存储区域</p><p>一块硬盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分若干个扇区（也称块），扇区是磁盘读写的最小单位，</p><p><img src="https://img.lishangcc.top//img/image-20220706222339850.png" alt="image-20220706222339850"></p></li><li><p>硬盘存储器</p><p>硬盘存储器有磁盘驱动器、磁盘控制器和盘片组成；</p><p>磁盘驱动器：核心部件是磁头组件和盘片组件；</p><p>磁盘控制器：是硬盘存储器和主机的接口；</p></li></ol><h3 id="磁盘的性能指标">磁盘的性能指标*</h3><ol><li><p><strong>磁盘的容量</strong>：一个磁盘所能存储的字节总数；</p></li><li><p><strong>记录密度</strong>：记录密度是指盘片单位面积上记录的二进制的信息量，通常以<strong>道密度</strong>、<strong>位密度</strong>和<strong>面密度</strong>表示；</p><blockquote><p>道密度：沿磁盘半径方向上单位长度的磁道数；</p><p>位密度：磁道单位长度上能记录的二进制代码位数；</p><p>面密度：位密度和道密度的乘积；</p><p>注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息量越多，故每个磁道的位密度都不同，越靠内侧的磁道位密度越大；</p></blockquote></li><li><p><strong>平均存取时间（常考）</strong>：</p><p>平均存取时间=寻道时间（磁头移动到目的磁道）+旋转延迟时间（磁头定位到所在扇区）+传输时间（传输数据所花费的时间）；</p><p><img src="https://img.lishangcc.top//img/image-20220707205658498.png" alt="image-20220707205658498"></p><blockquote><p>有的可能还要求加上磁盘控制器延迟时间；</p></blockquote></li><li><p><strong>数据传输率</strong>：磁盘存储器在单位时间内向主机传送数据的字节数；</p><blockquote><p>假设磁盘转数为r（转/秒），每条磁道容量为N个字节，则数据传输率为D=rN；</p></blockquote></li></ol><h3 id="磁盘地址">磁盘地址*</h3><p><img src="https://img.lishangcc.top//img/image-20220707210320188.png" alt="image-20220707210320188"></p><blockquote><p>若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码；</p><p>2bit驱动器号，8bit磁道号，4bit盘面号，4bit扇区号；</p></blockquote><h3 id="硬盘的工作工程">硬盘的工作工程</h3><p>主要操作有<strong>寻址</strong>、<strong>读盘</strong>、<strong>写盘</strong>，每个操作对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字；</p><p>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据；</p><h3 id="磁盘阵列（RAID）">磁盘阵列（RAID）*</h3><p>将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性；</p><p>RAID有以下分级，编号越大越可靠；</p><ul><li><p>RAID0：无冗余和无校验的磁盘阵列；</p><blockquote><p>RAID0把连续多个数据块交替存放在不同物理磁盘扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但<strong>RAID0没有容错能力</strong>；</p></blockquote></li><li><p>RAID1：镜像磁盘阵列；</p><blockquote><p>RAID1是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可从另一磁盘中读取数据；而两个磁盘当一个磁盘使用，意味着<strong>容量减少一半</strong>；</p></blockquote></li><li><p>RAID2：采用纠错的海明码的磁盘阵列；</p></li><li><p>RAID3：位交叉奇偶校验的磁盘阵列；</p></li><li><p>RAID4：块交叉奇偶校验的磁盘阵列；</p></li><li><p>RAID5：无独立校验的奇偶校验磁盘阵列；</p></li></ul><h2 id="固态硬盘SSD">固态硬盘SSD</h2><p><strong>固态硬盘的结构</strong></p><p><img src="https://img.lishangcc.top//img/image-20220707220032183.png" alt="image-20220707220032183"></p><p>块大小：16KB—512KB，页大小：512B—4KB；</p><p><img src="https://img.lishangcc.top//img/image-20220707215832601.png" alt="image-20220707215832601"></p><h2 id="Cache基本概念">Cache基本概念</h2><h3 id="局部性原理">局部性原理</h3><p><strong>空间局部性</strong>：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的；（如：数组元素、顺序执行的指令代码）</p><p><strong>时间局部性</strong>：在最近的未来要用到的信息，很可能是现在正在使用的信息；（循环结构的指令代码）</p><p>基础局部性原理，可以吧CPU目前访问的地址周围的部分数据放到Cache中。</p><blockquote><p>如何界定局部性原理中的“周围”呢？</p><p>将主存的存储空间分块，如：每1KB为一块；主存与Cache之间以“块”为单位进行数据交换；</p><p><img src="https://img.lishangcc.top//img/image-20220708213012930.png" alt="image-20220708213012930"></p></blockquote><h3 id="性能分析">性能分析</h3><p><img src="https://img.lishangcc.top//img/image-20220708205052300.png" alt="image-20220708205052300"></p><p>设tc为访问一次Cache所需时间，tm为访问一次主存所需时间；</p><p><strong>命中率H</strong>：CPU欲访问的信息已在Cache中的比率；</p><p><strong>缺失率</strong>：M=1-H；</p><p><strong>系统的平均访问时间</strong>：</p><p>1.先访问Cache，若Cache未命中再访问主存<img src="https://img.lishangcc.top//img/image-20220708205511524.png" alt="image-20220708205511524"></p><p>2.同时访问Cache和主存，若Cache命中则立即停止访问主存<img src="https://img.lishangcc.top//img/image-20220708205825593.png" alt="image-20220708205825593"></p><blockquote><p>例：假设Cache的速度是主存的5倍，且Cache的命中率为95%，则采用Cache后，存储器性能提高多少？</p><p>解：设Cache的存取周期为t，则主存的存取周期为5t；<br><strong>若Cache和主存同时访问</strong>，命中时访问时间为t，未命中时访问时间为5t；<br>平均访问时间：0.95×t+0.05×5t=1.2t；<br>性能提升：5t/1.2t=4.17倍；</p><p><strong>若先访问Cache再访问主存</strong>，命中时访问时间为t，未命中时访问时间为t+5t；<br>平均访问时间：0.95×t+0.05×6t=1.25t；<br>性能提升：5t/1.25t=4倍；</p></blockquote><h3 id="Cache与主存的映射方式">Cache与主存的映射方式</h3><blockquote><p>解决：如何区分Cache与主存的数据块的对应关系。</p></blockquote><blockquote><p>假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B；</p></blockquote><h4 id="全相联映射">全相联映射</h4><p>主存块可以放在Cache的任意位置；</p><p><img src="https://img.lishangcc.top//img/image-20220712114033399.png" alt="image-20220712114033399"></p><p><img src="https://img.lishangcc.top//img/image-20220712113050720.png" alt="image-20220712113050720"></p><p>主存地址共28位，其中主存块号22位，块内地址6位；</p><p>若CPU访问主存地址1…1101 001110：</p><ul><li>主存地址的前22位，对比Cache中所有块的标记；</li><li>若标记匹配且有效位为1，则Cache命中，访问块内地址为001110单元；</li><li>若未命中或有效位为0，则正常访问主存；</li></ul><blockquote><p>优点：Cache存储空间利用充分，命中率高；</p><p>缺点：查找标记最慢，有可能需要对比所有行的标记；</p></blockquote><h4 id="直接映射">直接映射</h4><p>每个主存块只能放到一个特定的位置；</p><p><strong>Cache块号=主存块号%Cache总块数</strong>；</p><p><img src="https://img.lishangcc.top//img/image-20220712115149596.png" alt="image-20220712115149596"></p><p>与上题一样，22位主存块号（其中19位标记，3位行号），6位块内地址；</p><p>（题目中Cache总块数为8，所以主存块号%2^3相当于留下主存块号后三位二进制数）</p><p>若CPU访问主存地址0…01000 001110：</p><ul><li>根据主存块号的后3位确定Cache行；</li><li>若主存块号的前19位与Cache标记匹配且有效位为1，则Cache命中，访问块内地址为001110的单元；</li><li>若为命中或有效位为0，则正常访问主存；</li></ul><blockquote><p>优点：对于任意一个地址，只需对比一个标记，速度最快；</p><p>缺点：Cache存储空间利用不充分，命中率低；</p></blockquote><h4 id="组相联映射">组相联映射</h4><p>Cache块分为若干组，每个主存块可放到特定分组中的任意一个位置；</p><p><strong>所属分组=主存块号%分组数</strong>；</p><p><img src="https://img.lishangcc.top//img/image-20220712142106447.png" alt="image-20220712142106447"></p><p>22位主存块号（20位标记，2位组号），6位块内地址；</p><p>CPU访问主存地址1…1101 001110：</p><ul><li>根据主存块号的后2位，确定所属分组号；</li><li>若主存块号的前20位与分组内的某个标记匹配，且有效位为1，则Cache命中，访问块内地址001110的单元；</li><li>若未命中或有效位为0，则正常访问主存；</li></ul><blockquote><p>优点：另外两种方式的折中，<strong>综合效果较好</strong>；</p><p>术语：n路组相联映射——每n个Cache行为一组；</p></blockquote><h3 id="Cache替换算法">Cache替换算法</h3><blockquote><p>解决：如果Cache满了怎么办？</p></blockquote><ul><li><strong>全相联映射</strong>：Cache完全满了才需要替换，需要在全局中选择替换哪一块；</li><li><strong>直接映射（无需考虑替换算法）</strong>：如果对应位置非空，则毫无选择地直接替换；</li><li><strong>组相联映射</strong>：分组内满了才需要替换，需要在分组内选择替换哪一块；</li></ul><h4 id="随机算法（RAND）">随机算法（RAND）</h4><p>若Cache已满，则随机选择一块替换；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p><img src="https://img.lishangcc.top//img/image-20220712142841936.png" alt="image-20220712142841936"></p><p>特点：实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定；</p></blockquote><h4 id="先进先出算法（FIFO）">先进先出算法（FIFO）</h4><p>若Cache已满，则替换最先被调入Cache的块；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p><img src="https://img.lishangcc.top//img/image-20220712143022549.png" alt="image-20220712143022549"></p><p>特点：也是实现简单，但依然没考虑局部性原理，最先被调入Cache的块也有可能是被频繁访问的，而且可能出现抖动现象；</p></blockquote><blockquote><p><strong>抖动现象</strong>：频繁的换入换出现象（刚被替换的块很快又被调入）；</p></blockquote><h4 id="近期最少使用（LRU）">近期最少使用（LRU）*</h4><p>为每一个Cache块设置一个计数器，用于记录每个Cache块已经有多久没被访问了，当Cache满后，<strong>替换计数器最大的</strong>；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p>步骤：</p><ol><li>命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变；</li><li>未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1；</li><li>未命中且无空闲行时，计数值最大的信息块被淘汰，新装行的块的计数器置0，其余全加1；</li></ol><p><img src="https://img.lishangcc.top//img/image-20220712143554578.png" alt="image-20220712143554578"></p><p>（Cache块的总数为2^n，则计数器只需n位）</p><p>特点：基于局部性原理，LRU算法的实际运行效果优秀，Cache命中率高；若被频繁访问的主存块数量 &gt; Cache行的数量，则可能发生抖动现象；</p></blockquote><h4 id="最不经常使用（LFU）">最不经常使用（LFU）</h4><p>为每一个Cache块设置一个计数器，用于记录每个Cache块被访问过几次，当Cache满后，<strong>替换计数器最小的</strong>；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p>步骤：<br>新调入的块计数器=0，之后每访问一次计数器+1，需要替换时，选择计数器最小的一行；</p><p><img src="https://img.lishangcc.top//img/image-20220712144015714.png" alt="image-20220712144015714"></p><p>特点：曾经被经常访问的主存块在未来不一定会用到，并没有很好的遵循局部性原理，因此实际效果不如LRU；</p></blockquote><h3 id="Cache写策略">Cache写策略</h3><blockquote><p>解决：CPU如果修改了Cache中的数据副本，如何确保主存中数据母本的一致性？</p></blockquote><h4 id="写命中">写命中</h4><p><strong>写回法</strong>：当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存；</p><blockquote><p>减少了访存次数，但存在数据不一致的隐患；</p></blockquote><p><strong>全写法</strong>：当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲；</p><blockquote><p>访存次数增加，速度变慢，但更能保证数据一致性；</p><p>使用写缓存，CPU写的速度很快，若写操作不频繁，则效果很好；若写操作频繁，则可能因为写缓存饱和而发生阻塞；</p></blockquote><h4 id="写不命中">写不命中</h4><p><strong>写分配法</strong>：当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改，通常<strong>搭配写回法使用</strong>；</p><p><strong>非写分配法</strong>：当CPU对Cache写不命中时，只写入内存，不调入Cache，通常<strong>搭配写全法使用</strong>；</p><blockquote><p>多级Cache</p><p>现代计算机通常采用多级Cache结构，各级Cache之间通常采用“全写法+非写分配法”，Cache和主存之间通常采用“写回法+写分配法”；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法</title>
      <link href="/myblog/2022/03/15/2022-03-15-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/myblog/2022/03/15/2022-03-15-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Java</button></li><li class="tab"><button type="button" data-href="#test-3">C</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/myblog/2022/03/02/hello-world/"/>
      <url>/myblog/2022/03/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
