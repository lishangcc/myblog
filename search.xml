<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第二章 进程与线程(上)</title>
      <link href="/myblog/2022/07/31/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-07-31-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B1/"/>
      <url>/myblog/2022/07/31/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-07-31-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<h2 id="进程简述">进程简述</h2><blockquote><p>区别一下程序与进程：</p><p>程序：静态的，就是存放在磁盘里的可执行文件，如：QQ.exe；</p><p>进程：动态的，是程序一次执行过程，如：同时打开多个QQ程序（同一个程序多次执行会对应多个进程）；</p></blockquote><h3 id="进程实体的组成">进程实体的组成</h3><p>进程由<code>PCB</code>、<code>程序段</code>、<code>数据段</code>三部分组成；</p><p>PCB：介绍见下面；</p><p>程序段：程序的代码（指令序列）；</p><p>数据段：运行过程中产生的各种数据（如：程序中定义的变量）；</p><blockquote><p>PCB是给操作系统用的，程序段、数据段是给进程自己用的；</p></blockquote><h3 id="进程控制块PCB">进程控制块PCB</h3><p>PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，回收其PCB；</p><p><strong>PCB保存的信息</strong></p><p><img src="https://img.lishangcc.top//img/image-20220801214628303.png" alt="image-20220801214628303"></p><h3 id="进程的特征">进程的特征</h3><ul><li><code>动态性（最基本特征）</code>：进程是程序的一次执行过程，动态地产生、变化和消亡；</li><li><code>并发性</code>：内存中有多个进程实体，各进程可并发执行；</li><li><code>独立性</code>：进程能独立运行、独立获得资源、独立接受调度的基本单位；</li><li><code>异步性</code>：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供进程同步机制解决异步问题；</li><li><code>结构性</code>：每个进程都会配置PCB，结构上看，进程由程序段、数据段、PCB组成；</li></ul><h2 id="进程的状态与转换">进程的状态与转换</h2><h3 id="进程的状态">进程的状态</h3><p>进程在其生命周期内，由于系统中各进程之间的相互制约及系统的运行环境的变化，使得进程的状态也在不断变化，一般认为进程有以下5种状态，其中中间三种为基本状态；</p><ul><li>创建态：程序正在被创建，尚未转到就绪态，创建进程需要多个步骤：</li><li>就绪态：进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行，系统中同一时间处于就绪状态的进程可能有多个，通常将它们排成一个队列；</li><li>运行态：进程正在处理机上运行，在单处理机中，每个时刻只有一个进程处于运行态；</li><li>阻塞态：又称等待态，进程执行过程中，可能因等待某一事件而暂停运行；</li><li>结束态：也称终止态，进程正在从系统中消失，可能是进程正常结束或其他原因退出运行；</li></ul><h3 id="状态的转换">状态的转换</h3><p>一般认为存在6种状态转换形式；</p><p><img src="https://img.lishangcc.top//img/image-20220801235933386.png" alt="image-20220801235933386"></p><p>**就绪态→运行态：**处于就绪态的进程被调度后，获得处理机资源，进程由就绪态转换为运行态；</p><p>**运行态→就绪态：**处于运行态的进程在时间片用完后，不得不让出处理机，从而进程由运行态转换为就绪态；</p><p>**运行态→阻塞态：**进程请求某一资源（如外设）的使用或等待某一事件的发生（如I/O操作的完成）时，运行态转换为阻塞态；</p><p>**阻塞态→就绪态：**进程等待的事件到来时，中断处理程序必须把相应进程的状态由阻塞态转换为就绪态；</p><h2 id="进程控制">进程控制</h2><p>进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能；</p><p>一般把进程控制的程序段称为原语，执行具有原子性，即执行期间不允许被中断；</p><p>可以用<code>关中断指令</code>和<code>开中断指令</code>这两个特权指令实现原子性；</p><h3 id="进程的创建">进程的创建</h3><p><img src="https://img.lishangcc.top//img/image-20220802100109849.png" alt="image-20220802100109849"></p><h3 id="进程的终止">进程的终止</h3><p><img src="https://img.lishangcc.top//img/image-20220802100148461.png" alt="image-20220802100148461"></p><h3 id="进程的阻塞和唤醒">进程的阻塞和唤醒</h3><p><img src="https://img.lishangcc.top//img/image-20220802100226334.png" alt="image-20220802100226334"></p><h3 id="进程的切换">进程的切换</h3><p><img src="https://img.lishangcc.top//img/image-20220802100315037.png" alt="image-20220802100315037"></p><h2 id="进程通信">进程通信</h2><p>进程间通信（IPC）：两个进程之间产生数据交互；</p><p>进程是分配系统资源的单位，因此各进程拥有的内存地址空间相互独立；</p><h3 id="共享存储">共享存储</h3><p>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换；一般有两种方式；</p><blockquote><p>为避免出错，各进程对共享空间的访问应该是互斥的，即如果一个进程正在访问共享空间，则其他进程不能访问；</p><p>各个进程可使用操作系统内核提供的同步互斥工具（如P、V操作）；</p></blockquote><p><strong>1.基于存储区共享</strong></p><p><img src="https://img.lishangcc.top//img/image-20220802104554051.png" alt="image-20220802104554051"></p><p>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统，这种方式速度很快，是一种高级通信方式；</p><p><strong>2.基于数据结构共享</strong></p><p><img src="https://img.lishangcc.top//img/image-20220802120252857.png" alt="image-20220802120252857"></p><p>比如共享空间里只能放一个长度为10的数组，这种方式速度慢，限制多，是一种低级通信方式；</p><h3 id="消息传递">消息传递</h3><p>进程间的数据交换以<code>格式化的消息</code>（Message）为单位，进程通过操作系统提供的<code>发送消息/接收消息</code>两个原语进行数据交换；一般也有两种方式；</p><p><strong>1.直接通信方式</strong></p><p>点名道姓的形式说明我是谁，我要发给谁；</p><p><img src="https://img.lishangcc.top//img/image-20220802121001891.png" alt="image-20220802121001891"></p><p><strong>2.间接通信方式</strong></p><p>以&quot;信箱&quot;作为中间实体进行消息传递；</p><p><img src="https://img.lishangcc.top//img/image-20220802120800991.png" alt="image-20220802120800991"></p><h3 id="管道通信">管道通信</h3><p>&quot;管道&quot;是一个特殊的共享文件，又名pipe文件，用于连接一个读进程一个写进程，以实现它们之间的通信；</p><p><img src="https://img.lishangcc.top//img/image-20220802190017105.png" alt="image-20220802190017105"></p><ul><li>管道只能采用半双工通信，即某一时间段内只能实现单向的传输，如果要实现双向同时通信，则需要设置两个管道；</li><li>各进程要互斥地访问管道（由操作系统实现）；</li><li>当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程；</li><li>当管道读空时，读进程将阻塞，直到写进程往管道写入新数据，即可唤醒读进程；</li><li>管道中的数据一旦读出，就彻底消失，因此当多个进程读同一个管道时，可能会错乱，对此一般有两种解决方案：①一个管道运行多个写进程，一个读进程（这里只说一种）；</li><li>只要管道没空，读进程就可以从管道读数据；只要管道没满，写进程就可以往管道写数据；</li></ul><h2 id="线程简述">线程简述</h2><h3 id="线程的概念">线程的概念</h3><p>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐率；</p><p>引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能；</p><p><img src="https://img.lishangcc.top//img/image-20220802191538760.png" alt="image-20220802191538760"></p><p>可以把线程理解为轻量级进程；</p><p>线程是一个基本的CPU的执行单元，也是程序执行流的最小单位；</p><p>引入线程后，不仅是进程之间可以并发，进程内的各线程自己也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务；</p><p>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间都是分配给进程的），线程则作为处理机的分配单元；</p><h3 id="线程带来的变化">线程带来的变化</h3><p><img src="C:/Users/LS/AppData/Roaming/Typora/typora-user-images/image-20220802191755499.png" alt="image-20220802191755499"></p><blockquote><p>理解一下运行环境：</p><p>假设去图书馆看书，桌子=处理机，人=进程，看不同的数=线程；<br>切换进程运行环境：有一个不认识的人要用桌子，此时你需要把书搬走，他把自己的书放到桌子上；<br>同一进程内线程切换：你的舍友要用你的桌子，而你们所学相同，则你不用把书搬走；</p></blockquote><h3 id="线程的属性">线程的属性</h3><ul><li>线程是处理机调度的单位；</li><li>多CPU计算机中，各个线程可占用不同的CPU；</li><li>每个线程都有一个线程ID、线程控制块（TCB）；</li><li>线程也有就绪、阻塞、运行三种基本状态；</li><li>线程几乎不拥有系统资源；</li><li>同一线程的不同线程间共享进程的资源；</li><li>由于共享内存地址空间，同一进程中的线程通信甚至不需要系统干预；</li><li>同一进程中的线程切换，不会引起进程切换；</li><li>不同进程中的线程切换，会引起进程切换；</li><li>切换同进程内的线程，系统开销很小；</li><li>切换进程，系统开销较大；</li></ul><h3 id="线程的实现方式">线程的实现方式</h3><p>分两类：用户级线程（ULT）、内核级线程（KLT）；</p><p><strong>1.用户级线程(ULT)</strong></p><p>在用户级线程中，有关线程管理（创建、撤销、切换等）的所有工作都由应用程序在用户空间中完成，内核意识不存在；</p><p>对于设置了用户级线程的系统，其调度仍以进程为单位进行；</p><p><img src="https://img.lishangcc.top//img/image-20220803150841465.png" alt="image-20220803150841465"></p><p>从代码角度看，线程就是一段代码逻辑，此段代码可看作三个&quot;线程&quot;，这个循环体就是一个简易的&quot;线程库&quot;；</p><p><img src="https://img.lishangcc.top//img/image-20220803151952517.png" alt="image-20220803151952517"></p><blockquote><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高；</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度并不高，多个线程不可在多核处理机上并行运行；</p></blockquote><p><strong>2.内核级线程(KLT)</strong></p><p>大多数现代操作系统都实现了内核级线程，如：Windows、Linux；</p><p>内核级线程的管理工作由操作系统内核完成，包括线程调度、切换；操作系统会为每个内核级线程建立相应TCP（线程控制块），通过TCP对线程进行管理；</p><p><img src="https://img.lishangcc.top//img/image-20220803153019916.png" alt="image-20220803153019916"></p><blockquote><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可在多核处理机上并行执行；</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理成本高，开销大；</p></blockquote><h3 id="多线程模型">多线程模型</h3><p>有些系统同时支持用户线程和内核线程，由于用户线程和内核线程连接方式的不同，从而形成三种不同的多线程模型；</p><blockquote><p>可以这么理解：</p><p>用户级线程是&quot;代码逻辑&quot;的载体；<br>内核级线程是&quot;运行机会&quot;的载体；<br>一段&quot;代码逻辑&quot;只有获得&quot;运行机会&quot;才能被CPU执行；</p></blockquote><p><strong>一对一模型</strong></p><p>一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程；</p><p><img src="https://img.lishangcc.top//img/image-20220803172111702.png" alt="image-20220803172111702"></p><blockquote><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可在多核处理机上并行执行；</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大；</p></blockquote><p><strong>多对一模型</strong></p><p>多个用户级线程映射到一个内核级线程，且一个进程只被分配一个内核级线程；</p><p><img src="https://img.lishangcc.top//img/image-20220803172349524.png" alt="image-20220803172349524"></p><blockquote><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高；</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行；</p><p><strong>注意：操作系统只看得见内核级线程，因此只有内核级线程才是处理机分配的单位；</strong></p></blockquote><p><strong>多对多模型</strong></p><p>n个用户级线程映射到m个内核级线程(n&gt;=m)，每个用户进程对应m个内核级线程；</p><p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销大的缺点；</p><p><img src="https://img.lishangcc.top//img/image-20220803172729910.png" alt="image-20220803172729910"></p><h3 id="线程的状态与转换">线程的状态与转换</h3><p>与进程一样，各线程之间也存在共享资源和相互合作的制约关系，致使线程在运行时也具有间断性，相应的，线程在运行时，也具有下面三种基本状态：</p><ul><li><code>执行状态</code>：线程已获得处理机而正在运行；</li><li><code>就绪状态</code>：线程已具备各种执行条件，只需再获得CPU便可立即执行；</li><li><code>阻塞状态</code>：线程在执行中因某事件受阻而处于暂停状态；</li></ul><p><img src="https://img.lishangcc.top//img/image-20220803183231274.png" alt="image-20220803183231274"></p><blockquote><p>线程三种基本状态的转换与进程的状态转换一样，参考上面的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章总线</title>
      <link href="/myblog/2022/07/27/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-27-%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%80%BB%E7%BA%BF/"/>
      <url>/myblog/2022/07/27/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-27-%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="总线概述">总线概述</h2><p>总线是一组能为多个部件<code>分时</code> <code>共享</code>的公共信息传送线路；</p><p><img src="https://img.lishangcc.top//img/image-20220729134130819.png" alt="image-20220729134130819"></p><blockquote><p>为什么要用总线？</p><p>早期计算机外部设备少时大多采用分散连接方式，不易实现随时增减外部设备；<br>为了更好解决I/O设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接</p></blockquote><p>分时：同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时的向总线发送信息；</p><p>共享：总线上可以挂接多个部件，各个部件之间互相交换信息都快通过这组线路分时共享，多个部件可同时从总线上接收相同的信息；</p><h3 id="总线的特性">总线的特性</h3><ul><li>机械特性：尺寸、形状、管脚数、排列顺序；</li><li>电气特性：传输方向和有效的电平范围；</li><li>功能特性：每根传输线的功能（地址、数据、控制）；</li><li>时间特性：信号的时序关系；</li></ul><h3 id="总线的数据传输格式">总线的数据传输格式</h3><h4 id="串行总线">串行总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729134955144.png" alt="image-20220729134955144"></p><p>优点：只需要一个条传输线，成本低廉，广泛应用于长距离传输；应用于计算机内部时，可以节省布线空间；</p><p>缺点：在数据发送和接收时，要进行拆卸和装配，要考虑串行-并行转换的问题；</p><h4 id="并行总线">并行总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729135144434.png" alt="image-20220729135144434"></p><p>优点：总线的逻辑时序比较简单，电路实现起来比较容易；</p><p>缺点：信号线数量多，占用更多的布线空间；远距离传输成本高；</p><h3 id="总线按功能分类">总线按功能分类</h3><h4 id="片内总线">片内总线</h4><p>片内总线是芯片内部的总线，它是CPU芯片内部<code>寄存器</code>和<code>寄存器</code>、<code>寄存器</code>与<code>ALU</code>之间的公共连接线；</p><h4 id="系统总线">系统总线</h4><p>是计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线；</p><p>按系统总线传输信息内容的不同，又可分为3类：<code>数据总线</code>、<code>地址总线</code>、<code>控制总线</code>；</p><p><strong>数据总线（DB）</strong>：传输各功能部件之间的数据信息，包括指令、操作数；位数（根数）与<code>机器字长</code>、<code>存储字长</code>有关，<code>双向</code>；</p><p><strong>地址总线（AB）</strong>：传输地址信息，包括主存单元或I/O端口的地址，位数（根数）与<code>主存地址空间大小</code>及<code>设备数量</code>有关，<code>单向</code>；</p><p><strong>控制总线（CB）</strong>：传输控制信息，一根控制线传输一个信号，有出：CPU送出的控制命令；有入：主存（或外设）返回CPU的反馈信号；</p><h4 id="通信总线">通信总线</h4><p>通信总线用于计算机系统之间或计算机系统与其他系统（如：远程通信设备、测试设备）之间信息传递的总线，也称外部总线；</p><h3 id="系统总线的结构">系统总线的结构</h3><h4 id="单总线">单总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729140252228.png" alt="image-20220729140252228"></p><p>单总线结构将CPU、主存、I/O设备（通过I/O接口）都挂载一组总线上，运行I/O设备之间、I/O设备与主存之间交换信息；</p><blockquote><p>优点：结构简单，成本低，易于接入新设备；</p><p>缺点：带宽低，负载重，多个部件只能争用唯一总线，且不支持并发传送操作；</p></blockquote><h4 id="双总线">双总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729140722038.png" alt="image-20220729140722038"></p><p>双总线结构有两条总线，一条是<code>主存总线</code>，用于CPU、主存和通道之间进行数据传送；另一条是<code>I/O总线</code>，用于多个设备与通道之间进行数据传送；</p><blockquote><p>一些概念</p><p>通道：具有特殊功能的处理器，能对I/O设备进行统一管理，通道程序存放在主存中；</p></blockquote><blockquote><p>优点：将较低速的I/O设备从单总线上分离出来，实现存储器总线和I/O总线的分离；</p><p>缺点：需要增加通道等硬件设备；</p></blockquote><h4 id="三总线">三总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729141117455.png" alt="image-20220729141117455"></p><p>三条总线结构是计算机系统各部件之间采用3条各自独立的总线来构成信息通路，3条总线分别为：<code>主存总线</code>、<code>I/O总线</code>、<code>直接内存访问DMA总线</code>；</p><blockquote><p>优点：提高了I/O设备的性能，使其更快响应命令，提高系统的吞吐量；</p><p>缺点：系统工作效率较低；</p></blockquote><h2 id="总线性能指标">总线性能指标</h2><p><strong>总线传输周期（总线周期）</strong></p><p>一次总线操作所需的时间（包括<code>申请阶段</code>、<code>寻址阶段</code>、<code>传输阶段</code>和<code>结束阶段</code>），通常由若干个总线时钟周期构成；</p><p><strong>总线时钟周期</strong></p><p>即机器的时钟周期；计算机系统有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制；</p><p><strong>总线的工作频率</strong></p><p>总线上各种操作的频率，为总线周期的倒数；理解：1秒内传送几次数据；</p><p><strong>总线的时钟频率</strong></p><p>即机器的时钟频率，为时钟周期的倒数；</p><p><strong>总线宽度</strong></p><p>又称总线位宽，它是总线上同时能够传输的数据位数，通常指数据总线的根数，如32根又称32位总线；</p><p><strong>总线带宽</strong></p><p>可理解为总线的最大数据传输率，即单位时间内总线上最多可传输数据的位数；通常以每秒传送信息的字节数来衡量，即 字节/秒（B/s）表示；</p><blockquote><p>总线带宽 = 总线工作频率 × （总线宽度/8）（B/s）</p></blockquote><p><strong>总线复用</strong></p><p>指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息；</p><p><strong>信号线数</strong></p><p>地址总线、数据总线、控制总线，3种总线数的总和称为信号线数；</p><h2 id="总线操作和定时">总线操作和定时</h2><p><strong>总线周期的四个阶段</strong></p><ol><li><code>申请分配阶段</code>：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者，也可将此阶段细分为传输请求和总线仲裁两个阶段；</li><li><code>寻址阶段</code>：获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，启动参与本次传输的从模块；</li><li><code>传输阶段</code>：主模块和从模块进行数据交换，可单向或双向进行数据传送；</li><li><code>结束阶段</code>：主模块的有关信息均从系统总线上撤除，让出总线使用权；</li></ol><h3 id="总线定时">总线定时</h3><p>指总线在双方交换数据的过程中，需要时间上配合关系的控制，这种控制称为总线定时，它的实质是一种协议；</p><h4 id="同步通信">同步通信</h4><p>也叫同步定时方式，由采用一个<code>统一时钟</code>来协调发送和接收双方的传送定时关系；</p><blockquote><p>假设：CPU作为主设备，某个输入设备作为从设备；</p><p><img src="https://img.lishangcc.top//img/image-20220729164450433.png" alt="image-20220729164450433"></p><ol><li>CPU在T1时刻的上升沿给出地址信息；</li><li>在T2上升沿给出读命令（低电平有效），与地址信息相符合的输入设备按命令进行一系列的内部操作，且必须在T3的上升沿之前将CPU所需的数据送到数据总线上；</li><li>CPU在T3时钟周期内，将数据线上的信息传送到其内部寄存器中；</li><li>CPU在T4上升沿撤销读命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动；</li></ol><p>注：如果从设备跟不上节奏，在T3给不出数据，就哦豁了；</p></blockquote><p>若干个时钟产生相等的时间间隔，每个间隔构成一个总线周期；</p><p>在一个总线周期中，发送方和接收方可进行一次数据传送；</p><p>因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始；</p><blockquote><p>优点：传送速度快快，具有较高的传输速率，总线控制逻辑简单；</p><p>缺点：自从设备属于强制性同步，不能及时进行数据通信的有效性检验，可靠性较差；</p><p>适用：同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统；</p></blockquote><h4 id="异步通信">异步通信</h4><p>也叫异步定时方式，其没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方制约的&quot;握手&quot;信号来实现定时控制；</p><p>主设备提出交换信息的请求信号，经接口传送到从设备，从设备接到主设备的请求后，通过接口想主设备发出回答信号；</p><p>根据&quot;请求&quot;和&quot;回答&quot;信号的撤销是否互锁，分为以下3种类型：</p><p><strong>1.不互锁方式</strong></p><blockquote><p>特点：速度最快，可靠性最差；</p></blockquote><p>主设备发出&quot;请求&quot;信号后，不必等到接收设备的&quot;回答&quot;信号，而是经过一段时间后，便撤销&quot;请求&quot;信号；</p><p>而从设备在接到&quot;请求&quot;信号后，发出&quot;回答&quot;信号，并经过一段时间，自动撤销&quot;回答&quot;信号，双方不存在互锁关系；</p><p><strong>2.半互锁方式</strong></p><p>主设备发出&quot;请求&quot;信号后，必须待接到从设备的&quot;回答&quot;信号后，才撤销&quot;请求&quot;信号，有互锁关系；</p><p>而从设备在接到&quot;请求&quot;信号后，发出&quot;回答&quot;信号，但不必等待主设备&quot;请求&quot;信号撤销，而是隔一段时间后自动撤销&quot;回答&quot;信号，这里不存在互锁关系；</p><p><strong>3.全互锁方式</strong></p><blockquote><p>特点：最可靠，速度最慢；</p></blockquote><p>主设备发出&quot;请求&quot;信号后，必须待从设备&quot;回答&quot;后，才撤销&quot;请求&quot;信号；</p><p>从设备发出&quot;回答&quot;信号后，必须待获知主设备&quot;请求&quot;信号已撤销后，在撤销其&quot;回答&quot;信号；</p><blockquote><p>异步定时方式</p><p>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠的进行信息交换，自动适应时间的配合；</p><p>缺点：比同步控制方式复杂，速度也比同步定时方式慢；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章中央处理器</title>
      <link href="/myblog/2022/07/22/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-22-%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/myblog/2022/07/22/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-22-%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="CPU概述">CPU概述</h2><p>CPU由<code>运算器</code>和<code>控制器</code>组成；</p><p>运算器：对数据进行加工；</p><p>控制器：协调并控制计算机各部件执行程序的指令序列，包括：取指令、分析指令、执行指令；</p><h3 id="运算器基本结构">运算器基本结构</h3><ol><li><strong>算术逻辑单元（ALU）</strong>：进行算术/逻辑运算；</li><li><strong>暂存寄存器</strong>：暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏原有内容；暂存寄存器对程序员是透明的（即不可见）；</li><li><strong>累加寄存器（ACC）</strong>：一个通用寄存器，用于暂时存放ALU的运算结果信息，可以作为加法运算的一个输入端；</li><li><strong>通用寄存器</strong>：用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息；</li><li><strong>程序状态寄存器（PSW）</strong>：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如：溢出标志OF、符号标志SF、零标志ZF、进位标志CF；</li><li><strong>移位器</strong>：对操作数或运算结果进行移位操作运算；</li><li><strong>计数器（CT）</strong>：控制乘除运算的操作步数（乘除结果也是由多次加减得来）；</li></ol><h3 id="控制器基本结构">控制器基本结构</h3><ol><li><strong>程序计数器（PC）</strong>：用于指出下一条指令在主存中的存放地址，PC有自增的功能；</li><li><strong>指令寄存器（IR）</strong>：保存当前正在执行的那条指令；</li><li><strong>指令译码器</strong>：仅对操作码字段进行译码，向控制器提供特定的操作信号；</li><li><strong>存储器地址寄存器（MAR）</strong>：存放要访问的主存单位的地址；</li><li><strong>存储器数据寄存器（MDR）</strong>：存放向主存写入的信息或从主存读出的信息；</li><li><strong>时序系统</strong>：用于产生各种时序信号，由统一时钟（CLOCK）分频得到；</li><li><strong>微操作信号发生器</strong>：根据IR的内容（指令）、PSW的状态信息及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种；</li></ol><h3 id="CPU基本结构">CPU基本结构</h3><p><img src="https://img.lishangcc.top//img/image-20220723000539085.png" alt="image-20220723000539085"></p><p>红框：用户可见；</p><p>灰框：用户不可见；</p><h3 id="CPU功能">CPU功能</h3><ol><li>指令控制</li><li>操作控制</li><li>时间控制</li><li>数据加工</li><li>中断处理</li></ol><h2 id="指令的执行">指令的执行</h2><h3 id="指令周期数据流">指令周期数据流</h3><p>CPU从主存中每取出并执行一条指令所需的全部时间；</p><p>指令周期常常用<code>若干机器周期</code>表示，机器周期又叫CPU周期；</p><p>一个机器周期又包含<code>若干时钟周期</code>（CPU操作的最基本单位）；</p><p>每个指令周期内机器周期可以不相等，每个机器周期内的时钟周期也可以不相等；</p><p><img src="https://img.lishangcc.top//img/image-20220724002535067.png" alt="image-20220724002535067"></p><h3 id="指令周期流程">指令周期流程</h3><p><img src="https://img.lishangcc.top//img/image-20220723185713352.png" alt="image-20220723185713352"></p><ul><li>取指周期：取指令；</li><li>间址周期：取有效地址，只在间接寻址有；</li><li>执行周期：取操作数；</li><li>中断周期：保存程序断点；</li></ul><blockquote><p>每个周期都有CPU访存操作；</p><p>为判断指令处于哪个周期，可设置相应触发器：FE（置1，取指周期）、IND（置1，间址周期）、EX（置1，执行周期）、INT（置1，中断周期）；</p></blockquote><h4 id="取指周期">取指周期</h4><ol><li>当前指令地址送至存储器地址寄存器，记：（PC）→MAR；</li><li>控制单元（CU）发出控制信号，经控制总线传到主存，读信号为例，记：1→R；</li><li>将MAR所指主存中的内容经数据总线送入MDR，记：M（MAR）→MDR；</li><li>将MDR中的内容（此时是指令）送入IR，记：（MDR）→IR；</li><li>CU发出控制信号，形成下一条指令地址，记：（PC）+1→PC；</li></ol><p><img src="https://img.lishangcc.top//img/image-20220723092248358.png" alt="image-20220723092248358"></p><h4 id="间址周期">间址周期</h4><p>指令采用间接寻址才有；</p><ol><li>将指令的地址码送入MAR，记：Ad（IR）→MAR 或 Ad（MDR）→MAR；</li><li>CU发出控制信号，启动主存做读操作，记：1→R；</li><li>将MAR所指主存中的内容经数据总线送入MDR，记：M（MAR）→MDR；</li><li>将有效地址送至指令的地址码字段，记：（MDR）→Ad（IR）；</li></ol><p><img src="https://img.lishangcc.top//img/image-20220723093028670.png" alt="image-20220723093028670"></p><h4 id="执行周期">执行周期</h4><p>根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果，不同指令的执行周期不同，因此没有统一的数据流向；</p><h4 id="中断周期">中断周期</h4><p>中断：暂停当前任务去完成其他任务，为了能够恢复当前任务，需保存断点；</p><p>一般使用堆栈来保存断点，<strong>这里用SP表示栈顶地址</strong>，假设SP指向栈顶元素，进栈操作是先修改指针，后存入数据；</p><ol><li>CU控制将SP减1，修改后的地址送入MAR，记：（SP）-1→SP，（SP）→MAR；（本质上是将断点存入某个存储单元，假设其地址为a，记：a→MAR）；</li><li>CU发出控制信号，启动主存做<code>写操作</code>，记：1→W；</li><li>将断点（PC的内容）送入MDR，记：（PC）→MDR；</li><li>CU控制将终端服务程序的入口地址（由向量地址形成部件产生）送入PC，记：向量地址→PC；</li></ol><blockquote><p>理解一下：若某程序发生中断，之后将会执行新程序，执行完新程序后，根据中断时压入堆栈的栈顶元素恢复PC的值以找到之前的程序；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220723184459107.png" alt="image-20220723184459107"></p><h2 id="数据通路">数据通路</h2><p>即数据在功能部件之间传送的路径；</p><p>考法：给一条指令，分析各阶段的微操作序列和控制信号；</p><h3 id="CPU内部单总线方式">CPU内部单总线方式</h3><blockquote><p>扩展一下：</p><p><strong>内部总线</strong>：指同一部件，如CPU内部连接各寄存器及运算部件之间的总线；</p><p><strong>系统总线</strong>：指同一台计算机系统的各部件，如CPU、内存、通道、各类I/O接口之间相互连接的总线；</p></blockquote><ol><li><p><strong>寄存器之间数据传送</strong></p><p><code>比如把PC内容送至MAR</code>，实现传送操作的流程及控制信号为：</p><ul><li><p><code>(PC)→Bus</code>PCout有效，PC内容送总线（Bus为总线的意思）；</p></li><li><p><code>Bus→MAR</code>MARin有效，总线内容送MAR；</p></li></ul></li><li><p><strong>主存与CPU之间数据传送</strong></p><p><code>比如CPU从主存读取指令</code>，实现传送操作的流程及控制信号为：</p><ul><li><code>(PC)→Bus→MAR</code>PCout和MARin有效，现行指令地址传给MAR；</li><li><code>1→R </code>                            CU发出读命令（通过控制总线发出）；</li><li><code>MEM（MAR）→MDR</code>     MDRin有效；</li><li><code>MDR→Bus→IR </code>           MDRout和IRin有效，现行指令传给IR；</li></ul></li><li><p><strong>执行算术或逻辑运算</strong></p><p><code>比如一条加法指令</code>，微操作序列及控制信号为：</p><ul><li><p><code>Ad(IR)→Bus→MAR</code>MDRout和MARin有效；</p></li><li><p><code>1→R</code>CU发出读命令；</p></li><li><p><code>MEN(MAR)→数据线→MDR</code>MDRin有效；</p></li><li><p><code>MDR→Bus→Y</code>MDRout和Yin有效，操作数传给Y；</p></li><li><p><code>(ACC)+(Y)→Z</code>ACCout和ALUin有效，CU向ALU发送加命令；</p></li><li><p><code>Z→ACC</code>Zout和ACCin有效，结果传给ACC；</p></li></ul><blockquote><p>例题</p><p>如图所示的单总线结构，分析指令ADD（R0），R1的指令流程和控制信号；</p><p><img src="https://img.lishangcc.top//img/image-20220724100852572.png" alt="image-20220724100852572"></p><p><strong>取指周期</strong>：公共操作</p><table><thead><tr><th style="text-align:center">时序</th><th style="text-align:center">微操作</th><th style="text-align:center">有效控制信号</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">(PC)→MAR</td><td style="text-align:center">PCout，MARin</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">M(MAR)→MDR<br />(PC)+1→PC</td><td style="text-align:center">MemR，MARout，MDRinE</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">(MDR)→IR</td><td style="text-align:center">MDRout，IRin</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">指令译码</td><td style="text-align:center">-</td></tr></tbody></table><p><strong>间址周期</strong>：完成取数操作，被加数在主存中，加数已放在寄存器R1中；（题目中R0带括号，表示存的是一个地址，即采用间接寻址，被加数在其所指向的地址中，而R1不带括号，即加数直接存在寄存器R1中）</p><table><thead><tr><th style="text-align:center">时序</th><th style="text-align:center">微操作</th><th style="text-align:center">有效控制信号</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">(R0)→MAR</td><td style="text-align:center">R0out，MARin</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">M(MAR)→MDR</td><td style="text-align:center">MemR，MARout，MDRinE</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">(MDR)→Y<br /># Y为暂存寄存器</td><td style="text-align:center">MDRout，Yin</td></tr></tbody></table><p><strong>执行周期</strong>：最终结果放在主存中，即R0所指地址中；</p><table><thead><tr><th style="text-align:center">时序</th><th style="text-align:center">微操作</th><th style="text-align:center">有效控制信号</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">(R1)+(Y)→Z</td><td style="text-align:center">R1out，ALUin，CU向ALU发ADD控制信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">(Z)→MDR</td><td style="text-align:center">Zout，MDRin</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">(MDR)→M(MAR)</td><td style="text-align:center">MemW，MDRoutE，MARout</td></tr></tbody></table></blockquote></li></ol><h3 id="专用数据通路方式">专用数据通路方式</h3><h2 id="控制器设计">控制器设计</h2><h3 id="硬布线控制器">硬布线控制器</h3><p><img src="https://img.lishangcc.top//img/image-20220724111051638.png" alt="image-20220724111051638"></p><p>取指周期微操作时序安排</p><p>间址周期微操作时序安排</p><p>执行周期微操作时序安排</p><h3 id="微程序控制器">微程序控制器*</h3><p><code>微程序</code>设计思想：将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令；</p><p>这些微程序可以存放在一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的命令；</p><blockquote><p><code>程序</code>：由指令序列组成；</p><p><code>微程序</code>：由微指令序列组成，每一种指令对应一个微程序；</p><p>指令是对程序执行步骤的描述；</p><p>微指令是对指令执行步骤的描述；</p><p>指令是对微指令功能的封装；</p><p>微命令与微操作一一对应；</p><p>微指令中可能包含多个微命令；</p></blockquote><h4 id="微指令的设计">微指令的设计</h4><blockquote><p>探讨：①微指令的具体格式应该怎么设计？②如何根据微指令发出相应的微命令？</p></blockquote><ul><li><p><strong>水平型微指令</strong>*</p><p>一条微指令能定义多个可并行的微命令；</p><blockquote><p>优点：微程序短，执行速度快；</p><p>缺点：微指令长，编写微程序麻烦；</p></blockquote></li><li><p><strong>垂直型微指令</strong></p><p>一条微指令只能定义一个微命令，由微操作码字段规定具体功能；</p></li><li><p><strong>混合型微指令</strong></p></li></ul><h4 id="微指令的编码方式">微指令的编码方式</h4><h5 id="直接编码">直接编码</h5><p>控制字段中每一位代表一个微操作命令；</p><p><img src="https://img.lishangcc.top//img/image-20220725102750205.png" alt="image-20220725102750205"></p><blockquote><p>优点：简单、直观，执行速度快，操作并行性好；</p><p>缺点：微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控存容量极大；</p></blockquote><h5 id="字段直接编码">字段直接编码</h5><p>将微指令的控制字段分成若干段，把互斥性微命令组合在同一个字段中，把相容性微命令组合在不同字段中，每个字段独立编码，每种编码代表一个微命令，且各字段编码含义单独定义，与其他字段无关；</p><blockquote><p>微指令字段分段原则：</p><ol><li>互斥性微命令分在同一段内，相容性微命令分在不同段内；</li><li>每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性；</li><li>一般每个小段还要留出一个状态，表示本字段不发出任何微命令；<br>如：某字段长度为3位，最多只能表示7个互斥的微命令，通常留000表示不操作；</li></ol></blockquote><p><img src="https://img.lishangcc.top//img/image-20220725103700386.png" alt="image-20220725103700386"></p><blockquote><p>优点：可以缩短微指令字长；</p><p>缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢；</p></blockquote><blockquote><p>例题：某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用<code>字段直接编码法</code>，共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有多少位?</p><p>答：3+2+4+3+3=15位</p><p>（若采用直接编码发誓，则需要控制字段33位）</p></blockquote><h5 id="字段间编码">字段间编码</h5><p>一个字段的某些微命令需要另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，因此称为字段间编码，又称隐式编码；</p><h4 id="微程序控制单元的设计">微程序控制单元的设计</h4><p>设计步骤：</p><ol><li>分析每个阶段的微操作序列</li><li>写出对应机器指令的微操作命令及节拍</li><li>确定微指令格式</li><li>编写微指令码点</li></ol><h2 id="指令流水线">指令流水线</h2><blockquote><p>为什么引入流水线结构？</p><p>有哪些结构？</p><p>会产生什么问题？</p></blockquote><p>一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成，如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线；</p><h3 id="流水线的表示方法">流水线的表示方法</h3><p><strong>指令执行过程图</strong></p><p><img src="https://img.lishangcc.top//img/image-20220725114055994.png" alt="image-20220725114055994"></p><p><strong>时空图</strong>*</p><p><img src="https://img.lishangcc.top//img/image-20220725114203623.png" alt="image-20220725114203623"></p><blockquote><p>横坐标：时间，分割成长度相等的时间段T；</p><p>纵坐标：空间，表示当前指令所处的功能部件；</p></blockquote><h3 id="流水线的性能指标">流水线的性能指标</h3><p><code>吞吐率TP</code>：在单位时间内流水线所完成的任务数量，或是输出结构的数量；</p><blockquote><p>设任务数为n，处理完n个任务所用时间为Tk；</p><p>TP=n / TK；</p></blockquote><p><code>加速比S</code>：完成同一批任务，不使用流水线所用时间与使用流水线所用时间之比；</p><blockquote><p>设T0表示不使用流水线时的执行时间，即顺序执行所用时间，Tk表示使用流水线时的执行时间；</p><p>S=T0 / Tk；</p></blockquote><p><code>效率E</code>：流水线的设备利用率；</p><blockquote><p>时空图上，效率为：完成n个任务占用的时空区有效面积与n个任务所用时间与k个流水段所围成的时空区总面积之比；</p><p>E = n个任务占用的时空区有效面积 / n个任务所用时间与k个流水段所围成的时空区总面积 = T0 / (k*Tk)；</p><p><img src="https://img.lishangcc.top//img/image-20220725115310781.png" alt="image-20220725115310781"></p></blockquote><h3 id="流水线影响因素">流水线影响因素</h3><p><strong>结构相关（资源冲突）</strong></p><p>由于多条指令在同一时刻争用同一资源而形成的冲突；</p><blockquote><p>解决办法：</p><ol><li>后一相关指令暂停一周期；</li><li>资源重复配置：数据存储器+指令存储器；</li></ol></blockquote><p><strong>数据相关（数据冲突）</strong>*</p><p>在一个程序中，存在必须等前一条指令执行完成才能执行后一条指令的情况，这两条指令即为数据相关；</p><blockquote><p>解决办法：</p><ol><li>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行；可分为<code>硬件阻塞</code>和<code>软件插入“NOP”</code>两种方法；</li><li>数据旁路技术（转发机制）；</li><li>编译优化：通过编译器调整指令顺序来解决数据相关；</li></ol></blockquote><p><strong>控制相关（控制冲突）</strong></p><p>当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关；</p><p>（理解：当程序执行一条判断语句时，条件满足PC值发生改变，而在判断条件执行过程中，程序会继续顺序取指令，而结果又没有用到）</p><blockquote><p>解决办法：</p><ol><li>转移指令分支预测：简单预测（永远才true或false）、动态预测（根据历史情况动态调整）；</li><li>预取转移成功和不成功两个控制流方向上的目标指令；</li><li>加快和提前形成条件码；</li><li>提高转移方向的猜准率；（第一种的优化）</li></ol></blockquote><h3 id="五段式指令流水线">五段式指令流水线</h3><p>一条指令执行过程分为如下5个阶段：</p><ol><li>IF：取指</li><li>ID：译码&amp;取数</li><li>EX：执行</li><li>MEM：访存</li><li>WB：写回寄存器</li></ol><p><img src="https://img.lishangcc.top//img/image-20220725154525714.png" alt="image-20220725154525714"></p><p>流水线每一个功能段部件后面都有一个<code>缓冲寄存器</code>，或称为<code>锁存器</code>，作用是保存本流水段的执行结果，供下一流水段使用；</p><blockquote><p>考试中常见的五类指令：</p><p>运算类指令、LOAD指令、STORE指令、条件转移指令、无条件转移指令；</p><p>通常，RISC处理器只有<code>取数LOAD</code>和<code>存数STORE</code>指令才能访问主存；</p></blockquote><p><strong>运算类指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：取出操作数至ID段锁存器；</li><li>EX：运算，将结果存入EX段锁存器；</li><li>M：空段；</li><li>WB：将运算结果写回指定寄存器；</li></ol><table><thead><tr><th style="text-align:center">指令举例</th><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">加法指令（两个寄存器相加）</td><td style="text-align:center">ADD Rs，Rd</td><td style="text-align:center">(Rs)+(Rd)→Rd</td></tr><tr><td style="text-align:center">加法指令（寄存器与立即数相机）</td><td style="text-align:center">ADD #996，Rd</td><td style="text-align:center">996+(Rd)→Rd</td></tr><tr><td style="text-align:center">算术左移指令</td><td style="text-align:center">SHL Rd</td><td style="text-align:center">(Rd)&lt;&lt;&lt;2→Rd</td></tr></tbody></table><p><strong>取数LOAD指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：将基址寄存器的值放到锁存器A，将偏移量的值放到Imm；</li><li>EX：运算，得到有效地址；</li><li>M：从数据Cache中取数并放入锁存器；</li><li>WB：将取出的数写回寄存器；</li></ol><table><thead><tr><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">LOAD Rd，996(Rs)</td><td style="text-align:center">(996+(Rs))→Rd</td></tr><tr><td style="text-align:center">LOAD Rd，mem</td><td style="text-align:center">(mem)→Rd</td></tr></tbody></table><p><strong>存数STORE指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：将基址寄存器的值放到锁存器A，将偏移量的值放到Imm，将要存的数放到B；</li><li>EX：运算，得到有效地址，并将锁存器B的内容放到锁存器Store；</li><li>M：写入数据Cache；</li><li>WB：空段；</li></ol><table><thead><tr><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">STORE Rs，996(Rd)</td><td style="text-align:center">Rs→(996+(Rd))</td></tr><tr><td style="text-align:center">STORE Rs，mem</td><td style="text-align:center">Rs→(mem)</td></tr></tbody></table><p><strong>条件转移指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：进行比较的两个数放入锁存器A、B；偏移量放入Imm；</li><li>EX：运算，比较两个数；</li><li>M：将目标PC值写回PC；</li><li>WB：空段；</li></ol><table><thead><tr><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">beq Rs，Rt，#偏移量</td><td style="text-align:center">若(Rs)==(Rt)，则(PC)+指令字长+(偏移量×指令字长)→PC；否则(PC)+指令字长→PC；</td></tr><tr><td style="text-align:center">bne Rs，Rt，#偏移量</td><td style="text-align:center">若(Rs)!=(Rt)，则(PC)+指令字长+(偏移量×指令字长)→PC；否则(PC)+指令字长→PC；</td></tr></tbody></table><p><strong>无条件转移指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：偏移量放入Imm；</li><li>EX：将目标PC值写回PC；</li><li>M：空段；</li><li>WB：空段；</li></ol><table><thead><tr><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">jmp #偏移量</td><td style="text-align:center">(PC)+指令字长+(偏移量×指令字长)→PC；</td></tr></tbody></table><blockquote><p>例题：假设某指令流水线采用“按序发射，按序完成”方式，没有采用转发技术处理数据相关，并且同一寄存器的读和写操作不能在同一个时钟周期内进行。若高级语言程序中某赋值语句为x=a+b，x、a和b均为int型变量，它们的存储单元地址分别表示为[x]、[a]和[b]。该语句对应的指令序列及其在指令流中的执行过程如下图所示。</p><p><img src="https://img.lishangcc.top//img/image-20220725173148839.png" alt="image-20220725173148839"></p><p><img src="https://img.lishangcc.top//img/image-20220725173202613.png" alt="image-20220725173202613"></p><p><strong>分析这4条指令执行过程中I3的ID段和I4的IF段被阻塞的原因各是什么？</strong></p><p>答：①I3与I1和I2存在数据相关；②I4的IF段必须在I3进入ID段后才能开始，否则会覆盖IF段锁存器的内容；</p><p>记住：只有上一条指令进入ID段后，下一条指令才能开始IF段，否则会覆盖IF段锁存器的内容；</p></blockquote><h2 id="多处理器系统">多处理器系统</h2><p>基于指令流的数量和数据流的数量，将计算机体系结构分为SISD、SIMD、MISD和MIMD四类；常规单处理器属于SISD，常规多处理器属于MIMD；</p><p><strong>单指令流单数据流（SISD）结构</strong></p><p>SISD是传统的串行计算机结构，这种计算机通常仅包含一个处理器，一个存储器；处理器在一段时间内仅执行一条指令，按指令流规定的顺序串行执行指令流中的若干条指令；</p><p><strong>多指令多数据流（MIMD）结构</strong></p><p>同时执行多条指令分别处理多个不同的数据，MIMD分为<code>多计算机系统</code>和<code>多处理器系统</code>；</p><p><code>多计算机系统</code>中，每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，不能通过存取指令来访问不同节点的私有存储器，而要通过消息传递进行数据传送，也称<code>消息传递MIMD</code>；</p><p><code>多处理器系统</code>是共享存储多处理器（SMP）系统的简称，他具有共享的单一地址空间，通过存取指令访问系统中所有存储器，也称<code>共享存储MIMD</code>；</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章指令系统</title>
      <link href="/myblog/2022/07/12/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-12-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/myblog/2022/07/12/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-12-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="指令概念">指令概念</h2><h3 id="指令基本格式">指令基本格式</h3><p>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码，一条指令包括**操作码字段（OP）<strong>和</strong>地址码字段（A）**两部分，一条指令可能包含多个地址码，<strong>根据地址码数目不同</strong>，可以将指令分为零地址指令、一地址指令、二地址指令……</p><blockquote><p>理解一下：</p><p>操作码：用户要干什么；地址码：对谁进行操作；</p></blockquote><p><strong>零地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712165522481.png" alt="image-20220712165522481"></p><ol><li>不需要操作数，如空操作、停机、关中断等指令；</li><li>堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果可压回栈顶；</li></ol><p><strong>一地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712165859828.png" alt="image-20220712165859828"></p><ol><li><p>只需要操作数，如加1、减1、取反、求补等；</p><blockquote><p>指令含义：OP(A1)→A1；</p><p>完成一条指令需要3次访存：取指→读A1→写A1；</p></blockquote></li><li><p>需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC）；</p><blockquote><p>指令含义：(ACC)OP(A1)→ACC；</p><p>完成一条指令需要2次访存：取指→读A1；</p></blockquote><blockquote><p>注：A1指某个主存地址（类比C语言指针）；（A1）表示A1所指向的地址中的内容（指针所指位置的内容）。</p></blockquote></li></ol><p><strong>二地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712203945428.png" alt="image-20220712203945428"></p><p>常用于需要两个操作数的算术运算、逻辑运算相关指令；</p><blockquote><p>指令含义：（A1）OP（A2）→A1；</p><p>完成一条指令需要4次访存：取指→读A1→读A2→写A1；</p></blockquote><p><strong>三地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712204145875.png" alt="image-20220712204145875"></p><p>常用于需要两个操作数的算术运算、逻辑运算相关指令；</p><blockquote><p>指令含义：（A1）OP（A2）→A3</p><p>完成一条指令需要4次访存：取指→读A1→读A2→写A3；</p></blockquote><p><strong>四地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712204325040.png" alt="image-20220712204325040"></p><p>正常情况下：取指令之后PC+1，指向下一条指令；</p><p>四地址指令：执行指令后，将PC的值修改为A4所指地址（与前面不同的是PC不是简单的+1，而是可以跳着指向其他地址）；</p><blockquote><p>指令含义：（A1）OP（A2）→A3，A4=下一条将要执行指令的地址；</p><p>完成一条指令需要4次访存：取指→读A1→读A2→写A3；</p></blockquote><h3 id="指令分类">指令分类</h3><p><strong>按指令长度分类</strong></p><ul><li>定长指令字结构：指令系统中所有指令的长度都相等；</li><li>变长指令字结构：指令系统中各种指令的长度不等；</li></ul><blockquote><p>一些概念：</p><p>指令字长：一条指令的总长度；</p><p>机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（与ALU相关）；</p><p>存储字长：一个存储单元中的二进制代码位数（与MDR位数同）；</p><p><strong>指令字长会影响取指令所需时间</strong>，如：机器字长=存储字长=16bit，则存取一条双字长指令需要2次访存；</p></blockquote><p><strong>按操作码长度分类</strong></p><ul><li>定长操作码：指令系统中所有指令的操作码长度相同；</li><li>可变长（扩展）操作码：指令系统中各指令的操作码长度可变；</li></ul><p><strong>按操作类型分类</strong></p><ul><li>数据传送类：CPU、主存之间的数据传送；</li><li>运算类：算数逻辑操作、移位操作；</li><li>程序控制类：改变程序执行流；</li><li>输入输出类：CPU、IO设备之间的数据传送；</li></ul><h3 id="扩展操作码指令格式">扩展操作码指令格式</h3><blockquote><p>定长指令字结构+可变长操作码；</p><p>不同地址数的指令使用不同长度的操作码；</p></blockquote><p>在扩展操作码指令格式时，需注意：</p><ol><li>不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分相同；（类比哈夫曼树）</li><li>各指令的操作码一定不能重复；</li><li>通常情况下，使用频率较高的指令，分配较短的操作码；使用频率较低的指令，分配较长的操作码；</li></ol><p>例：设指令字长固定为16位，试设计一套指令系统满足：</p><ol><li>有15条三地址指令</li><li>有12条二地址指令</li><li>有62条一地址指令</li><li>有32条零地址指令</li></ol><p><img src="https://img.lishangcc.top//img/image-20220713203433455.png" alt="image-20220713203433455"></p><p>设地址长度为n，上一层留出m种状态，下一层可扩展出<strong>m×2^n</strong>种状态；</p><p><img src="https://img.lishangcc.top//img/image-20220713203911765.png" alt="image-20220713203911765"></p><h2 id="指令寻址">指令寻址</h2><p>指令地址：下一条欲执行指令的地址（由程序计数器PC给出），分为顺序寻址、跳跃寻址；</p><h2 id="数据寻址">数据寻址*</h2><p>数据寻址：确定<strong>本条指令</strong>的<strong>地址码指明的真实地址</strong>；</p><h3 id="直接寻址">直接寻址</h3><p>指令字中的形式地址A就是操作数的真实地址EA，即EA=A；</p><p><strong>指令执行过程</strong>：</p><ol><li>取指令，访存1次；</li><li>执行指令：访存1次；</li></ol><blockquote><p>优点：简单，指令执行阶段进访问一次主存，不需专门计算操作数的地址；</p><p>缺点：A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改；</p></blockquote><h3 id="间接寻址">间接寻址</h3><p>指令的地址字段给出的形式地址不是操作数的真实地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=（A）；</p><p><img src="https://img.lishangcc.top//img/image-20220713213733162.png" alt="image-20220713213733162"></p><blockquote><p>优点：可扩大寻址范围（有效地址EA的位数大于形式地址A的位数）；便于编址程序；</p><p>缺点：指令的执行阶段要多次访存（一次间址需要两次访存，多次寻址需根据存储字的最高位确定几次访存）；</p></blockquote><h3 id="寄存器寻址">寄存器寻址</h3><p>在指令字中直接给出操作数所在的寄存器编号，即EA=Ri，其操作数在由Ri所指的寄存器内；</p><p><img src="https://img.lishangcc.top//img/image-20220713214909570.png" alt="image-20220713214909570"></p><p><strong>指令执行过程</strong>：</p><ol><li>取指令：访存1次；</li><li>执行指令：访存0次；</li></ol><blockquote><p>优点：指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快，支持向量/矩阵运算；</p><p>缺点：寄存器价格昂贵，计算机中寄存器个数有限；</p></blockquote><h3 id="寄存器间接寻址">寄存器间接寻址</h3><p>寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=（Ri）；</p><p><img src="https://img.lishangcc.top//img/image-20220713215413969.png" alt="image-20220713215413969"></p><p><strong>指令执行过程</strong>：</p><ol><li>取指令：访存1次；</li><li>执行指令：访存1次；</li></ol><blockquote><p>特点：与一般间接寻址相比，速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）；</p></blockquote><h3 id="隐含寻址">隐含寻址</h3><p>不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址；</p><p><img src="https://img.lishangcc.top//img/image-20220713215714829.png" alt="image-20220713215714829"></p><blockquote><p>优点：有利于缩短指令字长；</p><p>缺点：需增加存储操作数或隐含地址的硬件；</p></blockquote><h3 id="立即寻址">立即寻址</h3><p>形式地址A就是操作数本身，又称为立即数，一般采用补码形式；</p><p><strong>指令执行过程</strong>：</p><ol><li>取指令：访存1次；</li><li>执行指令：访存0次；</li></ol><blockquote><p>优点：指令执行阶段不访问只存，指令执行时间最短；</p><p>缺点：A的位数限制了立即数的范围，如果A的位数为n，且立即数采用补码时，可表示数据的范围为：<img src="https://img.lishangcc.top//img/image-20220713220248342.png" alt="image-20220713220248342"></p></blockquote><p><img src="C:/Users/LS/AppData/Roaming/Typora/typora-user-images/image-20220713220329465.png" alt="image-20220713220329465"></p><h3 id="偏移寻址">偏移寻址</h3><ul><li>基址寻址：以程序的起始存放地址作为 “起点”；EA=(BR)+A</li><li>变址寻址：程序员自己决定从哪里作为 “起点”；EA=(IX)+A</li><li>相对寻址：以程序计数器PC所指地址作为 “起点”；EA=(PC)+A</li></ul><blockquote><p>区别在于偏移的起点不一样；</p></blockquote><h4 id="基址寻址">基址寻址</h4><p>将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=（BR）+A；</p><p><img src="https://img.lishangcc.top//img/image-20220718000025191.png" alt="image-20220718000025191"></p><h4 id="变址寻址">变址寻址</h4><p>有效地址EA等于 指令字中的形式地址A与变址寄存器IX的内容相加之和，即 EA=（IX）+A，其中IX可为变址寄存器（专用），也可用通用寄存器作为变址寄存器；</p><p>变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）；</p><blockquote><p>数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序；</p></blockquote><h4 id="相对地址">相对地址</h4><p>把程序计数器PC的内容加上指令格式的形式地址A而形成操作数的有效地址，即EA=（PC）+A，其中A是相对于PC所指地址的位移量，可正可负，补码表示；</p><p><img src="https://img.lishangcc.top//img/image-20220719203907752.png" alt="image-20220719203907752"></p><h3 id="堆栈寻址">堆栈寻址</h3><p>操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址；</p><p>堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）；</p><h3 id="总结">总结</h3><p><img src="https://img.lishangcc.top//img/image-20220719220113005.png" alt="image-20220719220113005"></p><h2 id="高级语言与机器级代码">高级语言与机器级代码</h2><blockquote><p>考法：</p><ol><li>给出某段简单程序的C语言、汇编语言、机器语言的表示，能结合C语言看懂汇编语言关键语句（常见指令、选择结构、循环结构、函数调用）；</li><li>汇编语言、机器语言一一对应，要能结合汇编语言分析机器语言指令的格式、寻址方式；</li></ol></blockquote><h3 id="X86汇编语言指令">X86汇编语言指令</h3><p>指令的作用：1.改变程序执行流；2.处理数据；</p><p>指令的格式：操作码 + 地址码；</p><p><img src="https://img.lishangcc.top//img/image-20220720000851416.png" alt="image-20220720000851416"></p><p><strong>mov指令</strong></p><p>mov 目的操作数d，源操作数s</p><p>mov指令功能：将源操作数s复制到目的操作数d所指的位置；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax, ebx#将寄存器ebx的值复制到寄存器eax</span><br><span class="line">mov eax, 5#将立即数5复制到寄存器eax</span><br><span class="line">mov eax，dword ptr[af996h]#将内存地址af996h所指的32bit值复制到寄存器eax</span><br><span class="line">mov byte ptr[af996h]，5#将立即数5复制到内存地址af996h所指的一字节中</span><br></pre></td></tr></table></figure><blockquote><p><strong>1.如何指明内存的读写长度：</strong></p><p>dword ptr——双字，32bit<br>word ptr——单字，16bit<br>byte ptr——字节，8bit</p><p><strong>2.X86架构CPU有哪些寄存器：</strong></p><p><img src="https://img.lishangcc.top//img/image-20220719221038865.png" alt="image-20220719221038865"></p></blockquote><h3 id="循环语句的机器表示">循环语句的机器表示</h3><h2 id="CISC和RISC">CISC和RISC</h2><p><strong>CISC：Complex Instruction Set Computer</strong></p><p>一条指令完成一个复杂的基本功能；</p><p>代表：X86架构，主要用于笔记本、台式机等；</p><p>理解：程序+各种库和函数；</p><p><strong>RISC：Reduced Instruction Set Computer</strong></p><p>一条指令完成一个基本动作，多条指令组合完成一个复杂的基本功能；</p><p>代表：ARM架构，主要用于手机、平板；</p><p>理解：原生程序；</p><p><img src="https://img.lishangcc.top//img/image-20220722001624790.png" alt="image-20220722001624790"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章存储系统</title>
      <link href="/myblog/2022/07/04/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-04-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/myblog/2022/07/04/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-04-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><h3 id="存储器的层次化结构">存储器的层次化结构</h3><p><img src="https://img.lishangcc.top//img/image-20220704200541476.png" alt="image-20220704200541476"></p><p><img src="https://img.lishangcc.top//img/image-20220704200853790.png" alt="image-20220704200853790"></p><ul><li>辅存中的数据要调入主存后才能被CPU访问；</li><li><strong>主存—辅存</strong>：实现虚拟存储系统，解决主存容量不够的问题；</li><li><strong>Cache—主存</strong>：解决主存与CPU速度不匹配的问题；</li></ul><h3 id="存储器的分类">存储器的分类</h3><p><strong>按层次</strong></p><ul><li><strong>高速缓存</strong>（Cache）：可直接被CPU读写；</li><li><strong>主存储器</strong>（主存）：可直接被CPU读写；</li><li><strong>辅助存储器</strong>（辅存、外存）</li></ul><p><strong>按存储介质</strong></p><ul><li><strong>半导体存储器</strong>：主存、Cache；</li><li><strong>磁表面存储器</strong>：磁盘、磁带；</li><li><strong>光存储器</strong>：光盘；</li></ul><p><strong>按存取方式</strong></p><ul><li><strong>随机存储存储器（RAM）</strong>：读写任何一个存储单元所需时间都相同，与存储单元所在的物理位置无关；（如：内存条）</li><li><strong>顺序存储存储器（SAM）</strong>：读写一个存储单元所需时间取决于存储单元所在的物理位置；（如：磁带）</li><li><strong>直接存储存储器（DAM）</strong>：既有随机存取特性，也有顺序存取特性；先直接选取信息所在区域，然后按顺序方式存取；（如：机械硬盘）</li></ul><p><strong>按信息的可更改性</strong></p><ul><li><strong>读写存储器</strong>：即可读，也可写；（如：磁盘、内存、Cache）</li><li><strong>只读存储器（ROM）</strong>：只能读，不能写；（如：实体音乐专辑、电影光碟）（事实上现在很多ROM也可以多次读写，只是比较麻烦）</li></ul><p><strong>按信息的可保存性</strong></p><ul><li><strong>易失性存储器</strong>：断电后，存储信息消失的存储器；（主存、Cache）</li><li><strong>非易失性存储器</strong>：断电后，信息依然保持的存储器；（磁盘、光盘）</li><li><strong>破坏性读出</strong>：信息读出后，原存储信息被破坏；（如DRAM芯片）</li><li><strong>非破坏性读出</strong>：与上相反；（如SRAM芯片、磁盘、光盘）</li></ul><h3 id="存储器的性能指标">存储器的性能指标</h3><ol><li>存储容量：存储字数×字长（如1M×8位）（主存储器中的MDR反映存储字长）</li><li>单位成本：每位价格=总成本/中容量；</li><li>存储速度：数据传输率=数据的宽度/存储周期；（数据的宽度即存储字长）</li></ol><blockquote><p><strong>存取时间</strong>（Ta）：存储时间是指从启动一次存储器操作到完成该操作所经历的时间；分为读出时间和写入时间；</p><p><strong>存取周期</strong>（Tm）：又称<strong>读写周期</strong>或<strong>访问周期</strong>，他是指存储器进行一次完整的读写操作所需的全部时间，即<strong>连续两次独立地访问存储操作之间所需的最小时间间隔</strong>；</p><p><strong>主存带宽</strong>（Bm）：又称<strong>数据传输率</strong>，表示每秒从主存进出信息的最大数量，单位：字/秒、字节/秒（B/s）、位/秒（b/s）；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220704215754963.png" alt="image-20220704215754963"></p><h2 id="主存储器的基本组成">主存储器的基本组成</h2><blockquote><ul><li>存储体：也称存储矩阵，由多个存储单元组成，存储单元由存储元组成；</li><li>MAR：n位地址对应2^n个存储单元；</li><li>MDR</li></ul></blockquote><p><img src="https://img.lishangcc.top//img/image-20220705202715405.png" alt="image-20220705202715405"></p><p>总容量=存储单元个数×存储字长</p><p>片选线：一个内存条内可能含有多块存储芯片，由片选片选择哪块芯片；</p><p>金属引脚：地址线+数据线+片选线+读/写控制线；</p><h3 id="SRAM和DRAM">SRAM和DRAM</h3><blockquote><ul><li>DRAM（动态RAM）：用于主存；</li><li>SRAM（静态RAM）：用于Cache；</li></ul></blockquote><table><thead><tr><th style="text-align:center">类型特点</th><th style="text-align:center">SRAM</th><th style="text-align:center">DRAM</th></tr></thead><tbody><tr><td style="text-align:center">存储信息</td><td style="text-align:center">触发器</td><td style="text-align:center">电容</td></tr><tr><td style="text-align:center">破坏性读出</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">读出后是否需要重写</td><td style="text-align:center">不用</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">运行速度</td><td style="text-align:center">快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">集成度</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">发热量</td><td style="text-align:center">大</td><td style="text-align:center">小</td></tr><tr><td style="text-align:center">存储成本</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">易失/非易失性存储器</td><td style="text-align:center">易失</td><td style="text-align:center">易失</td></tr><tr><td style="text-align:center">是否需要刷新</td><td style="text-align:center">不需要（只要不断电，触发器状态就不会改变）</td><td style="text-align:center">需要（电容内的电荷一般只能维持2ms，因此需要刷新）</td></tr><tr><td style="text-align:center">送行列地址</td><td style="text-align:center">同时送</td><td style="text-align:center">分两次送</td></tr></tbody></table><h4 id="DRAM的刷新">DRAM的刷新</h4><p><strong>刷新周期</strong>：一般为2ms；</p><p><strong>每次刷新多少存储单元</strong>：以行为单位，每次刷新一行存储单元；</p><p><strong>存储器的简单模型</strong>（仅用行地址）：会产生有<strong>2^n</strong>根选通线；</p><p><strong>存储器的优化模型</strong>（用行列地址）：一半行地址，一半列地址；会产生**2×2^(n/2)**根选通线；</p><p><strong>如何刷新</strong>：有硬件支持，读出一行的信息后重新写入，占用一个存取周期；</p><p><strong>什么时候刷新</strong>：</p><blockquote><p>假设DRAM内部结构排列成128×128的形式，存取周期0.5us（微秒），2ms内共 2ms/0.5us=4000个周期；</p></blockquote><p>有以下三种思路，其中第三种好；</p><p><img src="https://img.lishangcc.top//img/image-20220705205604290.png" alt="image-20220705205604290"></p><h3 id="只读存储器ROM">只读存储器ROM</h3><blockquote><p>非易失性，断电后数据不会丢失，通常有以下5种，MROM、PROM、EPROM、闪存、SSD；</p></blockquote><p><strong>MROM——掩膜式只读存储器</strong>：由厂家直接写入，后期不可修改；</p><p>PROM——可编程只读存储器：用户可用专门的写入器写入信息，但也只可以写一次；</p><p><strong>EPROM——可擦除可编程只读存储器</strong>：允许用户写入信息，之后可用某种方法擦除数据，可进行多次重写；</p><p><strong>Flash Memory——闪存</strong>：如：U盘、SD卡，断电后也可保存信息，可多次擦除和重写；<br>注意：闪存的写速度要比读速度慢；</p><p><strong>SSD——固态硬盘</strong>：</p><p>由 <strong>控制单元</strong> + <strong>存储单元</strong> （Flash芯片）构成，与闪存的核心区别在于控制单元不一样，但存储介质都类似；</p><h3 id="主存储器与CPU连接">主存储器与CPU连接</h3><p>现在的计算机主要采用以下模式：</p><p><img src="https://img.lishangcc.top//img/image-20220705211324114.png" alt="image-20220705211324114"></p><h4 id="增加主存的存储字长——位扩展">增加主存的存储字长——位扩展</h4><p>主存的位数未用满CPU提供的接口，即MDR；</p><p><img src="https://img.lishangcc.top//img/image-20220705220444207.png" alt="image-20220705220444207"></p><h4 id="增加主存的存储字数——字扩展">增加主存的存储字数——字扩展</h4><p>主存的地址数未用满CPU提供的接口，即MAR；</p><p><img src="https://img.lishangcc.top//img/image-20220705215116296.png" alt="image-20220705215116296"></p><p><strong>线选法</strong>：如上图所示，A14和A13只能为01或10，不能为00或11，因此n条线只有n个选片信号；</p><p><img src="https://img.lishangcc.top//img/image-20220705215001799.png" alt="image-20220705215001799"></p><p><strong>译码片选法</strong>：n条线，2^n个选片信号；（如：1—2译码器（直接用一个非门即可）、2—4译码器、3—8译码器）</p><h4 id="主存容量扩展——字位同时扩展">主存容量扩展——字位同时扩展</h4><p><img src="https://img.lishangcc.top//img/image-20220705215604248.png" alt="image-20220705215604248"></p><p>如上图所示：16K×4位→64K×8位；</p><h2 id="双端口RAM和多模块存储器">双端口RAM和多模块存储器</h2><h3 id="双端口RAM">双端口RAM</h3><p><img src="https://img.lishangcc.top//img/image-20220706210343131.png" alt="image-20220706210343131"></p><blockquote><p>作用：优化多核CPU访问同一根内存条的速度；</p></blockquote><p>两个端口对同一主存的操作有4种情况，其中只有前2种可行（类似于操作系统中 “读者-写者问题” ）：</p><ul><li>两个端口同时对不同的地址单元存取数据；</li><li>两个端口同时对同一地址单元读出数据；</li><li>两个端口同时对同一地址单元写入数据；（写入错误）</li><li>两个端口同时对同一地址单元，一个写入，，一个读出；（读出错误）</li></ul><h3 id="多体并行存储器">多体并行存储器</h3><p>特点：每个模块都有相同的容量和存取速度；各模块都有独立的读写控制电路、地址寄存器和数据寄存器，他们既能并行工作，又能交叉工作；</p><p><strong>高位交叉编址的多体存储器</strong>：地址编号竖着编；</p><p><img src="https://img.lishangcc.top//img/image-20220706212435663.png" alt="image-20220706212435663"></p><p><strong>低位交叉编址的多体存储器</strong>：地址编号横着编；</p><p><img src="https://img.lishangcc.top//img/image-20220706212518149.png" alt="image-20220706212518149"></p><blockquote><p>例：假设每个存储体存取周期为T，存取时间为r，T=4r，若连续访问00000,00001,00010,00011,00100；</p><p><strong>高位交叉编址</strong>耗时如图所示：</p><p><img src="https://img.lishangcc.top//img/image-20220706212913484.png" alt="image-20220706212913484"></p><p>因为在同一存储体内，所以需要等一次存取之后需要等其恢复了才能进行下一次存取；<br>所以其耗时为5T；（若连续取n个存储字，耗时nT）</p><p><strong>低位交叉编址</strong>耗时如图所示：</p><p><img src="https://img.lishangcc.top//img/image-20220706213741018.png" alt="image-20220706213741018"></p><p>因为连续的存储字存储在不同的存储体中，所以在第一个存储体中取完数据后，其恢复期间便可向下一个存储体中的存储单元取数据；<br>耗时T+4r=2T；（连续取n个存储字，耗时T+（n-1）r）</p></blockquote><p>这种低位交叉编址应该取几个&quot;体&quot;呢？（两种说法，但结果一样）</p><blockquote><ol><li>存取周期为T，<strong>存取时间</strong>为r，为了使其工作不间断，应保证模块数 <strong>m&gt;=T/r</strong>；</li><li>存取周期为T，<strong>总线传输周期</strong>为r，为了使其工作不间断，应保证模块数 <strong>m&gt;=T/r</strong>；</li></ol></blockquote><h3 id="单体多字存储器">单体多字存储器</h3><p>相当于把上述多个体合成一整个，每次只能同时取m个字（一取取一整行），不能单独取其中某个字，这种方式灵活性比较差。</p><h2 id="磁盘存储器">磁盘存储器</h2><h3 id="磁盘设备组成">磁盘设备组成</h3><ol><li><p>存储区域</p><p>一块硬盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分若干个扇区（也称块），扇区是磁盘读写的最小单位，</p><p><img src="https://img.lishangcc.top//img/image-20220706222339850.png" alt="image-20220706222339850"></p></li><li><p>硬盘存储器</p><p>硬盘存储器有磁盘驱动器、磁盘控制器和盘片组成；</p><p>磁盘驱动器：核心部件是磁头组件和盘片组件；</p><p>磁盘控制器：是硬盘存储器和主机的接口；</p></li></ol><h3 id="磁盘的性能指标">磁盘的性能指标*</h3><ol><li><p><strong>磁盘的容量</strong>：一个磁盘所能存储的字节总数；</p></li><li><p><strong>记录密度</strong>：记录密度是指盘片单位面积上记录的二进制的信息量，通常以<strong>道密度</strong>、<strong>位密度</strong>和<strong>面密度</strong>表示；</p><blockquote><p>道密度：沿磁盘半径方向上单位长度的磁道数；</p><p>位密度：磁道单位长度上能记录的二进制代码位数；</p><p>面密度：位密度和道密度的乘积；</p><p>注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息量越多，故每个磁道的位密度都不同，越靠内侧的磁道位密度越大；</p></blockquote></li><li><p><strong>平均存取时间（常考）</strong>：</p><p>平均存取时间=寻道时间（磁头移动到目的磁道）+旋转延迟时间（磁头定位到所在扇区）+传输时间（传输数据所花费的时间）；</p><p><img src="https://img.lishangcc.top//img/image-20220707205658498.png" alt="image-20220707205658498"></p><blockquote><p>有的可能还要求加上磁盘控制器延迟时间；</p></blockquote></li><li><p><strong>数据传输率</strong>：磁盘存储器在单位时间内向主机传送数据的字节数；</p><blockquote><p>假设磁盘转数为r（转/秒），每条磁道容量为N个字节，则数据传输率为D=rN；</p></blockquote></li></ol><h3 id="磁盘地址">磁盘地址*</h3><p><img src="https://img.lishangcc.top//img/image-20220707210320188.png" alt="image-20220707210320188"></p><blockquote><p>若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码；</p><p>2bit驱动器号，8bit磁道号，4bit盘面号，4bit扇区号；</p></blockquote><h3 id="硬盘的工作工程">硬盘的工作工程</h3><p>主要操作有<strong>寻址</strong>、<strong>读盘</strong>、<strong>写盘</strong>，每个操作对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字；</p><p>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据；</p><h3 id="磁盘阵列（RAID）">磁盘阵列（RAID）*</h3><p>将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性；</p><p>RAID有以下分级，编号越大越可靠；</p><ul><li><p>RAID0：无冗余和无校验的磁盘阵列；</p><blockquote><p>RAID0把连续多个数据块交替存放在不同物理磁盘扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但<strong>RAID0没有容错能力</strong>；</p></blockquote></li><li><p>RAID1：镜像磁盘阵列；</p><blockquote><p>RAID1是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可从另一磁盘中读取数据；而两个磁盘当一个磁盘使用，意味着<strong>容量减少一半</strong>；</p></blockquote></li><li><p>RAID2：采用纠错的海明码的磁盘阵列；</p></li><li><p>RAID3：位交叉奇偶校验的磁盘阵列；</p></li><li><p>RAID4：块交叉奇偶校验的磁盘阵列；</p></li><li><p>RAID5：无独立校验的奇偶校验磁盘阵列；</p></li></ul><h2 id="固态硬盘SSD">固态硬盘SSD</h2><p><strong>固态硬盘的结构</strong></p><p><img src="https://img.lishangcc.top//img/image-20220707220032183.png" alt="image-20220707220032183"></p><p>块大小：16KB—512KB，页大小：512B—4KB；</p><p><img src="https://img.lishangcc.top//img/image-20220707215832601.png" alt="image-20220707215832601"></p><h2 id="Cache基本概念">Cache基本概念</h2><h3 id="局部性原理">局部性原理</h3><p><strong>空间局部性</strong>：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的；（如：数组元素、顺序执行的指令代码）</p><p><strong>时间局部性</strong>：在最近的未来要用到的信息，很可能是现在正在使用的信息；（循环结构的指令代码）</p><p>基础局部性原理，可以吧CPU目前访问的地址周围的部分数据放到Cache中。</p><blockquote><p>如何界定局部性原理中的“周围”呢？</p><p>将主存的存储空间分块，如：每1KB为一块；主存与Cache之间以“块”为单位进行数据交换；</p><p><img src="https://img.lishangcc.top//img/image-20220708213012930.png" alt="image-20220708213012930"></p></blockquote><h3 id="性能分析">性能分析</h3><p><img src="https://img.lishangcc.top//img/image-20220708205052300.png" alt="image-20220708205052300"></p><p>设tc为访问一次Cache所需时间，tm为访问一次主存所需时间；</p><p><strong>命中率H</strong>：CPU欲访问的信息已在Cache中的比率；</p><p><strong>缺失率</strong>：M=1-H；</p><p><strong>系统的平均访问时间</strong>：</p><p>1.先访问Cache，若Cache未命中再访问主存<img src="https://img.lishangcc.top//img/image-20220708205511524.png" alt="image-20220708205511524"></p><p>2.同时访问Cache和主存，若Cache命中则立即停止访问主存<img src="https://img.lishangcc.top//img/image-20220708205825593.png" alt="image-20220708205825593"></p><blockquote><p>例：假设Cache的速度是主存的5倍，且Cache的命中率为95%，则采用Cache后，存储器性能提高多少？</p><p>解：设Cache的存取周期为t，则主存的存取周期为5t；<br><strong>若Cache和主存同时访问</strong>，命中时访问时间为t，未命中时访问时间为5t；<br>平均访问时间：0.95×t+0.05×5t=1.2t；<br>性能提升：5t/1.2t=4.17倍；</p><p><strong>若先访问Cache再访问主存</strong>，命中时访问时间为t，未命中时访问时间为t+5t；<br>平均访问时间：0.95×t+0.05×6t=1.25t；<br>性能提升：5t/1.25t=4倍；</p></blockquote><h3 id="Cache与主存的映射方式">Cache与主存的映射方式</h3><blockquote><p>解决：如何区分Cache与主存的数据块的对应关系。</p></blockquote><blockquote><p>假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B；</p></blockquote><h4 id="全相联映射">全相联映射</h4><p>主存块可以放在Cache的任意位置；</p><p><img src="https://img.lishangcc.top//img/image-20220712114033399.png" alt="image-20220712114033399"></p><p><img src="https://img.lishangcc.top//img/image-20220712113050720.png" alt="image-20220712113050720"></p><p>主存地址共28位，其中主存块号22位，块内地址6位；</p><p>若CPU访问主存地址1…1101 001110：</p><ul><li>主存地址的前22位，对比Cache中所有块的标记；</li><li>若标记匹配且有效位为1，则Cache命中，访问块内地址为001110单元；</li><li>若未命中或有效位为0，则正常访问主存；</li></ul><blockquote><p>优点：Cache存储空间利用充分，命中率高；</p><p>缺点：查找标记最慢，有可能需要对比所有行的标记；</p></blockquote><h4 id="直接映射">直接映射</h4><p>每个主存块只能放到一个特定的位置；</p><p><strong>Cache块号=主存块号%Cache总块数</strong>；</p><p><img src="https://img.lishangcc.top//img/image-20220712115149596.png" alt="image-20220712115149596"></p><p>与上题一样，22位主存块号（其中19位标记，3位行号），6位块内地址；</p><p>（题目中Cache总块数为8，所以主存块号%2^3相当于留下主存块号后三位二进制数）</p><p>若CPU访问主存地址0…01000 001110：</p><ul><li>根据主存块号的后3位确定Cache行；</li><li>若主存块号的前19位与Cache标记匹配且有效位为1，则Cache命中，访问块内地址为001110的单元；</li><li>若为命中或有效位为0，则正常访问主存；</li></ul><blockquote><p>优点：对于任意一个地址，只需对比一个标记，速度最快；</p><p>缺点：Cache存储空间利用不充分，命中率低；</p></blockquote><h4 id="组相联映射">组相联映射</h4><p>Cache块分为若干组，每个主存块可放到特定分组中的任意一个位置；</p><p><strong>所属分组=主存块号%分组数</strong>；</p><p><img src="https://img.lishangcc.top//img/image-20220712142106447.png" alt="image-20220712142106447"></p><p>22位主存块号（20位标记，2位组号），6位块内地址；</p><p>CPU访问主存地址1…1101 001110：</p><ul><li>根据主存块号的后2位，确定所属分组号；</li><li>若主存块号的前20位与分组内的某个标记匹配，且有效位为1，则Cache命中，访问块内地址001110的单元；</li><li>若未命中或有效位为0，则正常访问主存；</li></ul><blockquote><p>优点：另外两种方式的折中，<strong>综合效果较好</strong>；</p><p>术语：n路组相联映射——每n个Cache行为一组；</p></blockquote><h3 id="Cache替换算法">Cache替换算法</h3><blockquote><p>解决：如果Cache满了怎么办？</p></blockquote><ul><li><strong>全相联映射</strong>：Cache完全满了才需要替换，需要在全局中选择替换哪一块；</li><li><strong>直接映射（无需考虑替换算法）</strong>：如果对应位置非空，则毫无选择地直接替换；</li><li><strong>组相联映射</strong>：分组内满了才需要替换，需要在分组内选择替换哪一块；</li></ul><h4 id="随机算法（RAND）">随机算法（RAND）</h4><p>若Cache已满，则随机选择一块替换；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p><img src="https://img.lishangcc.top//img/image-20220712142841936.png" alt="image-20220712142841936"></p><p>特点：实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定；</p></blockquote><h4 id="先进先出算法（FIFO）">先进先出算法（FIFO）</h4><p>若Cache已满，则替换最先被调入Cache的块；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p><img src="https://img.lishangcc.top//img/image-20220712143022549.png" alt="image-20220712143022549"></p><p>特点：也是实现简单，但依然没考虑局部性原理，最先被调入Cache的块也有可能是被频繁访问的，而且可能出现抖动现象；</p></blockquote><blockquote><p><strong>抖动现象</strong>：频繁的换入换出现象（刚被替换的块很快又被调入）；</p></blockquote><h4 id="近期最少使用（LRU）">近期最少使用（LRU）*</h4><p>为每一个Cache块设置一个计数器，用于记录每个Cache块已经有多久没被访问了，当Cache满后，<strong>替换计数器最大的</strong>；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p>步骤：</p><ol><li>命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变；</li><li>未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1；</li><li>未命中且无空闲行时，计数值最大的信息块被淘汰，新装行的块的计数器置0，其余全加1；</li></ol><p><img src="https://img.lishangcc.top//img/image-20220712143554578.png" alt="image-20220712143554578"></p><p>（Cache块的总数为2^n，则计数器只需n位）</p><p>特点：基于局部性原理，LRU算法的实际运行效果优秀，Cache命中率高；若被频繁访问的主存块数量 &gt; Cache行的数量，则可能发生抖动现象；</p></blockquote><h4 id="最不经常使用（LFU）">最不经常使用（LFU）</h4><p>为每一个Cache块设置一个计数器，用于记录每个Cache块被访问过几次，当Cache满后，<strong>替换计数器最小的</strong>；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p>步骤：<br>新调入的块计数器=0，之后每访问一次计数器+1，需要替换时，选择计数器最小的一行；</p><p><img src="https://img.lishangcc.top//img/image-20220712144015714.png" alt="image-20220712144015714"></p><p>特点：曾经被经常访问的主存块在未来不一定会用到，并没有很好的遵循局部性原理，因此实际效果不如LRU；</p></blockquote><h3 id="Cache写策略">Cache写策略</h3><blockquote><p>解决：CPU如果修改了Cache中的数据副本，如何确保主存中数据母本的一致性？</p></blockquote><h4 id="写命中">写命中</h4><p><strong>写回法</strong>：当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存；</p><blockquote><p>减少了访存次数，但存在数据不一致的隐患；</p></blockquote><p><strong>全写法</strong>：当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲；</p><blockquote><p>访存次数增加，速度变慢，但更能保证数据一致性；</p><p>使用写缓存，CPU写的速度很快，若写操作不频繁，则效果很好；若写操作频繁，则可能因为写缓存饱和而发生阻塞；</p></blockquote><h4 id="写不命中">写不命中</h4><p><strong>写分配法</strong>：当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改，通常<strong>搭配写回法使用</strong>；</p><p><strong>非写分配法</strong>：当CPU对Cache写不命中时，只写入内存，不调入Cache，通常<strong>搭配写全法使用</strong>；</p><blockquote><p>多级Cache</p><p>现代计算机通常采用多级Cache结构，各级Cache之间通常采用“全写法+非写分配法”，Cache和主存之间通常采用“写回法+写分配法”；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法</title>
      <link href="/myblog/2022/03/15/2022-03-15-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/myblog/2022/03/15/2022-03-15-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Java</button></li><li class="tab"><button type="button" data-href="#test-3">C</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/myblog/2022/03/02/hello-world/"/>
      <url>/myblog/2022/03/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
