<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第六章 应用层</title>
      <link href="/myblog/2022/09/02/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2022-09-02-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/myblog/2022/09/02/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2022-09-02-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="应用层概述">应用层概述</h2><p>应用层对应用程序的通信提供服务；</p><p><strong>应用层功能</strong></p><ul><li>文件传输、访问和管理：FTP</li><li>电子邮件：SMTP、POP3</li><li>虚拟终端：HTTP</li><li>查询服务和远程作业登录：DNS</li></ul><p><strong>网络应用模型</strong></p><ul><li><p><strong>C/S模型（客服/服务器）</strong></p><p>应用：Web、FTP、远程登陆、电子邮件</p><blockquote><p><img src="https://img.lishangcc.top//img/image-20220902174732216.png" alt="image-20220902174732216"></p><p><strong>服务器：提供计算服务的设备；</strong></p><p>①永久提供服务（不间断，一直有效）</p><p>②永久性访问地址/域名（地址不变）</p><p><strong>客户机：请求计算服务的主机；</strong></p><p>①使用服务器提供的服务</p><p>②间歇性接入网络</p><p>③可能使用动态IP地址（地址可能会变）</p><p>④不与其他客户机直接通信（客户机与服务器通信，服务器再与目的主机通信）</p></blockquote></li><li><p><strong>P2P模型</strong></p><blockquote><p><img src="https://img.lishangcc.top//img/image-20220902174821765.png" alt="image-20220902174821765"></p><p>1.不存在永远在线的服务器（C/S服务器永远有效）</p><p>2.每个主机既可以提供服务，也可以请求服务（C/S客户机只能请求服务）</p><p>3.任意端系统/节点之间可以直接通信（C/S客户机和服务器直接通信，客户机间不能直接通信）</p><p>4.节点间接性接入网络（C/S同）</p><p>5.可能使用动态IP地址（C/S同）</p><p>6.可扩展性好（大量主机涌入时，还能服务。但C/S只能接收一定量主机）</p><p>7.健壮性强（单个结点失效不影响其他结点。但C/S服务器坏了全部瘫痪）</p></blockquote></li></ul><h2 id="域名解析系统DNS">域名解析系统DNS</h2><p><strong>域名</strong></p><p><img src="https://img.lishangcc.top//img/image-20220902213253590.png" alt="image-20220902213253590"></p><p><strong>域名服务器</strong></p><ol><li><code>根域名服务器</code>：最高层次的域名服务器，知道所有顶级域名服务器的及其对应的IP地址；</li><li><code>顶级域名服务器</code>：管理在该顶级域名服务器注册的所有二级域名；</li><li><code>权限域名服务器</code>：负责一个区的域名服务器。（例如：abc.com和y.abc.com属于com顶级域名服务器的两个不同的区，两者等级相等，每个权限域名服务器只能负责一个区，因此，需要需要两个权限域名服务器）；</li><li><code>本地域名服务器</code>：当主机发出DNS查询请求时，将查询报文发送给本地域名服务器；</li></ol><p><strong>递归查询（比较少用）</strong></p><p><img src="https://img.lishangcc.top//img/image-20220902213523445.png" alt="image-20220902213523445"></p><p><strong>递归与迭代结合方式</strong></p><p><img src="https://img.lishangcc.top//img/image-20220902213547067.png" alt="image-20220902213547067"></p><h2 id="文件传输协议FTP">文件传输协议FTP</h2><ul><li><p>FTP是基于C/S的协议；</p></li><li><p>使用TCP实现可靠传输；</p></li><li><p>FTP分为一个主进程和若干个从属进程；</p><blockquote><p>主进程：负责接收新的请求，为新请求分配相应的从属进程处理；</p><p>从属进程：处理单个请求，处理完之后等待接收下一个请求；</p></blockquote></li><li><p>控制连接：传送请求，在整个会话期间内保持开启状态，端口号21；</p></li><li><p>数据连接：传送请求，收到传输请求后创建，传输完毕后关闭，端口号20（仅保持一会儿）；</p><blockquote><p>数据连接的端口号并不一定是20：</p><p>主动传输，端口号20；</p><p>被动传输，端口号由主机和服务器协商；</p></blockquote></li><li><p>FTP传输模式：①文本模式；②二进制模式；</p></li></ul><h2 id="电子邮件">电子邮件</h2><p><img src="https://img.lishangcc.top//img/image-20220902215928836.png" alt="image-20220902215928836"></p><ul><li>用户代理：电子邮件客户端软件（如：Outlook）；</li><li>邮件服务器：发送和接收邮件；</li><li>协议：发送邮件——SMTP；接收邮件——POP3、IMAP；</li></ul><h3 id="SMTP和MIME">SMTP和MIME</h3><p><strong>SMTP</strong></p><ul><li><p>规定两个SMTP进程之间如何交换信息</p></li><li><p>SMTP客户：发送邮件的SMTP。包括发送方和发送方服务器</p></li><li><p>SMTP服务器：接收邮件的进程</p></li><li><p>TCP连接，端口号25，基于C/S</p></li><li><p>三个阶段：连接建立→邮件传送→连接释放</p></li></ul><p><img src="https://img.lishangcc.top//img/image-20220902220939169.png" alt="image-20220902220939169"></p><p><strong>MIME</strong><br>使电子邮件可以支持多种格式（声音、图像和不同语言）的传输；</p><h3 id="POP3、IMAP和基于万维网">POP3、IMAP和基于万维网</h3><p><strong>POP3</strong><br>TCP连接，端口号110，基于C/S；</p><p>两种工作方式：</p><p>①下载并删除：邮件一旦读取，就从邮件服务器删除；</p><p>②下载并保留：邮件读取后，还能保存在邮件服务器；</p><p><strong>IMAP</strong><br>允许用户仅获取邮件的首部（摘要、邮件发送方）；</p><p>允许用户在不同地方使用不同计算机处理邮件；</p><p><strong>基于万维网</strong><br>用户代理和邮件服务器之间的协议改为采用HTTP，但是邮件服务器之间的协议仍是SMTP；</p><h2 id="万维网和HTTP协议">万维网和HTTP协议</h2><p>万维网WWW：一个大规模、联机式的信息存储所/资料空间，是无数个网络站点和网页的集合；</p><p>在WWW上，任何一个信息资源都有统一的并且在网上唯一的地址，这个地址就叫做URL；</p><p>统一资源定位符URL：资源（文字、视频等）唯一标识；</p><p>URL一般形式：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><blockquote><p>协议：http、ftp；</p><p>主机：域名、IP地址；</p></blockquote><h3 id="超文本传输协议HTTP">超文本传输协议HTTP</h3><p>HTTP协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器；</p><p><img src="https://img.lishangcc.top//img/image-20220902224707160.png" alt="image-20220902224707160"></p><p><strong>工作过程</strong></p><ol><li>浏览器分析URL；</li><li>浏览器向DNS请求解析IP地址；</li><li>DNS解析出IP地址；</li><li>浏览器与服务器建立TCP连接；</li><li>浏览器发出取文件命令；</li><li>服务器响应；</li><li>释放TCP连接；</li><li>浏览器显示；</li></ol><p><strong>HTTP协议特点</strong></p><ul><li><p>HTTP协议是无状态的；</p></li><li><p>Cookie：存储在用户主机中的文本文件，记录一段时间内某用户（使用识别码识别）的访问记录；</p></li><li><p>HTTP采用TCP作为运输层协议，但HTTP协议本身是<code>无连接</code>的；</p><blockquote><p>非持久连接：每个网页元素的对象都需要单独建立一次TCP连接，即需要两个RTT；</p><p>持久连接：在建立TCP连接后，双方可以继续使用该TCP连接传输，有以下两种；</p><ul><li>非流水线式（类似停止-等待）：一次只能进行一个对象的传输；</li><li>流水线式（类似后退N帧或者选择重传）：一次可以传输多个对象；</li></ul></blockquote></li></ul><p><strong>HTTP报文</strong></p><p>HTTP报文是面向文本的，因此报文中每一个字段都是一些ASCII码串；</p><p>HTTP报文有两种：①请求报文；②响应报文；</p><p><img src="https://img.lishangcc.top//img/image-20220902225824127.png" alt="image-20220902225824127"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 传输层</title>
      <link href="/myblog/2022/09/02/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2022-09-02-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/myblog/2022/09/02/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2022-09-02-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="传输层概述">传输层概述</h2><h3 id="传输层功能">传输层功能</h3><ol><li><p>提供进程与进程间的通信（网络层是主机与主机之间的通信；）；</p></li><li><p>复用和分用；</p><blockquote><p>复用：多个进程可以使用同一个传输层协议传输数据；</p><p>分用：接收方的传输层在收到数据后，将其分离，并送给相应的进程；</p></blockquote></li><li><p>差错检测；</p></li></ol><h3 id="传输层的寻址和端口">传输层的寻址和端口</h3><p>端口：标识主机中的进程（软件端口，区别于路由器和交换机之类的硬件端口）；</p><p>端口号只有本地意义（不同主机端口号无联系）；</p><p><strong>熟知端口号：0~1023</strong></p><table><thead><tr><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>SNMP</th></tr></thead><tbody><tr><td>熟知端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>161</td></tr></tbody></table><p>套接字（主机IP地址，端口号）：唯一标识一个主机和它的一个进程；</p><h2 id="UDP协议">UDP协议</h2><ul><li>无连接、不可靠传输；</li><li>无拥塞控制，适合实时应用；</li></ul><p><strong>UDP首部格式</strong></p><p><img src="https://img.lishangcc.top//img/image-20220902150844193.png" alt="image-20220902150844193"></p><ul><li>源端口号：可有可无。如果不要求回信，则可以全0；</li><li>目的端口号：必须有；</li><li>UDP长度：整个数据报的长度，即数据部分+UDP首部（8B）；</li><li>UDP检验和：检测是否有错，有错直接丢弃；</li></ul><p>分用时，找不到目的端口号，直接丢弃，并向发送方返回ICMP端口不可达报文；</p><h2 id="TCP协议">TCP协议</h2><ul><li><p><code>面向连接</code>，且该连接只能有两个端点（点对点连接）</p></li><li><p><code>提供可靠服务</code>，即无差错、不丢失、不重复、按序到达（可靠有序，不丢不重）</p></li><li><p><code>提供全双工通信</code>（发送方和接收方可以互换），因此，需要建立发送缓存和接收缓存</p><blockquote><p>发送缓存：①准备发送的数据②已经发送但未收到确认的数据</p><p>接收缓存：①按序到达但是未被应用读取的数据②未按序收到的数据</p></blockquote></li><li><p><code>TCP面向字节</code>（将应用程序交付的数据仅视为一段无结构的字节流）</p></li></ul><h3 id="TCP首部格式">TCP首部格式</h3><p><img src="https://img.lishangcc.top//img/image-20211208204449329.png" alt="image-20211208204449329"></p><p><strong>源端口和目的端口字段</strong> —— 各占 2 字节。端口是传输 层与应用层的服务接口，每个端口对应一个应用程序。</p><p><strong>序号(SEQ)</strong> —— 占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值 则指的是本报文段所发送的数据的第一个字节的序号。</p><p><strong>确认号(ACK)</strong> —— 占 4 字节，是期望收到对方的 下一个报文段的数据的第一个字节的序号。</p><p><strong>数据偏移</strong> —— 占 4 bit，它指出 TCP 头部包含多少个32bit的 字。（也指明了报文段的数据起始处距离 TCP 报文段的起始处 有多远。“TCP头长度”的单位不是字节而是 32 bit 字（4 字节 为计算单位）。</p><p><strong>保留字段</strong> —— 占 4bit，保留为今后使用，但目前 应置为 0。</p><blockquote><p><strong>紧急指针URG</strong> —— 当 URG = 1 时，表明紧急指针 字段有效。它告诉系统此报文段中有紧急数据，应 尽快传送(相当于高优先级的数据)。</p><p><strong>确认比特 ACK</strong> —— 只有当 ACK = 1 时确认号字 段才有效。当 ACK = 0 时，确认号无效。</p><p>推送比特 PSH (PuSH) —— 接收 TCP 收到推送比特 置 1 的报文段，就尽快地交付给接收应用进程，而不 再等到整个缓存都填满了后再向上交付。</p><p>复位比特 RST (ReSeT) —— 当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）， 必须释放连接，然后再重新建立运输连接。</p><p><strong>同步比特 SYN</strong> —— 同步比特 SYN 置为 1，就表示 这是一个连接请求或连接接受报文。</p><p><strong>终止比特 FIN</strong> —— 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送端的数据已发送完 毕，并要求释放传输连接。</p></blockquote><p><strong>窗口(WIN)</strong>——占2字节。窗口字段用来控制对方发送的数据量,单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小,然后通知对方以确定对方的发送窗口的上限。</p><p><strong>检验和</strong> —— 占 2 字节。检验和字段检验的范围包括 首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p><p><strong>紧急指针</strong> —— 占 16 bit。紧急指针指出在本报文段中的紧急数据的最后一个字节的位置。</p><p><strong>选项</strong> —— 长度可变。TCP 只规定了一种选项， 即最大报文段长度 MSS (Maximum Segment Size)。 MSS 告诉对方 TCP： “我的缓存所能接收的报文段 的数据字段的最大长度是 MSS 个字节。 ”</p><blockquote><p>MSS 是 TCP 报文段中的数据字段的最大长度。 数据字段加上 TCP 首部才等于整个的 TCP 报文段</p></blockquote><p><strong>填充</strong> —— 这是为了使整个首部长度是 4 字节的 整数倍。</p><h3 id="TCP连接管理">TCP连接管理</h3><p><strong>三次握手</strong></p><p><img src="https://img.lishangcc.top//img/image-20211208204751088.png" alt="image-20211208204751088"></p><p>第一次：客户端发送连接请求报文，无应用层数据。<br>SYN=1，seq=x（随机）</p><p>第二次：<code>服务端</code>为该TCP连接<code>分配缓存</code>和<code>变量</code>，并向客户端返回确认报文段，允许连接，无应用层数据。<br>SYN=1，ACK=1，seq=y（随机），ack=x+1</p><p>第三次：<code>客户端</code>为该TCP连接<code>分配缓存</code>和<code>变量</code>，并向服务器端返回确认的报文，可以携带数据。<br>SYN=0，ACK=1，seq=x+1，ack=y+1</p><blockquote><p>ACK：这里出现的ACK即为上面所说的TCP报文段首部中的“ACK字段”，置1时该报文段为确认报文段。</p><p>ack：ack则为TCP报文段首部中“确认号”的具体数值。ack=x+1说明B希望A下次发来的报文段的第一个数据字节为序号=x+1的字节；ack=y+1说明A希望B下次发来的报文段的第一个数据字节为序号=y+1的字节。</p><p>seq序号、ack序号：用于确认数据是否准确，是否正常通信。</p></blockquote><p><strong>四次挥手</strong></p><p><img src="https://img.lishangcc.top//img/image-20211209222153580.png" alt="image-20211209222153580"></p><p>第一步：客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。<br>FIN=1，seq=u</p><p>第二步：服务端回送一个确认报文段，客户到服务器这个方向的连接就释放了——半关闭状态；<br>ACK=1，seq=v，ack=u+1</p><p>第三步：服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接；<br>FIN=1，ACK=1，seq=w，ack=u+1</p><p>第四步：客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭。<br>ACK=1，seq=u+1，ack=w+1</p><h3 id="TCP可靠传输">TCP可靠传输</h3><ol><li><p><strong>校验</strong>：跟UDP校验一样，添加伪首部；</p></li><li><p><strong>序号</strong>：TCP为传输的每一个字节都编上一个序号</p><blockquote><p>序号字段：本报文段发送的数据的第一个字节的序号；</p></blockquote></li><li><p><strong>确认</strong>：采用累计确认或者捎带确认；</p><blockquote><p>接收时候若能按序接收，则返回的确认是期待接收的下一个字节</p><p>接收时若未能按序接收，则返回的确认是数据流中第一个丢失字节为止的字节</p></blockquote></li><li><p><strong>重传</strong>：</p><p>①超时重传：TCP发送方在规定时间内若没有收到接收方发回的确认则重传已发送的报文段</p><p>规定时间：TCP采用自适应算法，它的RTT会随着之前的报文的RTT变化产生新的RTTS</p><p>②冗余ACK：解决超时重传需要等待过久的问题</p><blockquote><p>TCP规定每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号。若发送方接收到对同一个报文段的3个冗余ACK时，就判定该报文段丢失，立即重传该报文段</p></blockquote></li></ol><blockquote><p>例：发送方发送1、2、3、4、5，但是2在传输过程中丢失；</p><ul><li><p>接收方接收到1：返回1的确认（表示期望接收序号为2的数据）</p></li><li><p>接收方接收到3：失序接收，仍返回1的确认（表示期望接收序号为2的数据）</p></li><li><p>接收方接收到4：失序接收，仍返回1的确认（表示期望接收序号为2的数据）</p></li><li><p>接收方接收到5：失序接收，仍返回1的确认（表示期望接收序号为2的数据）</p></li></ul><p>发送方收到3个对报文段1的冗余确认（收到的第一个对报文段1的确认不是冗余确认），判定报文段2丢失，立即重传报文段2</p></blockquote><h3 id="TCP流量控制">TCP流量控制</h3><blockquote><p>例：设A给B发数据，B仅回确认报文，初始时B的接收窗口rwnd为400B。</p><p><img src="https://img.lishangcc.top//img/image-20220902172758386.png" alt="image-20220902172758386"></p><p>①A发送序号为1 - 100的数据共100B，B的接收窗口大小为400 - 100 = 300B</p><p>②A发送序号为101 - 200的数据共100B，B的接收窗口大小为300 - 100 = 200B</p><p>③A发送序号为201 - 300的数据共100B，但传输过程中丢失</p><p>④B发送确认报文（只有ACK = 1的时候，ack才有效），确认按序收到前200B的数据，并更改接收窗口为300B</p><p>⑤A发送序号为301 - 400的数据共100B，B的接收窗口大小为300 - 100 = 200B（虽然未能按序接收，但是接受数据前，B的接收窗口为300B，参考数据链路层的选择重传协议SR，可以先将该失序数据放到接收缓存，等待按序数据的到来后，采用累加确认的方式对数据进行确认）</p><p>⑥A发送序号为401 - 500的数据共100B，B的接收窗口大小为200 - 100 = 100B</p><p>⑥A此时仍未收到B对序号为201 - 300的数据的确认帧，判定该数据丢失，重新传输。A发送序号为201 - 300的数据共100B，B的接收窗口大小为100 - 100 = 0B（此时，B原本接收的序号为301 - 500的失序数据数据加上现在接收的201 - 300的数据，组合而成按序接收的201 - 500的数据）</p><p>⑦B发送确认报文，确认按序收到前500B的数据，并更改接收窗口为100B</p><p>⑧A发送序号为501 - 600的数据共100B，B的接收窗口大小为100 - 100 = 0B</p><p>⑨B发送确认报文，确认按序收到前600B的数据，并更改接收窗口为0B</p><p>⑩当接收窗口为0B时，A就会每隔一段时间向B发送查询当前B的接收窗口的报文，B收到该报文后，就会向A返回一个当前接收窗口大小的报文。若不为0，则继续传输；若仍未0，则继续等待一个间隔后重复操作</p></blockquote><h3 id="TCP拥塞控制">TCP拥塞控制</h3><p>拥塞控制是防止过多的数据注入网络，保证网络中的路由器不过载；</p><p><code>接收窗口</code>：接收方根据接受缓存设置的值，并告知发送方，<code>反映接收方容量</code>；</p><p><code>拥塞窗口</code>：发送方根据自己估算的网络拥塞程度而设置的窗口值，<code>反映网络当前容量</code>；</p><h4 id="慢开始和拥塞避免">慢开始和拥塞避免</h4><p><img src="https://img.lishangcc.top//img/image-20220902173332098.png" alt="image-20220902173332098"></p><ol><li><p>慢开始：指的是拥塞窗口从1开始（试探网络拥塞情况），在经历一个RTT后，拥塞窗口加倍（线性增长），直到达到慢开始的阈值时，改用拥塞避免；</p></li><li><p>拥塞避免：经历一个RTT后，拥塞窗口+1（加法增长）。直到发生网络拥塞后，拥塞窗口重新变回1，更改慢开始阈值为此时拥塞窗口的一半，并重新改用慢开始算法；</p></li></ol><h4 id="快重传和快恢复">快重传和快恢复</h4><p><img src="https://img.lishangcc.top//img/image-20220902173651769.png" alt="image-20220902173651769"></p><p><code>快重传</code>：冗余ACK。当收到三个对同一序号的ACK报文时，直接重传该报文，无须等待超时重传；</p><p><code>快恢复</code>：当发生快重传后，拥塞窗口变为当前拥塞窗口的一半（预防发生拥塞）（区别于采用之前采用慢开始和拥塞避免情况下，拥塞窗口变为1），之后采用拥塞避免，每经历一个RTT，拥塞窗口+1（加法增加）；</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 网络层</title>
      <link href="/myblog/2022/08/29/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2022-08-29-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/myblog/2022/08/29/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2022-08-29-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="网络层功能概述">网络层功能概述</h2><ul><li>路由选择和分组转发；</li><li>异构网络互联；</li><li>拥塞控制（开环控制：静态；闭环控制：动态）；</li></ul><h2 id="路由算法">路由算法</h2><ul><li>静态路由算法（非自适应路由算法）：管理员手工配置路由信息；</li><li>动态路由算法（自适应路由算法）：路由器间彼此交换信息，按照路由算法优化出路由表项；</li></ul><p><strong>路由算法</strong></p><p>自治系统内使用内部网关协议（IGP）：RIP、OSPF；</p><p>自治系统间使用外部网关协议（EGP）：BGP；</p><blockquote><p>自治系统AS：在单一的技术管理下的一组路由器，</p></blockquote><h3 id="RIP协议">RIP协议</h3><ul><li><p>应用层协议，使用UDP传送数据；</p></li><li><p>RIP是一种分布式的基于距离向量的路由选择协议；</p></li><li><p>要求网络中每一个路由器都维护从自己到其他每一个目的网络的唯一最佳距离；（格式：&lt;目的网络&gt;&lt;距离&gt;&lt;下一条路由器地址&gt;）</p><blockquote><p>从一路由器到直接连接的网络距离为1；</p><p>RIP允许一条路由最多包含15个路由器，即距离为15；</p><p>距离为16表示网络不可达；</p></blockquote></li></ul><p><strong>工作过程</strong></p><p><img src="https://img.lishangcc.top//img/image-20220901234127139.png" alt="image-20220901234127139"></p><blockquote><p>例：已知路由器R6的路由表，现收到相邻路由器R4发来的路由更新信息，试更新R6的路由表；</p><p><img src="https://img.lishangcc.top//img/image-20220901234343440.png" alt="image-20220901234343440"></p></blockquote><h3 id="OSPF协议">OSPF协议</h3><ol><li><code>向谁发送</code>：使用洪泛法（洪水一般泛滥）向自治系统内所有路由器发送信息（一传十，十传百）；</li><li><code>发送什么</code>：发送的信息就是与本路由器相邻的所有的路由器的链路状态；</li><li><code>多久交换一次</code>：只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息（RIP是每30秒更新一次）；</li></ol><blockquote><p>规模大的时候，OSPF比RIP好（规模过大的时候，OSPF会将一个自治系统划分成若干个区域）；</p><p>OSPF不存在收敛慢的问题；</p></blockquote><h3 id="BGP协议">BGP协议</h3><p>1.向谁发送：其他自治系统的BGP发言人（需要建立TCP连接）；</p><p>2.发送什么：交换网络可达性信息（到达某一网络要经历的一系列自治系统，即路径）（据此选出到达各AS的较好路由）；</p><p>3.多久交换：只有发生变化时候（类似OSPF），仅更新有变化的部分（刚开始时，交换整个BGP路由表）；</p><p>4.支持CIDR；</p><h3 id="三种协议比较">三种协议比较</h3><p><img src="https://img.lishangcc.top//img/image-20220902110439121.png" alt="image-20220902110439121"></p><h2 id="IPv4地址">IPv4地址</h2><h3 id="IP数据报格式">IP数据报格式</h3><p><img src="https://img.lishangcc.top//img/20200520161629236.png" alt="img"></p><ul><li><p>版本：IPv4/IPv6</p></li><li><p>首部长度：单位是4B，最小为5（即0101）；</p></li><li><p>服务类型：指示期望获得哪种类型的服务；</p></li><li><p>总长度：首部+数据，单位是1B；</p></li><li><p>标识：同一数据报的分片使用同一标识；</p></li><li><p>标志位：3位只有后2位有意义；</p><blockquote><p>中间位：DF=1禁止分片；DF=0允许分片；</p><p>最低位：MF=1：后面还有分片；MF=0：代表最后一片或没有分片</p></blockquote></li><li><p>片偏移：指出较长分组分片后，某片在原分组中的相对位置，以8B为单位；</p></li><li><p>生存周期（TTL）：IP分组的保质期，经过一个路由器减1，变成0则丢弃；</p></li><li><p>协议：数据部分的协议；</p></li><li><p>首部校验和：只检验首部；</p></li><li><p>源IP地址和目的IP地址：32位；</p></li><li><p>选项字段：0—40B，用来支持排错、测量以及安全等措施；</p></li><li><p>填充：全0，把首部补成4B的整数倍；</p></li></ul><p><strong>数据报分片</strong></p><p><code>分片的原因</code>：数据链路层的MTU严格限制IP数据报的长度，若大于该长度，则无法传输，因此，需要分片（过长但是不同意分片的分组，则无法传递，返回ICMP差错报文）；</p><p>分片在接收方的网络层进行组装，同一分组的标识相同，根据片偏移字段确定该分片属于原数据的哪一个部分；</p><blockquote><p>如：原数据部分为3800B，设最长分片不超过1420B；</p><p>①首部为20B，因此，最长分片的最大数据部分为1420 - 20 = 1400B</p><p>②3800 = 1400 + 1400 + 1000</p><p>③0 - 1399为第一个分片：因为是第一个分片，片偏移量为0，总长度为数据部分1400B + 首部20B = 1420B，DF = 0（允许分片），MF = 1（不是最后一个分片），标识为12345（假设）</p><p>1400 - 2799为第二个分片：第一个字节为1400B，除以单位8B，片偏移量为175，总长度为数据部分1400B + 首部20B = 1420B，DF = 0（允许分片），MF = 1（不是最后一个分片），标识为12345</p><p>2800 - 3799为第三个分片：第一个字节为2800B，除以单位8B，片偏移量为350，总长度为数据部分1000B + 首部20B = 1020B，DF = 0（允许分片），MF = 0（是最后一个分片），标识为12345</p></blockquote><h3 id="IP地址分类">IP地址分类</h3><p><img src="https://img.lishangcc.top//img/image-20220831140135820.png" alt="image-20220831140135820"></p><p><img src="https://img.lishangcc.top//img/image-20220831140339989.png" alt="image-20220831140339989"></p><p><strong>特殊IP地址</strong></p><p><img src="https://img.lishangcc.top//img/image-20220831144838796.png" alt="image-20220831144838796"></p><p><strong>私有IP地址</strong>：用于内部网络；</p><p><img src="https://img.lishangcc.top//img/image-20220831144955908.png" alt="image-20220831144955908"></p><h3 id="网络地址转换NAT">网络地址转换NAT</h3><p>在专用网连接到因特网的路由器上安装NAT软件，安装后即为<code>NAT路由器</code>，其至少有一个有效的<code>外部全球IP地址</code>；</p><p><img src="https://img.lishangcc.top//img/image-20220831150041681.png" alt="image-20220831150041681"></p><blockquote><p><img src="https://img.lishangcc.top//img/image-20220831150244574.png" alt="image-20220831150244574"></p><p>如：A给B发送数据:</p><ol><li>A给NAT路由器发送数据报①：网络层：源IP地址为192.168.0.3（A的专有网内地址），目的地址为213.18.2.4（B的IP地址）；传输层：端口号30000</li><li>NAT路由器给B发送数据报①：将C中原来的源IP地址192.168.0.3（A的专有网内地址）替换为172.38.1.5（NAT路由器IP地址），并且端口号也从30000替换为40001，但是，目的地址不变，这样B就能识别（根据NAT转换表）</li></ol></blockquote><h3 id="子网划分与子网掩码">子网划分与子网掩码</h3><p>子网划分的原因：</p><ol><li>IP地址空间的利用率有时很低；</li><li>两级IP地址不够灵活；</li></ol><p><strong>子网划分</strong></p><p><img src="https://img.lishangcc.top//img/image-20220831152501479.png" alt="image-20220831152501479"></p><blockquote><p>若某单位划分子网后，对外仍表现为一个网络，即外面的网络看不到单位内子网的划分；</p><p>子网号可以没有，但主机号至少2位，同时主机号不能全0或全1；</p></blockquote><p><strong>子网掩码</strong></p><p>网络号全1，主机号全0；</p><p><img src="https://img.lishangcc.top//img/image-20220831152759334.png" alt="image-20220831152759334"></p><blockquote><p>给出子网掩码与IP地址，求子网网络地址时，子网掩码与IP地址逐位相与；</p></blockquote><h3 id="无分类编址CIDR">无分类编址CIDR</h3><h3 id="ARP协议">ARP协议</h3><p>完成主机或路由器IP地址到MAC地址的映射（解决下一跳走哪的问题）；</p><blockquote><p>数据链路层发送数据需要接收方IP地址和MAC地址，发送方IP地址和目的地址。但是，有时候仅有接收方的IP地址，而没有接收方的MAC地址，ARP就是通过接收方的IP地址查询其MAC地址；</p></blockquote><p><strong>协议使用过程</strong></p><p><img src="https://img.lishangcc.top//img/image-20220831193344409.png" alt="image-20220831193344409"></p><h3 id="DHCP协议">DHCP协议</h3><p>DHCP是<code>应用层协议</code>；使用<code>客户/服务器</code>方式，客户端与服务端通过<code>广播</code>方式进行交互，基于<code>UDP</code>；</p><p><img src="https://img.lishangcc.top//img/image-20220831210826189.png" alt="image-20220831210826189"></p><p><strong>功能</strong></p><ul><li>即插即用：主机进入范围内，DHCP就可以为它进行服务；</li><li>地址重用：设IP地址为IP1，本来由A使用，在A不再使用该地址后，B可以使用IP1；</li><li>支持移动用户加入网络；</li><li>支持在用地址续租：每个IP地址都有一个使用时间；</li></ul><p><strong>工作过程</strong></p><ol><li>主机广播<code>DHCP发现报文</code>，试图找到网络中的服务器；（有没有DHCP服务器啊？）</li><li>DHCP服务器广播<code>DHCP提供报文</code>，服务器拟分配给主机一个IP地址及相关配置，先到先得；（有！有！有！）</li><li>主机广播<code>DHCP请求报文</code>，主机向服务器请求提供IP地址；（那我用咯？）</li><li>DHCP服务器广播<code>DHCP确认报文</code>，正式将IP地址分配给主机；（用吧！）</li></ol><h3 id="ICMP协议">ICMP协议</h3><p>ICMP是网络层协议；</p><p>作用是通过ICMP报文报告差错或者异常情况；</p><p><strong>差错报告报文</strong></p><ol><li><code>终点不可达</code>：路由器或主机无法交付数据报；</li><li><code>源点抑制</code>：网络拥塞丢数据；</li><li><code>时间超过</code>：路由器收到生存时间为0的数据或者目的主机没在预定时间内收到完整的数据报;</li><li><code>参数问题</code>：首部字段有问题；</li><li><code>改变路由（重定向</code>：路由器改变路由报文发给主机，让主机知道下次数据报发给别的路由器更好；</li></ol><p><strong>不发送ICMP差错报文的情况</strong></p><ol><li>对<code>ICMP差错报告报文</code>不再发送ICMP差错报告报文；</li><li>对第一个分片的数据报片的所有<code>后续数据报片</code>都不发送差错报文；</li><li>对具有组播地址的数据报不发送；</li><li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送；</li></ol><p><strong>ICMP询问报文</strong></p><p>①回送请求和回答报文：测试目的站是否可达及了解状况（PING）；</p><p>②时间戳请求和回答报文：用来进行时间同步和测量时间；</p><p><strong>ICMP的应用</strong></p><ul><li>PING：测试两个主机之间的连通性，使用了<code>ICMP回送请求和回答报文</code>；</li><li>Traceroute：跟踪一个分组从源点到终点的路径，使用了<code>ICMP时间超过差错报告报文</code>；</li></ul><h2 id="IPv6">IPv6</h2><blockquote><p>CIDR和NAT没有从根本上解决地址空间分配问题，因此产生了IPv6；</p></blockquote><h2 id="IP组播">IP组播</h2><ul><li>单播：发送数据到单个目的地，<code>点对点</code>；</li><li>广播：发送数据到某一广播域或子网内所有设备，<code>点对多点</code>；</li><li>组播（多播）：发送数据到某些<code>特定主机</code>，到这些主机的默认网关处开始复制数据和分发（在之前的传输过程中仅发送一份数据），<code>点对多点</code>；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 数据链路层</title>
      <link href="/myblog/2022/08/26/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2022-08-26-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/myblog/2022/08/26/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2022-08-26-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="数据链路层基本概念">数据链路层基本概念</h2><p>数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报；</p><p><code>结点</code>：主机、路由器；</p><p><code>链路</code>：网络中两个结点之间的<code>物理通道</code>，链路的传输介质有：双绞线、光纤、微波；链路分类：有线链路、无线链路；</p><p><code>数据链路</code>：两个结点之间的<code>逻辑通道</code>；</p><p><code>帧</code>：链路层的协议数据单元，封装网络层数据报；</p><p><strong>数据链路层功能</strong></p><ol><li>为网络层提供服务：无确认无连接服务，有确认无连接服务，有确认面向连接服务；（有连接一定有确认）</li><li>链路管理，即连接的建立、维持、释放；（面向连接的服务）</li><li>组帧；</li><li>流量控制；（限制发送方）</li><li>差错控制；</li></ol><h2 id="封装成帧和透明传输">封装成帧和透明传输</h2><p><code>封装成帧</code>：在一段数据的前后添加首部和尾部，这样就构成了一个帧；</p><blockquote><p>接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记识别出帧的开始和结束；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220827164312041.png" alt="image-20220827164312041"></p><p><code>帧同步</code>：接收方应当能从接收到的二进制比特流中区分帧的起始和终止；</p><p><code>透明传输</code>：不管传输什么样的比特流，都应当能在链路上传送；</p><blockquote><p>若所传数据中的某部分比特组合正好与某个控制信息一致，就必须采取适当措施区分开；</p></blockquote><p><code>组帧有四种方法</code>：①字符计数法；②字符填充法；③零比特填充法；④违规编码法；</p><h3 id="字符计数法">字符计数法</h3><p>帧首部用一个计数字段（第一个字节，8位）来标明帧内字符数；</p><p><img src="https://img.lishangcc.top//img/image-20220827164426790.png" alt="image-20220827164426790"></p><p>缺点：若计数字符出现问题，则无法区分后面的帧；</p><h3 id="字符填充法">字符填充法</h3><p>在一段数据中，难免会出现与控制信息相同的比特组合，可以通过添加转义字符标注出来；</p><p><img src="https://img.lishangcc.top//img/image-20220827165444699.png" alt="image-20220827165444699"></p><p>发生端为原始数据某些部分在其前面填充字符；</p><p>接收端收到数据后，碰到填充字符就明白后面的是数据信息；</p><h3 id="零比特填充法">零比特填充法</h3><p>以01111110作为起始和终止标准，发送端在数据信息段中遇到连续5个1就在其后填入1个0；</p><p>接收端接收数据后，先找到起始和终止位置，在对数据信道中填充的0进行删除；</p><blockquote><p>在发送端填充0，在接收端删除0；</p></blockquote><h3 id="违规编码法">违规编码法</h3><p>编码中，用两种不会用到的电平方式标记起始和终止；</p><blockquote><p>如：曼彻斯特编码，“高—低” 表示1，“低—高” 表示0，而不会出现 “高—高”，“低—低” 两种情况；</p></blockquote><h2 id="差错控制">差错控制</h2><h3 id="检错编码">检错编码</h3><h4 id="奇偶校验码">奇偶校验码</h4><p>n-1位信息元，1位校验元；</p><p>奇校验码——添加校验元（0或者1）使得数据中1的个数为奇数</p><p>偶校验码——添加校验元（0或者1）使得数据中1的个数为偶数</p><blockquote><p>缺点：只能查出奇数个比特错误，检错能力为50%，而且不能只能具体那错了；</p></blockquote><h4 id="CRC循环冗余码">CRC循环冗余码</h4><blockquote><p>例：要发送的数据是 1101 0110 11，采用CRC校验，生成多项式是10011，最终发送的数据应该是？</p><p>答：</p><p>先求多项式阶数（N位，阶为N-1）；在原数据后补上N-1个0，用该数除以10011，得到的余数为FCS，原数据后面直接补上FCS即为要发送的数据；</p><p>补充：</p><p>接收端检错过程，把收到的每一个帧都除以同样的除数（即发送端最终发送的数据除以那个多项式），余数为0，这个帧没有查出，接受；余数不为0，有差错，丢弃；</p></blockquote><h3 id="纠错编码（海明码）">纠错编码（海明码）</h3><p>两个编码的比特值不同的总位数称为<code>海明距离（码距）</code>（如：0000,1001，第一位和第四位不同，码距为2）；</p><p>一个编码集中，任意两个编码的码距最小值称为该编码集的<code>海明距离（码距）</code>（如：0000,1001,1111，码距依然为0）；</p><p>检验d位错：码距 ≥ d+1</p><p>纠正d位错：码距 ≥ 2d+1</p><blockquote><p>工作流程：①确定校验码数r；②确定校验码和数据的位置；③求出校验码的值；④检查并纠错；</p></blockquote><p><strong>1.确定校验码位数r</strong></p><p><img src="https://img.lishangcc.top//img/image-20220827202932117.png" alt="image-20220827202932117"></p><blockquote><p>如：要发送的数据：D=1100；</p><p>数据的位数m=4；<br>满足不等式的最小r=3；<br>所以海明码有7位（原数据4位，校验码3位）；</p></blockquote><p><strong>2.确定校验码和数据的位置</strong></p><p>校验码放在序号为2^n的位置上，数据按序填上；</p><blockquote><p>接上题，2^0^=1；2^1^=2；2^2^=4；</p><p><img src="https://img.lishangcc.top//img/image-20220827203300206.png" alt="image-20220827203300206"></p></blockquote><p><strong>3.求出校验码的值</strong></p><p>①每个校验码负责校验表中与自己的二进制含有相同位置1的数据（包括自己）；</p><blockquote><p>x4负责校验1XX：7,6,5,4；</p><p>x2负责校验X1X：7,6,3,2；</p><p>x1负责校验XX1：7,5,3,1；</p></blockquote><p>②采用奇偶校验；</p><blockquote><p>设采用偶校验：</p><p>x4 = 0；</p><p>x2 = 0；</p><p>x1 = 1；</p><p><img src="https://img.lishangcc.top//img/image-20220827204526383.png" alt="image-20220827204526383"></p></blockquote><p><strong>4.检错并纠错</strong></p><blockquote><p>检错</p><p>若接收方收到的数据为1110 001，对照海明码表；</p><p><img src="https://img.lishangcc.top//img/image-20220827212036616.png" alt="image-20220827212036616"></p><p>纠错</p><p>用偶校验</p><p>x4，0,1,1,1→x4=1</p><p>x2，0,0,1,1→x2=0</p><p>x1，1,0,1,1→x1=1</p><p>得：x4，x2，x1为101，则第5位错了；</p></blockquote><h2 id="流量控制与可靠传输">流量控制与可靠传输</h2><p><code>可靠传输</code>：发送端发啥，接收端收啥；</p><p><code>流量控制</code>：控制发送速率，使接收方有足够的缓冲空间来接收每一个帧；</p><blockquote><p>较高的发送速度与较低的接收能力的不匹配，可能会造成传输错误（发送方，你慢点）；</p></blockquote><p><code>数据链路层</code>的流量控制是点对点的；<code>手段</code>：接收方收不下就不回复确认。（发送确认帧就是告诉发送端你可以发送下一个了）<br><code>传输层</code>的流量控制是端到端的；<code>手段</code>：接收端给发送端一个窗口公告。</p><p><code>滑动窗口</code>解决：流量控制（收不下就不给确认，想发也发不了），可靠传输（发送方自动重传）；</p><h3 id="停止-等待协议">停止-等待协议</h3><p>每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧；</p><p><img src="https://img.lishangcc.top//img/image-20220827220535859.png" alt="image-20220827220535859"></p><p><strong>1.无差错情况</strong></p><p>发送端发送一个帧，接收端收到后返回一个确认帧，发送端收到确认帧后再发送下一个帧；</p><p><strong>2.有差错情况</strong></p><p><strong>①数据帧丢失或检测到帧出错</strong></p><p>发送端设置了一个超时计时器，每次发送一个帧就启动一个计时器，设置一个时间（一般大于RTT），若超时而未收到确认帧，发送端重传该帧；</p><blockquote><p>发完一个帧后，必须保留它的副本，以便重传；</p><p>数据帧和确认帧必须编号；</p></blockquote><p><strong>②确认帧丢失</strong></p><p>一样，超时重传该帧，但是当接收端收到重传的帧，应将其丢弃（因为与之前的重复了），并返回确认帧；</p><p><strong>③确认帧迟到</strong></p><p>丢弃掉就好了；</p><p><strong>信道利用率</strong></p><p><img src="https://img.lishangcc.top//img/image-20220827223143551.png" alt="image-20220827223143551"></p><h3 id="后退N帧协议（GBN）">后退N帧协议（GBN）</h3><p><strong>背景</strong>： 一个帧1000bit，信息传输速率为: 50kb/s，从开始发送到结束发送共需: 1000bit/(50kb/s)=20ms.但从一方传输到另外一方的传输时延为250ms，来回500ms。所以一方在发送完一个帧之后,最少要 等待500 ms 才有可能回来确认20/520=4%的信道利用率。即发送方要在500 ms 时才能发送第一帧。</p><p><strong>利用该协议</strong>：不是一次发送一个帧，而是一次可以连续发送若干个帧；</p><p><strong>以上问题解决</strong>：增加最大发送窗口的数目，Ws=26，一次可以发送26帧，当发完26帧（26×20=520ms）之后正好收到第0号帧的确认，从而发送窗口向前移动，发送27帧，20ms之后发完27帧，正好收到对第1帧的确认，依次进行；</p><p><strong>特点</strong>：信道利用率高，任何时候都有帧在等待确认；管道化技术，管道比较长本身有容量，流经它需要时间比较长，容纳25到26个帧。</p><p><strong>出错时：</strong></p><p><img src="https://img.lishangcc.top//img/image-20211208103811819.png" alt="image-20211208103811819"></p><p><strong>过程</strong></p><p><img src="https://img.lishangcc.top//img/image-20211208110858452.png" alt="image-20211208110858452"></p><p><strong>窗口长度不能无限</strong></p><p><img src="https://img.lishangcc.top//img/image-20211208104820990.png" alt="image-20211208104820990"></p><p><img src="https://img.lishangcc.top//img/image-20211208104838587.png" alt="image-20211208104838587"></p><p><strong>总结</strong></p><p><img src="https://img.lishangcc.top//img/image-20211208105908223.png" alt="image-20211208105908223"></p><h3 id="选择重传协议（SR）">选择重传协议（SR）</h3><p>**后退N帧协议的问题：**当线路的出错率高时,将出错帧之后的所有帧都丢弃掉,重传这些帧会带来效率上的大幅度降低</p><p><strong>解决方法——选择重传协议</strong></p><ul><li>将接收窗口的数目增加Wr&gt;1</li><li>帧出错之后,对出错帧之后的帧能够接收并且储存在接收缓冲区中</li><li>一旦出错帧到达,和之前接收到的帧一起顺序提交给网络层</li><li>接收窗口的滑动过程</li></ul><p><strong>过程</strong></p><p><img src="https://img.lishangcc.top//img/image-20211208105325093.png" alt="image-20211208105325093"></p><h3 id="协议总结">协议总结</h3><ul><li>停止-等待协议：发送窗口=1，接收窗口=1；</li><li>后退N帧协议：发送窗口&gt;1，接收窗口=1，发送窗口&lt;=2^n^-1;</li><li>选择重传协议：发送窗口&gt;1，接收窗口&gt;1，发送窗口 ≥ 接收窗口，发送窗口+接收窗口 ≤ 2^n^；</li></ul><h2 id="介质访问控制">介质访问控制</h2><blockquote><p>使用广播通信时，若有两个或多个节点同时发送信息，会导致信道上发生信号冲突问题；</p><p>介质访问控制：采取一定的措施，使得两对节点之间的通信不会受到干扰；</p></blockquote><p>点对点链路：两个相邻节点通过一条链路相连；应用：PPP协议；常用于<code>广域网</code>；</p><p>广播式链路：所有主机共享通信介质（其他人能收到）；常用于<code>局域网</code>；典型拓补结构：总线型、星型；</p><h3 id="信道划分介质访问控制（静态）">信道划分介质访问控制（静态）</h3><p>将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开（使用多路复用技术），把<code>时域和频域资源</code>合理地分配给网络上的设备；</p><p><img src="https://img.lishangcc.top//img/image-20220828191434455.png" alt="image-20220828191434455"></p><blockquote><p>把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子线道，<code>把广播信道转变为点对点信道</code>；</p></blockquote><p><strong>1.频分多路复用FDM</strong></p><p>同一时间不同用户占用不同的频率；</p><p><strong>2.时分多路复用TDM</strong></p><p>将时间划分为等长的若干周期，每个用户占用一个时间周期（不同时间）；</p><p><strong>3.波分多路复用WDM</strong></p><p>就是<code>光的频分多路复用</code>，在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率)不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来；</p><p><strong>4.码分多路复用CDM</strong>*</p><p>1个比特分为多个码片，每一个站点被指定一个唯一m为的芯片序列，<code>发送1时站点发送芯片序列</code>，<code>发送0时发送芯片序列反码</code>；</p><p>设A的码片序列为0001 1011，B的码片序列为0010 1110，则0用-1表示，1用+1表示：</p><p>A：-1 -1 -1 +1+1 -1 +1 +1 ——发送比特1</p><p>A：+1 +1 +1 -1-1 +1 -1 -1——发送比特0（反码）</p><p>B：-1 -1 +1 -1+1 +1 +1 -1——发送比特1</p><p>B：+1 +1 -1 +1 -1 -1 -1 +1——发送比特0（反码）</p><p><img src="https://img.lishangcc.top//img/image-20220828201207498.png" alt="image-20220828201207498"></p><h3 id="随机访问介质访问控制（动态）">随机访问介质访问控制（动态）</h3><h4 id="ALOHA协议（不听就说）">ALOHA协议（不听就说）</h4><p>**纯ALOHA：**如果有数据需要发送就传输。 如果发生冲突， 就完成当前传输并稍后重试。</p><p><img src="https://gitee.com/lishangcc/picgo/raw/master/img/image-20211208111148369.png" alt="image-20211208111148369"></p><p>**时隙ALOHA：**把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送。</p><p><img src="https://gitee.com/lishangcc/picgo/raw/master/img/image-20211201165144909.png" alt="image-20211201165144909"></p><blockquote><p>纯ALOHA比时隙ALOHA吞吐量更低，效率更低；<br>纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发；</p></blockquote><h4 id="CSMA协议（先听再说）">CSMA协议（先听再说）</h4><p>CS——载波监听    MA——多点接入；</p><p>发送帧之前，监听信道，若信道空闲，发送完整帧，若信道忙，推迟发送；</p><p><strong>1.1-坚持CSMA</strong></p><p>信道空闲直接传输，若信道忙则一直等待；</p><p>冲突（一定时间内未收到回复）则等待一个随长的时间再监听，重复上述过程；</p><blockquote><p>优点：避免媒体利用率的损失；</p><p>缺点：假如有两个或多个站点有数据要发送，冲突就不可避免；</p></blockquote><p><strong>2.非坚持CSMA</strong></p><p>空闲直接传输，忙则等待一个随机时间后再进行监听；</p><blockquote><p>优点：减少冲突发生的可能性；</p><p>缺点：可能存在大家都在等待，而媒体已处于空闲状态；</p></blockquote><p><strong>3.p-坚持CSMA</strong></p><p>空闲则以p概率直接传输，以1-p概率等到下一个时间槽再传输；</p><p>忙则持续监听，等到空闲以p概率发送；</p><p>若冲突则等到下一个时间槽再监听，并重复上述过程；</p><p><strong>三种对比</strong></p><p><img src="https://img.lishangcc.top//img/image-20220828205757947.png" alt="image-20220828205757947"></p><h4 id="CSMA-CD协议">CSMA/CD协议*</h4><p>CD：碰撞检测，边发送边监听；</p><p><strong>过程</strong></p><p><img src="https://img.lishangcc.top//img/image-20220828211504358.png" alt="image-20220828211504358"></p><blockquote><p>只要经过2τ时间没检测出碰撞，那么此次发送不会发生碰撞；</p></blockquote><p><strong>如何确定碰撞后的重传时机</strong></p><p><img src="https://img.lishangcc.top//img/image-20220828220526930.png" alt="image-20220828220526930"></p><p><strong>最小帧的长度</strong></p><p>背景：A站发了一个很短的帧，但发生了碰撞，不过帧在发生完毕后才检测到发生碰撞，没法停止发送，因为发完了。。。</p><p><img src="https://img.lishangcc.top//img/image-20211208134508824.png" alt="image-20211208134508824"></p><blockquote><p>例：考虑建立一个CSMA/CD网络，在一个1公里的电缆上运行1 Gbps，没有中继器。电缆中的信号速度为200000公里/秒。最小帧长度是多少？</p><p>对于1km 电缆，单程传播时间为1/200000=5×10-6 s=5微秒，往返传播时间为2t=10 微秒。为了能够按照CSMA/CD 工作，最小帧的发射时间不能小于10 微秒。以1Gb/s速率工作，10 可以发送的比特数等于：<br>（10×10-6）×（1×10^9）=10000。因此，最小帧是10000 bit = 1250字节长</p></blockquote><h4 id="CSMA-CA协议">CSMA/CA协议</h4><p>CSMA / CA用于无线网（存在隐蔽站）</p><p>1.发送数据前，先检测信道是否空闲</p><p>2.空闲则发送RTS（request to send）（避解决隐蔽站），包括源地址、目的地址、数据将持续发送的时间，忙则等待</p><p>3.接收方收到RTS后，返回CTS（clear to send）（解决隐蔽站）</p><p>4.发送方接收到CTS后，预约信道（发送方告知其他站点自己需要发送多久数据）（避免碰撞的方法），并开始发送数据帧</p><p>5.接收方接收到数据后，用CRC进行确认，正确则返回ACK帧（避免碰撞）</p><p>6.发送方收到ACK帧后，开始下一个数据帧的传输，若一段时间未收到ACK帧，则重新传输（采用二进制指数退避算法确定随机延迟时间）</p><p><img src="https://img.lishangcc.top//img/image-20220828220956929.png" alt="image-20220828220956929"></p><h3 id="轮询访问介质访问控制（动态）">轮询访问介质访问控制（动态）</h3><h4 id="令牌传递协议">令牌传递协议</h4><p>1.既不产生冲突，又可以占全部带宽</p><p>2.令牌：特殊的MAC控制帧，不含任何信息。用于控制信道使用，确保同一时刻只有一个结点独占信道</p><p>3.令牌循环的在各个主机中传递，并且限定持有时间（防止传输数据过大）。若有主机需要传送数据，则修改令牌标志位，并附上数据和目的主机，其他的主机在接收令牌时若不是目的主机则传递给下一个，直到传递到目的主机后，目的主机复制该数据</p><p>4.存在问题：令牌开销；等待延迟；单点故障</p><p>5.物理：星形拓扑；逻辑：环形拓扑</p><h2 id="局域网体系结构">局域网体系结构</h2><p><img src="https://img.lishangcc.top//img/image-20220828222510677.png" alt="image-20220828222510677"></p><p>IEEE 802.3 以太网</p><p>IEEE 802.5 令牌环网</p><p>IEEE 802.11 无线局域网WLAN</p><p>局域网将数据链路层分为<code>逻辑链路控制子层LLC</code>和<code>介质访问控制子层MAC</code>；</p><p>LLC：负责识别网络层协议，然后对它们进行封装。靠近网络层，为网络层提供服务；</p><p>MAC：负责对数据帧进行封装和处理，帧的寻址和识别，帧的接收和发送，链路的管理，帧的差错控制等。靠近物理层；</p><h3 id="以太网（Ethernet）">以太网（Ethernet）</h3><p>1.以太网采用CSMA/CD</p><p>2.以太网标准IEEE 802.3</p><p>3.提供无连接，不可靠服务</p><blockquote><p>A.无连接：发送方和接收方无需建立连接</p><p>B.不可靠：发送方无须编号，接收方无须确认，差错帧直接丢弃，差错纠正由上层进行</p><p>C.只实现无差错接收，不实现可靠传输</p></blockquote><p>4.逻辑上总线，物理上星形</p><p><strong>以太网MAC帧</strong><br><img src="https://img.lishangcc.top//img/image-20220828234804065.png" alt="image-20220828234804065"></p><ul><li>对于数据进行加头（目的地址、源地址、类型）加尾（FCS）</li><li>类型：指出MAC的数据应该交往上层的哪个协议处理</li><li>数据的大小范围为46B-1500B：46B的下限是最小帧长64B - 头尾加起来18B；最大为MTU = 1500B</li><li>FCS：校验码</li></ul><h3 id="无线局域网">无线局域网</h3><p><img src="https://img.lishangcc.top//img/image-20220828234950606.png" alt="image-20220828234950606"></p><blockquote><p>如：A给B发送数据，A靠近AP1基站，B靠近AP2基站</p><p>地址1：MAC（AP2）</p><p>地址2：MAC（AP1）</p><p>地址3：MAC（B）</p><p>地址4：MAC（A）</p></blockquote><h2 id="广域网">广域网</h2><p>广域网的通信子网主要使用<code>分组交换技术</code>；</p><h3 id="PPP协议（点对点）">PPP协议（点对点）</h3><p>只支持<code>全双工链路</code>；</p><blockquote><p>PPP协议<code>不需要支持</code>：①纠错（注意不是检错）；②流量控制；③序号；④多点线路；</p></blockquote><p><strong>三个组成部分</strong>：</p><ol><li>一个将IP数据报封装到串行链路的方法；</li><li>链路控制协议LCP：建立并维护数据链路连接；</li><li>网络控制协议NCP：每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接；</li></ol><p><strong>PPP协议帧格式</strong></p><p><img src="https://img.lishangcc.top//img/image-20220829002607680.png" alt="image-20220829002607680"></p><h2 id="链路层设备">链路层设备</h2><h3 id="交换机">交换机</h3><p>1.它能够检测数据帧的源地址和目的地址的MAC地址，然后与它的查找表进行比较，若不在源地址查找表中，则将该地址加入查找表中，（自学习）并且将数据帧发送给相应的目的端口；</p><p>2.若带宽为10Mb/s，拥有N个端口的交换机的总容量为N * 10 Mb/s（独占传输媒体带宽）；</p><p>3.交换机隔离冲突域，不隔离广播域；</p><p><strong>两种方式</strong></p><p>1.<code>直通式交换机</code>：只检查目的地址（6B）就立即转发，延迟低，但可靠性低，无法支持不同速率的端口交换；</p><p>2.<code>存储转发式交换机</code>：将帧存入高速缓存，并检查是否正确，可靠性高，可以支持不同速率的端口交换，但延迟高；</p><p><strong>自学习功能</strong></p><p><img src="https://img.lishangcc.top//img/image-20220829000724338.png" alt="image-20220829000724338"></p><blockquote><p>初始状态转发表为空：</p><ol><li>A给B传输数据，交换机会查找自己的转发表中是否有B的MAC地址，然后将该帧的源地址A和端接口1写入转发表，并向除接口1外的所有接口广播这个帧；</li><li>CD接收后因为目的地址不对，直接丢弃，故只有B收到；</li><li>转发表中写入（A，1）后，所有目的地址为A的帧都直接从接口1转发；</li></ol></blockquote><p><img src="https://img.lishangcc.top//img/image-20220829000936776.png" alt="image-20220829000936776"></p><blockquote><p><code>冲突域</code>：在同一个冲突域中的每一个节点都能收到所有被发送的帧。简单的说就是<code>同一时间内只能有一台设备发送信息的范围</code>；</p><p><code>广播域</code>：网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说如果<code>站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域</code>；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 物理层</title>
      <link href="/myblog/2022/08/26/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2022-08-26-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/myblog/2022/08/26/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2022-08-26-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="物理层基本概念">物理层基本概念</h2><p>主要解决如何在连接各种计算机的传输媒体上<code>传输数据比特流</code>，而不是指具体的传输媒体；</p><p>主要任务：确定与传输媒体接口有关的一些特性（定义标准）；</p><h3 id="物理层接口特性">物理层接口特性</h3><p><code>机械特性</code>：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况；</p><p><code>电气特性</code>：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制；</p><p><code>功能特性</code>：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途；</p><p><code>规程特性</code>：定义各条物理线路的工作规程和时序关系；</p><h3 id="数据通信模型">数据通信模型</h3><p><img src="https://img.lishangcc.top//img/image-20220826113521336.png" alt="image-20220826113521336"></p><h3 id="数据通信基础知识">数据通信基础知识</h3><p><code>通信的目的</code>：传送消息（消息：语音、文字、图像等）；</p><p><code>信号</code>：数据的电气/电磁表现，是数据在传输过程中的存在形式；</p><p><img src="https://img.lishangcc.top//img/image-20220826113948612.png" alt="image-20220826113948612"></p><p><strong>单工/半双工/全双工</strong></p><ul><li><code>单工</code>：单方向的通信，仅需要一条信道（如：广播，只有你在说话）；</li><li><code>半双工</code>：双方都可以发送或接收消息，但任何一方不能同时发送和接收消息，需要两条信道（如：对讲机）；</li><li><code>全双工</code>：双方可以同时发送和接收消息，需要两条信道（如：打电话）；</li></ul><p><strong>串行/并行</strong></p><ul><li><p><code>串行</code>：如一个字符的8位二进制数按由低位到高位的顺序依次发送，一条信道；</p><p><img src="https://img.lishangcc.top//img/image-20220826115044386.png" alt="image-20220826115044386"></p><blockquote><p>特点：速度慢，费用低，适合远距离；</p></blockquote></li><li><p><code>并行</code>：一个字符的8位二进制数同时通过8条信道发送；</p><p><img src="https://img.lishangcc.top//img/image-20220826115025561.png" alt="image-20220826115025561"></p><blockquote><p>特点：速度快，费用高，适合近距离；</p></blockquote></li></ul><p><strong>同步/异步</strong></p><ul><li><p><code>同步</code>：数据的传送以一个<code>数据区块</code>为单位，传送数据时，先送出<code>1个或多个同步字符SYN</code>，在送出整批数据；</p><p><img src="https://img.lishangcc.top//img/image-20220826124134303.png" alt="image-20220826124134303"></p></li><li><p><code>异步</code>：传送数据时，加一个字符起始位和一个字符终止位；</p><p><img src="https://img.lishangcc.top//img/image-20220826124334349.png" alt="image-20220826124334349"></p></li></ul><p><strong>码元</strong></p><p>指用一个<code>固定时长的信号波形</code>（数字脉冲），时长内的信号称为<code>k进制码元</code>(离散状态有M个，即M进制码元)，该时长称为<code>码元宽度</code>；</p><p>不同进制的码元区别在于携带多少信息量——2进制（1bit）：0,1；4进制（2bit）：00,01,10,11；</p><p><strong>数据传输速率</strong></p><p>两种表示方法：①码元传输速率；②信息传输速率；</p><p><code>1.码元传输速率（1s传输多少个码元）</code></p><p>单位时间内传输的码元个数（脉冲个数或信号变化次数），单位：波特（Baud）；</p><p><code>2.信息传输速率（1s传输多少个比特）</code></p><p>单位时间内传输比特数，单位：比特/秒（b/s）；</p><blockquote><p>两者关系：信息传输速率 = 码元传输速率 × 一个码元携带信息量；</p></blockquote><p><strong>带宽</strong></p><ol><li>模拟信号系统中，最高频率和最低频率的差值为系统的通频带宽，单位：赫兹（Hz）；</li><li>数字设备中，从一点到另一点所通过的最高数据率（单位时间内通过链路的数量），单位：比特/秒（bps）</li></ol><blockquote><p>更宽的带宽拥有更大的信息运送能力；</p></blockquote><h2 id="奈氏准则和香浓定理">奈氏准则和香浓定理*</h2><p><strong>失真</strong></p><p><img src="https://img.lishangcc.top//img/image-20220826155108308.png" alt="image-20220826155108308"></p><blockquote><p>失真程度影响因素：1.码元传输速率；2.信号传输距离；3.噪声干扰；4.传输媒体质量；</p></blockquote><p><strong>码间串扰</strong>：接收端收到的信号波形失去了码元之间清晰界限的现象；</p><h3 id="奈氏准则">奈氏准则</h3><p>在理想低通（无噪声、带宽受限）条件下，为避免码间串扰，极限码元传输速率为2W Baud（W是信道带宽，单位Hz）；<br>$$<br>C_\max=2W\log_2V (bps)<br>$$</p><blockquote><p>W——带宽（Hz）；V——每个码元离散电平数目（如：码元有16种状态，即16进制信号，需要4个二进制位，V=16）；</p></blockquote><p>结论：</p><ol><li>任何信道中，码元传输的速率是有上限的；</li><li>信道的频带越宽，就可以用更高的速率进行码元的有效传输；</li><li>奈氏准则仅给出了码元传输速率的限制，并没有对信息传输速率给出限制（所以要提高数据传输速率，尽可能使每个码元携带更多信息量）；</li></ol><blockquote><p>例：在无噪声情况下，某通信链路的带宽为3kHz，采用4个相位，每个相位具有4中振幅的QAM调制技术，则该通信链路的最大数据传输率是多少？</p><p>答：信号有4×4=16种变化，最大数据传输率 = 2 × 3k × 4 = 24 kb/s；</p></blockquote><h3 id="香农定理">香农定理</h3><p>在带宽受限、有噪声的信道中，为不产生误差，信息的数据传输率有上限值；<br>$$<br>信噪比(dB) = 10\log_{10}(S/N)<br>$$</p><p>$$<br>信道的极限数据传输速率=Wlog_2(S/N)<br>$$</p><blockquote><p>W：带宽（Hz）</p></blockquote><p>结论：</p><ol><li>带宽或信噪比越大，信息极限传输速率越高；</li><li>信息传输速率 &lt; 极限信息传输速率，一定能实现差错传输；</li><li>实际信道达到的传输速率要比极限的低很多；</li></ol><blockquote><p>例：电话系统的信道带宽为3000Hz，信噪比为30dB，则该系统的最大数据传输速率是多少？</p><p>答：</p><p><img src="https://img.lishangcc.top//img/image-20220826161816035.png" alt="image-20220826161816035"></p></blockquote><h3 id="两者对比">两者对比</h3><p><img src="https://img.lishangcc.top//img/image-20220826161857294.png" alt="image-20220826161857294"></p><blockquote><p>答题时，若没给信噪比必用奈氏准则，若给了可以两个都算一下，最终速率取最小的；</p><p><img src="https://img.lishangcc.top//img/image-20220826180052602.png" alt="image-20220826180052602"></p></blockquote><h2 id="编码和调制">编码和调制</h2><p><code>基带信号</code>：将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）；</p><p><code>宽带信号</code>：将基带信号进行调制后形成的频分复用模拟信号，再送到模拟信道上传输（宽带传输）；</p><p>传输距离近，采用基带传输方式（衰减小）；</p><p>传输距离远，采用宽带传输方式（衰减大）；</p><p><img src="https://img.lishangcc.top//img/image-20220826201940468.png" alt="image-20220826201940468"></p><h3 id="数字数据编码为数字信号">数字数据编码为数字信号</h3><p><img src="https://img.lishangcc.top//img/image-20220826222532321.png" alt="image-20220826222532321"></p><ul><li>归零编码（RZ）：每个码元都要恢复到零；</li><li>非归零编码（NRZ）：高1低0；</li><li>反向非归零编码（NRZI）：碰0翻转，碰1不变；</li><li>曼彻斯特编码：前高后低为1，前低后高为0（也可以相反）（数据传输速率只有调制速率的1/2，即一个时钟周期只有1bit，但是有2个码元(或脉冲个数)）；</li><li>差分曼彻斯特编码：差分曼彻斯特编码：数据为1，则前半个码元的电平和上个码元后半个电平相同；若数据为0，则相反；</li></ul><h3 id="数字数据调制为模拟信号">数字数据调制为模拟信号</h3><p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号；</p><p><img src="https://img.lishangcc.top//img/image-20220826224522652.png" alt="image-20220826224522652"></p><blockquote><p>例：某通信链路的波特率是1200Baud，采用4个相位，每个相位有4种振幅的QAM调制技术，则该链路的信息传输速率是多少？</p><p>答：</p><p>调幅+调相所产生的不同种类的码元个数 = 相位数 × 振幅数；</p><p>4×4=16种，需要4bit，1200×4=4800 b/s；</p></blockquote><h3 id="模拟数据编码为数字信号">模拟数据编码为数字信号</h3><p><img src="https://img.lishangcc.top//img/image-20220826225138669.png" alt="image-20220826225138669"></p><h2 id="数据交换方式">数据交换方式</h2><h3 id="电路交换">电路交换</h3><p>发送端和接收端<code>必须建立</code>一条专有的物理通信路径，这条路径在数据传输结束前一直保持；</p><p><img src="https://img.lishangcc.top//img/image-20220826230039690.png" alt="image-20220826230039690"></p><p>三个阶段：建立连接→数据传输→释放连接；</p><p><strong>优点</strong>：</p><ol><li><p>传输时延小，实时性强（专有线路，适用交互式会话类通信）</p></li><li><p>数据顺序传输，无失序问题</p></li><li><p>全双工</p></li><li><p>适用模拟信号和数字信号</p></li><li><p>交换设备和控制简单</p></li></ol><p><strong>缺点</strong>：</p><ol><li><p>建立时间长</p></li><li><p>信道使用率低（线路独占，即使空闲，别人也不能使用）</p></li><li><p>灵活性差，任何一点出故障必须重新建立连接（不适用突发性通信）</p></li><li><p>无数据存储能力</p></li><li><p>无法进行差错控制</p></li></ol><h3 id="报文交换">报文交换</h3><p>无需在两个站点之间建立一条专用通路，其数据传输单位：报文，传送过程采用<code>存储转发</code>方式；</p><p><img src="https://img.lishangcc.top//img/image-20220826230235016.png" alt="image-20220826230235016"></p><p><strong>优点</strong>：</p><ol><li><p>无需建立连接。（相对于电路交换）</p></li><li><p>动态分配线路。选择当前最佳路径（相对于电路交换）</p></li><li><p>提高可靠性。任何一点出问题，可以重新选择路径（相对于电路交换）</p></li><li><p>提高线路利用率。非独占线路（相对于电路交换）</p></li><li><p>多目标服务。一个报文可以发送给多个目的地址（相对于电路交换）</p></li></ol><p><strong>缺点</strong>：</p><ol><li><p>实时性差（存储转发导致转发时延，甚至有可能排队等待）</p></li><li><p>只适用数字信号</p></li><li><p>由于报文没有长度限制，因此，需要大量的缓存空间</p></li></ol><h3 id="分组交换">分组交换</h3><blockquote><p>分组：大多数计算机网络不能连续的传送任意长的数据，实际上网络系统会把数据分割成小块，然后逐块发送，这种小块称为分组；</p></blockquote><p>分组交换与报文交换的工作方式基本相同，都采用<code>存储转发</code>方式，主要差别在于，分组交换网中要限制所传输的数据单位的长度，一般选128B。发送节点首先对从终端设备送来的数据报文进行接收存储，而后将报文划分成一定长度的分组，并以分组为单位进行传输和交换。接收结点将收到的分组组装成信息或报文。</p><p><img src="https://img.lishangcc.top//img/image-20220826230634124.png" alt="image-20220826230634124"></p><p><strong>优点</strong>：</p><ol><li><p>无需建立连接（相对于电路交换）</p></li><li><p>信道利用率高（相对于电路交换）</p></li><li><p>简化存储管理（相对于报文交换，限制数据最大长度）</p></li><li><p>加速传输（相对于报文交换）：对于两个分组来说，存储和转发是可以同时进行的；并且分组一般小于报文，其所需的发送等待时间也更小</p></li><li><p>减小出错概率和重发量（相对于报文交换）：分组较小，提高可靠性</p></li><li><p>传播时延低，适用突发式通信</p></li></ol><p><strong>缺点</strong>：</p><ol><li>存在传输时延。即使相交于报文交换已经大大降低，但是仍然比不上电路交换</li><li>需要传输额外信息量。每个分组都要有目的地址、源地址和编号等控制数据</li><li>采用数据报可能会失序、丢失等；采用虚电路，会有呼叫建立、数据传输和虚电路释放三个过程</li></ol><h3 id="数据报与虚电路（分组交换）">数据报与虚电路（分组交换）</h3><p><strong>数据报方式</strong></p><p><img src="https://img.lishangcc.top//img/image-20220827114821137.png" alt="image-20220827114821137"></p><p>特点：</p><ol><li><p>数据报方式为网络层提供无连接服务；</p><blockquote><p>无连接服务：不事先为分组的传输确定路径；</p></blockquote></li><li><p>每个分组在传输过程中必须携带源地址、目的地址、分组号；</p></li><li><p>分组在交换结点存储转发时，需要排队等待处理，会产生一定的时延；</p></li><li><p>交换结点可以根据情况丢弃部分分组；</p></li><li><p>网络具有冗余路径，当某一交换结点或一段链路出现故障，可更新转发表另寻一条路径转发；</p></li></ol><p><strong>虚电路方式</strong></p><p><img src="https://img.lishangcc.top//img/image-20220827124024891.png" alt="image-20220827124024891"></p><p>特点：</p><ol><li><p>虚电路为网络层提供连接服务，源节点和目的节点之间建立一条逻辑连接，而非物理连接；</p><blockquote><p>连接服务：为分组确定传输路径（建立连接），传输结束后拆除连接；</p></blockquote></li><li><p>分组不需要携带源地址、目的地址等信息，仅携带虚电路号，减小开销；</p></li><li><p>不会发生乱序、重复、丢失的问题；</p></li><li><p>分组通过每个节点时，只进行差错检测，不进行路由选择（建立连接时需要路由选择）；</p></li><li><p>每个节点可能与多个节点之间建立多条虚电路，但每条虚电路仅支持特定的两个端系统之间的数据传输；</p></li></ol><p><strong>两者对比</strong></p><p><img src="https://img.lishangcc.top//img/image-20220827124814571.png" alt="image-20220827124814571"></p><h3 id="数据交换方式的选择">数据交换方式的选择</h3><ul><li>传送数据量大，且传送时间远大于呼叫时间——电路交换；</li><li>端到端有很多段链路——分组交换；</li><li>考虑信道利用率——分组交换；</li></ul><p><img src="https://img.lishangcc.top//img/image-20220826231105894.png" alt="image-20220826231105894"></p><h2 id="物理层传输介质">物理层传输介质</h2><p><strong>1.双绞线</strong></p><p>由两根采用一定规则并绞合的、相互绝缘的铜导线组成（绞合以减少相邻导线的电磁干扰）；</p><p><img src="https://img.lishangcc.top//img/image-20220826231614544.png" alt="image-20220826231614544"></p><p><strong>2.同轴电缆</strong></p><p>由<code>导体铜质芯线</code>、<code>绝缘层</code>、<code>网络编织屏蔽层</code>、<code>塑料外层</code>构成；</p><p><img src="https://img.lishangcc.top//img/image-20220826231820359.png" alt="image-20220826231820359"></p><p><strong>3.光纤</strong></p><p>光纤通信就是利用光导纤维（简称光纤）传递<code>光脉冲</code>来进行通信。有光脉冲表示1，无光脉冲表示0，而可见光的频率大约是10^8MHz，因此光纤通信系统的带宽远远大于目前其他各种传输媒体的带宽。</p><p>光纤主要由<code>纤芯（实心的）</code>和<code>包层</code>构成，光波通过纤芯进行传导，包层较纤芯有较低的折射率。</p><p><img src="https://img.lishangcc.top//img/image-20220826232113425.png" alt="image-20220826232113425"></p><h2 id="物理层设备">物理层设备</h2><h3 id="中继器">中继器</h3><p>对信号进行再生和还原，对衰减的信号进行放大，保持和原数据相同，以增加信号传输的距离，延长网络长度；</p><blockquote><p>线路上的信号功率会衰减，衰减到一定程度会失真，所以需要再生和还原；</p></blockquote><h3 id="集线器">集线器</h3><p>对信号进行<code>再生放大转发</code>，对衰减的信号进行放大，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。</p><blockquote><p>注意：</p><p>其不具备信号的定向传送能力，是一个共享式设备；</p><p>集线器不能分割冲突域；</p><p>连在集线器上的工作主机平分带宽；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 计算机网络体系结构</title>
      <link href="/myblog/2022/08/25/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2022-07-01-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/myblog/2022/08/25/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2022-07-01-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。</p></blockquote><h2 id="计算机网络概述">计算机网络概述</h2><h3 id="计算机网络的功能">计算机网络的功能</h3><ul><li>数据通信</li><li>资源共享</li><li>分布式处理：多台计算机各自承担同一工作任务的不同部分；如：Hadoop平台；特点：提高可靠性，负载均衡；</li><li>等等……</li></ul><h3 id="计算机网络的组成">计算机网络的组成</h3><p><strong>组成部分</strong>：硬件、软件、协议（一系列规则和约定的集合）；</p><p><strong>工作方式</strong>：</p><p>边缘部分：C/S方式（Client / Server）、P2P方式（Peer-to-Peer，对等的连接，即所有端系统同时是客服端也是服务端）；</p><p>核心部分： 为边缘部分服务；</p><p><strong>功能组成</strong>：</p><p>通信子网：实现数据通信；</p><p>资源子网：实现资源共享/数据处理；</p><p><img src="https://img.lishangcc.top//img/image-20220702212755398.png" alt="image-20220702212755398"></p><h3 id="计算机网络的分类">计算机网络的分类</h3><p><strong>按分布范围分</strong></p><ul><li>广域网WAN（交换技术（通过路由器等中间设备转发出去））</li><li>城域网MAN</li><li>局域网LAN（广播技术（简单理解喊一声就听见））</li><li>个人区域网PAN</li></ul><p><strong>按使用者分</strong></p><ul><li>公用网</li><li>专用网</li></ul><p><strong>按交换技术分</strong></p><ul><li>电路交换：会独占资源，想想电话占线；</li><li>报文交换：存储转发机制，不会独占资源；</li><li>分组交换：存储转发机制，不会独占资源；</li></ul><p><strong>按拓补结构分</strong></p><ul><li>总线型</li><li>星型</li><li>环形</li><li>网状型</li></ul><p><img src="https://img.lishangcc.top//img/image-20220702213916724.png" alt="image-20220702213916724"></p><p><strong>按传输技术分</strong></p><ul><li>广播式网络：共享公共通信信道；</li><li>点对点网络：使用分组存储转发和路由选择机制；</li></ul><blockquote><p>区别：是否使用存储转发机制；</p></blockquote><h3 id="计算机网络标准化工作">计算机网络标准化工作</h3><p>要实现不同厂商、软件之间相互连通，必须遵从统一标准；</p><p><strong>法定标准</strong>：有权威机构制定的正式的、合法的标准；如：OSI；</p><p><strong>事实标准</strong>：某些公司的产品在竞争中占据了主流，这些产品的协议和技术久而久之就成了标准；如：TCP/IP；</p><p><strong>相关组织</strong>：</p><ul><li>国际标准化组织ISO</li><li>国际电信联盟ITU</li><li>电气和电子工程师协会IEEE</li><li>Internet工程任务组IETF</li></ul><h2 id="性能指标">性能指标</h2><p><strong>1.速率</strong></p><p>即<code>数据率</code>or<code>数据传输率</code>or<code>比特率</code>；</p><p>单位：b/s，kb/s，Mb/s，Gb/s，Tb/s；（相互间的换算倍数为1000）；</p><p><strong>2.带宽</strong></p><p>带宽用来表示网络的通信线路<code>传送数据的能力</code>，通常是指单位时间内从网络中的某一点到另一点所能通过的“<code>最高数据率</code>”，单位为“比特 / 秒”；</p><p><strong>3.吞吐量</strong></p><p>单位时间内通过某个网络（或信道、接口）的数据量，单位：b/s，kb/s，Mb/s；</p><blockquote><p>吞吐量受网络的带宽或网络的额定速率的限制；</p></blockquote><p><strong>4.时延</strong></p><p>数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间，也叫<code>延迟</code>或<code>迟延</code>；</p><p><strong>5.时延带宽积</strong></p><p>时延带宽积 = 传播时延 × 带宽；</p><blockquote><p>时延带宽积又称：比特为单位的链路长度；</p></blockquote><p><strong>6.往返时延RTT</strong></p><p>从发送方<code>发放数据开始</code>，到发送方收到<code>接收方的确认</code>（接收方收到数据立即发送确认）所经历的时间；</p><p><img src="https://img.lishangcc.top//img/image-20220826010024063.png" alt="image-20220826010024063"></p><p><strong>7.利用率</strong></p><p><img src="https://img.lishangcc.top//img/image-20220826010117624.png" alt="image-20220826010117624"></p><h2 id="网络体系结构">网络体系结构</h2><h3 id="网络分层结构">网络分层结构</h3><blockquote><p>为什么要分层，分层以解决下列各种复杂的网络问题；</p><p><img src="https://img.lishangcc.top//img/image-20220824231356191.png" alt="image-20220824231356191"></p></blockquote><p><strong>分层的基本原则</strong></p><ol><li>各层之间相互独立，每层只实现一种相对独立的功能；</li><li>每层之间界面自然清晰，易于理解，相互交流尽可能少；</li><li>结构上可分割开，每层都采用最合适的技术实现；</li><li>保持下层对上层的独立性，上层单向使用下层提供的服务；</li></ol><p><strong>分层结构概念</strong></p><ol><li><p>实体：第n层中的活动元素称为n层实体，同一层实体叫对等实体；</p></li><li><p>协议：为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议；（体现在水平方向上）</p><blockquote><p>语法：规定传输数据的格式；</p><p>语义：规定所要完成的功能；</p><p>同步：规定各种操作的顺序；</p></blockquote></li><li><p>接口：上层使用下层服务的入口；</p></li><li><p>服务：下层为相邻上层提供的功能调用（体现在垂直方向上）；</p></li><li><p>SDU服务数据单元：为完成用户所要求的的功能而传送的数据；</p></li><li><p>PCI协议控制信息：控制协议操作的信息；</p></li><li><p>PDU协议数据单元：对等层次之间传送的数据单元；</p><blockquote><p>在各个层次中，每个报文都分为两部分：数据部分SDU，控制信息部分PCI；共同组成PDU；</p><p>PDU往往作为下一层的SDU；</p></blockquote></li></ol><p><strong>分层结构</strong></p><ol><li><code>OSI参考模型</code>（7层，法定标准）</li><li><code>TCP/IP参考模型</code>（4层，事实标准）</li></ol><h3 id="OSI参考模型">OSI参考模型</h3><p><strong>解释通信过程</strong></p><p><img src="https://img.lishangcc.top//img/image-20220825001604368.png" alt="image-20220825001604368"></p><blockquote><p>理解一下：</p><p>上面四层端到端：一个快递，里面的内容也就只有卖家和买家可以看到；</p><p>下面三层点到点：快递需要一个点一个点的运送，中间的点并不知道快递中的具体信息；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220825001704081.png" alt="image-20220825001704081"></p><h4 id="应用层">应用层</h4><p>所有能和用户交互产生网络流量的程序（连上网才可以使用的程序）；</p><p>典型应用层服务：文件传输（FTP），电子邮件（SMTP），万维网（HTTP）；</p><h4 id="表示层">表示层</h4><p>用于处理在两个通信系统中交换信息的表示方式（语法和语义）；</p><p><strong>主要功能</strong>：</p><ol><li>数据格式转换；</li><li>数据加密解密；</li><li>数据压缩和恢复；</li></ol><h4 id="会话层">会话层</h4><p>向表示层实体/用户进程提供建立连接，并在连接上有序的传输数据；</p><blockquote><p>理解一下，打电话首先得对方得接通，从而建立连接，这时才可以开始对话；</p></blockquote><p><strong>主要功能</strong>：</p><ol><li>建立、管理、终止会话；</li><li>使用校验点可使会话在通信失效时从校验点/同步点恢复通信，实现数据同步；（适用于传输大文件）</li></ol><h4 id="传输层">传输层</h4><p>负责主机中两个进程的通信，即端到端的通信，传输单位是<code>报文段</code>或<code>用户数据报</code>；</p><p><strong>主要功能</strong>：</p><ol><li><p>可靠传输、不可靠传输；</p></li><li><p>差错控制；</p></li><li><p>流量控制；</p><blockquote><p>解决速度匹配的问题；</p></blockquote></li><li><p>复用分用；</p><blockquote><p>复用：多个应用层进程可同时使用下面运输层的服务；</p><p>分用：运输层把收到的信息分别交付给上面应用层中相应的进程；</p></blockquote></li></ol><p><strong>主要协议</strong>：TCP、UDP；</p><h4 id="网络层">网络层</h4><p>把分组从源端传输到目的端，为分组交换网上的不同主机提供通信服务；网络层传输单位是<code>数据报</code>；</p><p><strong>主要功能</strong>：</p><ol><li><p>路由选择；</p></li><li><p>流量控制；</p></li><li><p>差错控制；</p></li><li><p>拥塞控制；</p><blockquote><p>若所有结点都来不及接受分组，从而要丢弃大量分组的话，网络就处于拥塞状态；</p></blockquote></li></ol><p><strong>主要协议</strong>：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF；</p><h4 id="数据链路层">数据链路层</h4><p>主要任务是把网络层传下来的数据报组装成帧；数据链路层传输单位是<code>帧</code>；</p><p><strong>主要功能</strong>：</p><ol><li>成帧（定义帧的开始和结束）；</li><li>差错控制；</li><li>流量控制；</li><li>访问（接入）控制；</li></ol><p><strong>主要协议</strong>：SDLC、HDLC、PPP、STP；</p><h4 id="物理层">物理层</h4><p>主要任务是在物理媒体上实现比特流的透明传输；物理层的传输单位是<code>比特</code>；</p><p>透明传输：指不管所传数据是什么样的比特组合，都应到能够在链路上传送；</p><p><strong>主要功能</strong>：</p><ol><li>定义接口特性；</li><li>定义传输模式（单工、半双工、双工）；</li><li>定义传输速率；</li><li>比特同步；</li><li>比特编码；</li></ol><p><strong>主要协议</strong>：Rj45、802.3；</p><h3 id="TCP-IP参考模型">TCP/IP参考模型</h3><p>四层：应用层、传输层、网际层、网络接口层；</p><p><strong>OSI与TCP/IP相同点</strong></p><ul><li>都分层；</li><li>基于独立的协议栈的概念；</li><li>都可以实现异构网络互联；</li></ul><p><strong>OSI与TCP/IP不同点</strong></p><ul><li><p>OSI定义三点：服务、协议、接口；</p></li><li><p>TCP/IP将IP作为重要层次；</p></li><li><p>OSI：网络层——无连接+面向连接；传输层——面向连接；</p></li><li><p>TCP/IP：网络层——无连接；传输层——无连接+面向连接；</p><blockquote><p>面向连接：建立连接→传输数据→释放连接；</p><p>无连接：没有那么多阶段，直接进行数据传输；</p></blockquote></li></ul><h3 id="五层参考模型">五层参考模型</h3><p>为方便教学和理解所产生的模型，综合了OSI和TCP/IP两种模型的优点；</p><p><img src="https://img.lishangcc.top//img/image-20220826004748713.png" alt="image-20220826004748713"></p><p><strong>解释通信过程</strong></p><p><img src="https://img.lishangcc.top//img/image-20220826004902045.png" alt="image-20220826004902045"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 文件管理</title>
      <link href="/myblog/2022/08/18/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-08-18-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/myblog/2022/08/18/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-08-18-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="文件系统的概念">文件系统的概念</h2><h3 id="文件的属性">文件的属性</h3><ul><li><code>文件名</code>：由创建文件的用户决定文件名，主要是为了方便用户找到文件；</li><li><code>标识符</code>：一个系统内的各文件标识符唯一，但对用户毫无可读性；</li><li><code>类型</code>：指明文件类型；</li><li><code>位置</code>：文件存放的路径；</li><li><code>大小</code>：文件大小；</li><li><code>保护信息</code>：对文件进行保护的访问控制信息；</li><li><code>创建时间</code></li><li><code>上次修改时间</code></li><li><code>文件所有者信息</code></li></ul><h3 id="文件的逻辑结构">文件的逻辑结构</h3><p>按逻辑结构，文件可划分为：无结构文件、有结构文件；</p><p><img src="https://img.lishangcc.top//img/image-20220818210953047.png" alt="image-20220818210953047"></p><p><strong>①无结构文件（流式文件）</strong></p><p><img src="https://img.lishangcc.top//img/image-20220818211209037.png" alt="image-20220818211209037"></p><p><strong>②有结构文件（记录式文件）</strong></p><p><img src="https://img.lishangcc.top//img/image-20220818211407417.png" alt="image-20220818211407417"></p><h3 id="操作系统向上提供的功能">操作系统向上提供的功能</h3><ul><li>创建文件（create系统调用）</li><li>删除文件（delete系统调用）</li><li>读文件（read系统调用）</li><li>写文件（write系统调用）</li><li>打开文件（open系统调用）</li><li>关闭文件（close系统调用）</li></ul><h2 id="文件的逻辑结构-2">文件的逻辑结构</h2><p><code>无结构文件</code>：文件内部的数据就是一系列二进制流或字符流组成，又称流式文件，如txt文本文件；</p><p><code>有结构文件</code>：由一组相似的记录组成，又称记录式文件，每条记录又由若干个数据项组成，如数据库表文件；根据每条记录的长度是否相等，又分为定长记录和可变长记录；</p><p><img src="https://img.lishangcc.top//img/image-20220818212419322.png" alt="image-20220818212419322"></p><h3 id="顺序文件">顺序文件</h3><p>文件中的记录一个接一个的顺序排列，记录是定长或可变长的，各个记录在物理上可以顺序存储或链式存储；</p><p><img src="https://img.lishangcc.top//img/image-20220818213340255.png" alt="image-20220818213340255"></p><p><img src="https://img.lishangcc.top//img/image-20220818213534997.png" alt="image-20220818213534997"></p><blockquote><p>定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取，若能再保证记录的顺序结构，则可实现快速检索（根据关键字快速找到对应记录）；</p></blockquote><h3 id="索引文件">索引文件</h3><p>索引表：定长记录的顺序文件，因此可以快速找到第i个记录对应的索引项；</p><p><img src="https://img.lishangcc.top//img/image-20220818224837028.png" alt="image-20220818224837028"></p><blockquote><p>缺点：每个记录对应一个索引表项，因此索引表可能会很大，比如：文件的每个记录平均只占8B，而每个索引表项占32B，那么索引表都比文件内容本身大4倍；</p></blockquote><h3 id="索引顺序文件">索引顺序文件</h3><p>索引顺序文件是索引文件和顺序文件思想的结合，同样是建立一张索引表，不同的是，一组记录会对应一个索引表项；</p><p><img src="https://img.lishangcc.top//img/image-20220818225304762.png" alt="image-20220818225304762"></p><blockquote><p>索引顺序文件VS顺序文件：</p><ul><li>若顺序文件有10000个记录，则根据关键字检索文件，只能从头开始顺序查找，平均查找5000次；</li><li>采用索引顺序结构，把10000个记录分为100组，每组100个记录，平均查找次数为50+50=100次；</li></ul></blockquote><h3 id="多级索引顺序文件">多级索引顺序文件</h3><p><img src="https://img.lishangcc.top//img/image-20220818225640562.png" alt="image-20220818225640562"></p><p><img src="https://img.lishangcc.top//img/image-20220818225711682.png" alt="image-20220818225711682"></p><p><strong>总结</strong></p><p><img src="https://img.lishangcc.top//img/image-20220818225843261.png" alt="image-20220818225843261"></p><h2 id="文件的物理结构">文件的物理结构</h2><h3 id="连续分配">连续分配</h3><p>要求每个文件在磁盘上占有一组连续的块；</p><p><img src="https://img.lishangcc.top//img/image-20220819001041053.png" alt="image-20220819001041053"></p><p>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快；</p><p>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片；</p><h3 id="链接分配——隐式链接">链接分配——隐式链接</h3><p>除文件的最后一个磁盘块外，每个盘块中都存有指向下一个盘块的指针，文件目录包括文件第一块的指针和最后一块的指针；</p><p><img src="https://img.lishangcc.top//img/image-20220819001313196.png" alt="image-20220819001313196"></p><p>优点：方便文件拓展；不会产生碎片问题；</p><p>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间；</p><h3 id="链接分配——显示链接">链接分配——显示链接</h3><p>把用于链接文件各物理块的指针，从每个物理块的末尾提取出来，显示存放在一张链表中，该表在磁盘中仅设置一张，称为<code>文件分配表（FAT）</code>；</p><p><img src="https://img.lishangcc.top//img/image-20220819002021876.png" alt="image-20220819002021876"></p><blockquote><p>如：aaa依次存放在磁盘块2—5—0—1；</p></blockquote><p>优点：方便文件拓展，不会有碎片问题，并且支持随机访问，相比于隐式，地址转换不需要访问磁盘，因此文件访问效率更高；</p><p>缺点：文件分配表需要占用一定的存储空间；</p><h3 id="索引分配">索引分配</h3><p>允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张<code>索引表</code>，索引表<code>记录了文件的各个逻辑块对应的物理块</code>，索引表存放的磁盘块称为<code>索引块</code>，文件数据存放的磁盘块称为<code>数据块</code>；</p><p><img src="https://img.lishangcc.top//img/image-20220819155535648.png" alt="image-20220819155535648"></p><p>如：文件aaa，7号磁盘块为其索引块，其数据存放在磁盘块2—5—13—9；</p><blockquote><p>注意：索引表与显式链接方式中的文件分配表FAT不同，FAT是一个磁盘对应一张，索引表是一个文件对应一张；</p></blockquote><h4 id="链接方案">链接方案</h4><p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放；</p><p><img src="https://img.lishangcc.top//img/image-20220819161103196.png" alt="image-20220819161103196"></p><p>缺点：若文件很大，索引表很长，就需要将多个索引块链接起来，想要找到第i号索引块，必须从0开始依次读入索引块，导致磁盘I/O次数过多，查找效率低；</p><h4 id="多层索引">多层索引</h4><p>建立多层索引（类似多级页表），使第一层索引块指向第二层索引块，还可以根据文件大小再建立更多层；</p><p><img src="https://img.lishangcc.top//img/image-20220819161134528.png" alt="image-20220819161134528"></p><p>缺点：即使是小文件，访问一个数据块依然需要K+1次读磁盘；</p><h4 id="混合索引">混合索引</h4><p>多种索引分配方式的结合；</p><p><img src="https://img.lishangcc.top//img/image-20220819161209945.png" alt="image-20220819161209945"></p><p>优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少；</p><blockquote><p>考点：</p><p>①根据多层索引、混合索引的结构计算出文件的最大长度（各级索引表最大不能超过一个块）；</p><p>②分析访问某个数据块所需要的读磁盘次数（注意顶级索引块是否调入内存）；</p></blockquote><h2 id="文件存储空间管理">文件存储空间管理</h2><h3 id="空闲表法">空闲表法</h3><p>适用于连续分配方式；</p><p><img src="https://img.lishangcc.top//img/image-20220819163807273.png" alt="image-20220819163807273"></p><p><strong>如何分配磁盘块</strong></p><blockquote><p>与内存管理中的动态分区分配类似，为一个文件分配连续的存储空间；同样可以采用首次适应、最佳适应等算法决定为文件分配哪个空间；</p></blockquote><p><strong>如何回收磁盘块</strong></p><blockquote><p>也是分那四种情况，①回收区前后没有相邻空闲区；②回收区前后都是空闲区；③回收区前是空闲区；④回收区后是空闲区；</p></blockquote><h3 id="空闲链表法">空闲链表法</h3><p>分两种：空闲盘块链、空闲盘区链；</p><p><strong>空闲盘块链</strong></p><p><img src="https://img.lishangcc.top//img/image-20220819192444062.png" alt="image-20220819192444062"></p><p><strong>空闲盘区链</strong></p><p><img src="https://img.lishangcc.top//img/image-20220819192509619.png" alt="image-20220819192509619"></p><h3 id="位示图法">位示图法</h3><p><img src="https://img.lishangcc.top//img/image-20220819180528299.png" alt="image-20220819180528299"></p><p><img src="https://img.lishangcc.top//img/image-20220819180559327.png" alt="image-20220819180559327"></p><p><code>位示图</code>：每个二进制对应一个盘块，在本例中，“0”表示盘块空闲，“1”表示盘块已分配，位示图一般用连续的“字”来表示；</p><blockquote><p>本例中一个字的字长为16位，字中每一位对应一个盘块，可用（字号，位号）对应一个盘块号；</p></blockquote><p>（字号，位号）=（i，j）的二进制对应盘块号b=ni+j；（本例中，盘块号、字号、位号从0开始，n表示字长）</p><p>b盘块对应的字号：i=b/n;</p><p>对应的位号：j=b%n；</p><blockquote><p><img src="https://img.lishangcc.top//img/image-20220819193311009.png" alt="image-20220819193311009"></p></blockquote><h3 id="成组链接法">成组链接法</h3><p>UNIX系统采用该方法，适合大型文件系统，自行了解；</p><h2 id="文件目录">文件目录</h2><p>一个文件对应一个文件控制块FCB，一个FCB就是一个目录项，多个FCB组成文件目录；</p><p><img src="https://img.lishangcc.top//img/image-20220818230320132.png" alt="image-20220818230320132"></p><p><strong>对目录的操作：</strong></p><p><img src="https://img.lishangcc.top//img/image-20220818230154859.png" alt="image-20220818230154859"></p><h3 id="单级目录结构">单级目录结构</h3><p>整个文件系统中只建立一张目录表，每个文件占一个目录项；</p><p><img src="https://img.lishangcc.top//img/image-20220818230425293.png" alt="image-20220818230425293"></p><p>单级目录实现了按名存取，但是不允许文件重名；</p><p>创建一个文件时，需要先检查目录表中是否有重名文件；</p><p>该结构不适用于多用户操作系统；</p><h3 id="两级目录结构">两级目录结构</h3><p>分为主文件目录和用户文件目录；</p><p><img src="https://img.lishangcc.top//img/image-20220818230626826.png" alt="image-20220818230626826"></p><p>用户文件目录项记录该用户文件的FCB信息；</p><p>优点：提高了检索速度，解决了多用户之间文件重名的问题，文件系统可以在目录上实现访问限制；</p><h3 id="多级目录结构-树形目录结构">多级目录结构(树形目录结构)</h3><p><img src="https://img.lishangcc.top//img/image-20220818231149500.png" alt="image-20220818231149500"></p><ul><li>明显提高了对目录的检索速度和文件系统性能；</li><li>理解一下相对路径和绝对路径；</li><li>该结构不便于文件的共享；</li></ul><h3 id="无环图目录结构">无环图目录结构</h3><p>针对多级目录结构不便于实现文件共享的问题，提出该结构；</p><p><img src="https://img.lishangcc.top//img/image-20220818231745428.png" alt="image-20220818231745428"></p><p><img src="https://img.lishangcc.top//img/image-20220818231837603.png" alt="image-20220818231837603"></p><h3 id="索引结点（FCB的改进）">索引结点（FCB的改进）</h3><ul><li>除文件名之外的所有信息都放到索引结点中，每个文件对应一个索引结点；</li><li>目录项值包含文件名、索引结点指针，因此每个目录项长度大幅减小；</li><li>由于目录项长度减小，每个磁盘块可以存放更多目录项，因此检索文件时磁盘I/O次数就少了很多（看例子理解）；</li></ul><p><img src="https://img.lishangcc.top//img/image-20220818232017373.png" alt="image-20220818232017373"></p><p><img src="https://img.lishangcc.top//img/image-20220818232035398.png" alt="image-20220818232035398"></p><h2 id="文件的基本操作">文件的基本操作</h2><p><strong>创建文件（create系统调用）</strong></p><p>提供参数：</p><ol><li>所需的外存空间大小；</li><li>文件存放路径；</li><li>文件名；</li></ol><p>主要事件：</p><ol><li>在外存找到文件所需的空间；</li><li>根据文件存放路径的信息找到该目录对应的目录文件，创建该文件对应的目录项；</li></ol><p><strong>删除文件（delete系统调用）</strong></p><p>提供参数：</p><ol><li>文件存放路径；</li><li>文件名；</li></ol><p>主要事件：</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项；</li><li>根据目录项记录的信息，回收文件占用的磁盘块；</li><li>从目录表中删除文件对应的目录项；</li></ol><p><strong>读文件（read系统调用）</strong></p><p>操作系统从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中；</p><p><strong>写文件（write系统调用）</strong></p><p>操作系统会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存；</p><p><strong>打开文件（open系统调用）</strong></p><p>提供参数：</p><ol><li>文件存放路径；</li><li>文件名；</li><li>对文件的操作类型（如：r只读，rw读写）；</li></ol><p>主要事件：</p><ol><li>也是找到文件名对应的目录项，并检查该用户是否有指定的操作权限；</li><li>将目录复制到内存中的&quot;打开文件表&quot;中，并将对应表目的编号返回给用户，之后用户使用打开文件表的编号来指明操作的文件；</li></ol><p><strong>关闭文件（close系统调用）</strong></p><p>主要事件：</p><ol><li>将进程打开文件表相应的表项删除；</li><li>回收分配给该文件的内存空间等资源；</li><li>系统打开文件表的打开计数器count减1，若count=0，则删除对应表项；</li></ol><h2 id="文件系统">文件系统</h2><h3 id="文件共享">文件共享</h3><h4 id="基于索引结点的共享方式（硬链接）">基于索引结点的共享方式（硬链接）</h4><p>索引结点回顾：检索文件时可能只需用到文件名，因此将除文件名之外的信息放到索引结点中；</p><p><img src="https://img.lishangcc.top//img/image-20220819200315742.png" alt="image-20220819200315742"></p><p>索引结点中设置一个链接计数变量count，用于表示链接到本索引结点上的用户目录项数；</p><p>若count=2，说明此时有两个用户目录项链接到该索引结点上，若某个用户决定删除该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1；</p><p>若count&gt;0，说明还有别的用户使用该文件，暂时不能把文件数据删除；</p><p>若count=0，系统负责删除文件；</p><h4 id="基于符号链的共享方式（软链接）">基于符号链的共享方式（软链接）</h4><p>为使用户B能共享用户A的一个文件F，由操作系统创建一个Link类型文件，也取名F，并将该文件写入B的目录中，实现用户B的目录与文件F的链接，这个新的F文件只包含了被链接文件F的路径名；</p><p><img src="https://img.lishangcc.top//img/image-20220819214109379.png" alt="image-20220819214109379"></p><p>当user3访问ccc时，操作系统判断ccc属于Link类型文件，会根据其中记录的路径层层查找目录，最终找到user1的目录表中的aaa表项，于是就找到了文件1的索引结点；</p><h3 id="文件保护">文件保护</h3><p><strong>口令保护</strong></p><p>为文件设置一个口令，用户请求访问该文件时必须提供口令；</p><p>优点：保存口令的空间开销不多，验证口令的时间开销也很小；</p><p>缺点：正确的口令存放在系统内部，不够安全；</p><p><strong>加密保护</strong></p><p>使用某个密码对文件进行加密，在访问文件时需要提供正确的密码才能对文件进行正确的解密；</p><p>如：异或加密：</p><p><img src="https://img.lishangcc.top//img/image-20220819215022524.png" alt="image-20220819215022524"></p><p>优点：保密性强，不需要再系统中存储密码；</p><p>缺点：加密或解密需要一定的时间；</p><p><strong>访问控制</strong></p><p>在每个文件的FCB（或索引节点）中增加一个访问控制列表（ACL），该表记录各个用户可以执行哪些操作；</p><blockquote><p>如果对某个目录进行了访问权限控制，那么也要对目录下的所有文件进行相同的访问权限控制；</p></blockquote><h3 id="文件系统全局结构">文件系统全局结构</h3><p><strong>文件系统在外存中的结构</strong></p><p>探究文件系统在外存是如何一步步建立的；</p><p>①物理格式化（低级格式化）：将磁盘划分为一个个扇区，并检查该磁盘是否有坏扇区，如果有，则用备用扇区替换；（坏扇区对操作系统是透明的）</p><p><img src="https://img.lishangcc.top//img/image-20220822010454691.png" alt="image-20220822010454691"></p><p>②逻辑格式化（高级格式化）：将磁盘划分为一个个的分区（如：C盘、D盘）；</p><p><img src="https://img.lishangcc.top//img/image-20220822010718214.png" alt="image-20220822010718214"></p><blockquote><p>分区表记录每个分区的大小、起始地址、地址范围等；</p><p>每个分区可用建立独立的文件系统；</p><p>（1）引导块：负责开机时初始化操作系统</p><p>（2）超级块：找到该分区中所有空闲磁盘块</p><p>（3）与空闲分区管理有关的数据结构：例如位示图，判断某个特定的磁盘块是否空闲</p><p>（4）i结点区：i结点即索引结点，一个文件对应一个索引结点，所有索引结点连续存放在i结点区（可以理解为超大的数组，该数组元素就是索引结点）</p><p>（5）根目录：逻辑格式化后，根目录被建立；任何文件都必须从根目录出发，建立新的下一级目录</p><p>（6）灰色部分此时已经有数据，白色部分还没有数据，只有新建文件或者目录时才会有数据</p></blockquote><p><strong>文件系统在内存中的结构</strong></p><p>内存分为用户区和内核区；</p><p><code>1.目录的缓存</code>：最近访问过的目录的数据会被暂时缓存在内存中。例如：最近查找过目录M，即将目录M中的FCB都读入主存，如果接下来又访问到目录M，就无需再从外存中读入</p><p><code>2.系统打开文件表</code>：记录整个系统打开了哪些文件</p><p>①整个系统只有一张系统打开文件表</p><p>②保存每个文件对应的FCB</p><p><code>3.进程（用）户打开文件表</code>：记录该进程当前打开了哪些文件</p><p>①一个进程对应一张进程打开文件表</p><p>②进程打开文件表包含于PCB中</p><p>③进程打开文件表并不会保存FCB，但会有一个指向系统打开文件表中该文件的索引，这样就能通过该索引找到系统打开文件表中该文件对应的FCB</p><p><img src="https://img.lishangcc.top//img/image-20220822011249240.png" alt="image-20220822011249240"></p><blockquote><p>示例：通过open系统调用打开目录M中的文件A</p><p>①根据路径读入目录：在外存中找到目录M→将目录M的数据读入主存（即将目录M缓存）</p><p>②找到目标文件FCB，复制到系统打开文件表：检查目录M的FCB，即逐一对比找到文件A的FCB→复制文件A的FCB到系统打开文件表中（表示文件A被打开），同时设置打开计数为1（表示当前有1个进程正在使用文件A）</p><p>③在进程打开文件表中新建一个条目，并返回文件描述符：发起OPEN系统调用的进程的进程打开文件表中新建一个条目，该条目记录对该文件的打开方式（读/写、只读等）；返回文件描述符，即返回指向该文件在系统打开文件表的位置的指针</p><p>④OPEN系统调用打开文件后，将返回一个文件描述符，可以通过该文件描述符对打开的文件进行操作（例如：操作系统收到READ系统调用后，根据文件描述符在进程打开文件表中找到对应的条目，然后根据索引信息找到系统打开文件表中对应的条目，即找到该文件的FCB，最后根据FCB找到该文件在外存中的位置）</p></blockquote><h3 id="虚拟文件系统">虚拟文件系统</h3><h4 id="虚拟文件系统概念">虚拟文件系统概念</h4><p><code>不同的外部存储设备内部的文件系统格式可能不同</code>（如：磁盘——UFS文件系统、移动硬盘——NTFS文件系统等）；</p><p>不同的文件系统所定义的函数接口可能不同（比如：打开文件的系统调用有：open、fopen、openf等）；</p><p><img src="https://img.lishangcc.top//img/image-20220822004442931.png" alt="image-20220822004442931"></p><p><strong>虚拟文件系统特点</strong></p><ol><li><p><code>向上层用户进程提供统一标准的系统调用接口</code>，屏蔽底层具体文件系统的实现差异；</p></li><li><p>要求下层的文件系统必须实现某些规定的函数功能，如：read/open/write；</p></li><li><p>每打开一个文件，虚拟文件系统就在主存中新建一个vnode，用统一的数据结构表示文件，无论该文件存储在哪个系统；</p><blockquote><p>vnode只存于主存中，而inode即会被调入主存，也会存在外存中；</p></blockquote></li></ol><p><img src="https://img.lishangcc.top//img/image-20220822005327620.png" alt="image-20220822005327620"></p><p>不同文件系统所对应的数据结构不同（例如：FAT文件系统的目录项包含其所有信息；UFS文件系统的目录项由指向索引结点的指针组成，具体的信息存放在该索引结点中），在虚拟文件系统中，通过open系统调用打开一个文件后就会给这个文件在主存中新建一个包含该文件的所有信息的VNODE（也称V结点），即将不用的文件系统的文件信息的数据结构通过复制到VONDE的方法形成统一的数据结构</p><p>（1）VNODE只会存在于主存中（由虚拟文件系统创建），而INODE（索引结点）存放在外存中，在使用时调入主存</p><p>（2）VNODE中的函数功能指针指向的是该文件所属文件系统的函数功能列表（write、read、open等）：对该文件进行的任何操作时，先找到该文件的VNODE，根据VNODE中的函数功能指针找到对应的文件系统的函数功能列表，再去执行具体函数，从而实现从上至下逐层函数调用</p><h4 id="文件系统挂载">文件系统挂载</h4><p>即文件系统的安装，如：U盘插入电脑，U盘的文件系统就需要挂载到操作系统上（挂载到虚拟文件系统）；</p><p><strong>挂载过程</strong></p><p>①在虚拟文件系统中注册新挂载的文件系统：虚拟文件系统管理一个名为<code>挂载表</code>的数据结构，新增一个文件系统时候就要在挂载表中增加一个相应的表项，即让虚拟文件系统发现这个文件系统。例如图中的虚拟文件系统管理的挂载表中有三个表项，分别指向UFS、NTFS和FAT</p><p>②新挂载的文件系统需要向虚拟文件系统提供一个<code>函数地址列表</code>：每一个文件系统实现系统调用的方式可能不同，即告诉系统调用自己的每个系统调用存放在哪个地址（VNODE中的函数功能指针），使得虚拟文件系统能够实现这些系统调用</p><p>③将新文件系统加到挂载点：例如Windows操作系统中，插入一个U盘，在我的电脑中将会增加一个可移动硬盘H（跟C盘、D盘平级），这样才能够被我们所访问和使用</p><h2 id="磁盘">磁盘</h2><p>磁盘属于一种I/O设备，第五章会更详细也可参考组成原理第三章；</p><p><img src="https://img.lishangcc.top//img/image-20220819224726522.png" alt="image-20220819224726522"></p><p><img src="https://img.lishangcc.top//img/image-20220819224456681.png" alt="image-20220819224456681"></p><h3 id="磁盘调度算法">磁盘调度算法*</h3><p>平均存取时间 = 寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁头定位到所在扇区）+ 传输时间（传输数据所花费的时间）</p><p><strong>寻道时间Ts</strong></p><p>①启动磁头臂时间s；</p><p>②移动磁头臂的时间，假设磁头匀速移动，每跨越一个磁道耗时m，总共跨越n条磁道；</p><blockquote><p>Ts=s+m*n;</p></blockquote><p><strong>延迟时间Tr</strong></p><p>通过旋转转盘，使磁头定位到目标扇区所需要的时间，设磁盘转速为r（单位：转/秒or转/分）；</p><blockquote><p>Tr=（1/2）*（1/r）= 1/（2r）；</p></blockquote><p><strong>传输时间Tt</strong></p><p>传输数据的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N；</p><blockquote><p>Tt = (1/r) * (b/N) = b / (rN)；</p></blockquote><p><strong>平均存取时间Ta</strong></p><p><code>Ta = Ts + 1/2r + b/(rN)</code></p><h4 id="先来先服务算法（FCFS）">先来先服务算法（FCFS）</h4><p>根据进程请求访问磁盘的先后顺序进行调度；</p><p><img src="https://img.lishangcc.top//img/image-20220819230307169.png" alt="image-20220819230307169"></p><p><img src="https://img.lishangcc.top//img/image-20220819230336363.png" alt="image-20220819230336363"></p><h4 id="最短寻找时间优先（SSTF）">最短寻找时间优先（SSTF）</h4><p>优先处理的磁道是与当前磁头最近的磁道，保证每次的寻道时间最短，但并不能保证总的寻道时间最短；（贪心算法思想，眼前最优未必总体最优）</p><p><img src="https://img.lishangcc.top//img/image-20220819230520489.png" alt="image-20220819230520489"></p><p><img src="https://img.lishangcc.top//img/image-20220819230539285.png" alt="image-20220819230539285"></p><h4 id="扫描算法（SCAN）">扫描算法（SCAN）</h4><p>为解决SSTF可能产生饥饿的问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道时才能往外移动；</p><p><img src="https://img.lishangcc.top//img/image-20220819230723378.png" alt="image-20220819230723378"></p><p><img src="https://img.lishangcc.top//img/image-20220819230745113.png" alt="image-20220819230745113"></p><h4 id="LOOK调度算法">LOOK调度算法</h4><p>上述SCAN算法例子中，处理184号磁道后其实可以不再往右移动，LOOK算法就是为解决该问题；</p><p>如果在磁头移动方向上已经没有别的请求，就立即改变磁头移动方向（边移动边观察）；</p><p><img src="https://img.lishangcc.top//img/image-20220819231056592.png" alt="image-20220819231056592"></p><p>优点：比起SCAN算法，使寻道时间进一步缩短；</p><h4 id="循环扫描算法（C-SCAN）">循环扫描算法（C-SCAN）</h4><p>规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回直接快速移动至另一端位置；</p><p><img src="https://img.lishangcc.top//img/image-20220819231409379.png" alt="image-20220819231409379"></p><p>优点：比起SCAN算法，对于各个位置磁道的响应频率很平均；</p><p>缺点：只有到达最边上的磁道才能改变磁头移动方向，并且返回时实际只需要返回到18号即可，比起SCAN算法，平均寻道时间更长；</p><h4 id="C-LOOK算法">C-LOOK算法</h4><p>解决C-SCAN算法的缺点，规定，如果磁头移动的方向上已经没有请求了，可以立即让磁头返回，并且只需要返回到有访问请求的位置即可；</p><p><img src="https://img.lishangcc.top//img/image-20220819231739398.png" alt="image-20220819231739398"></p><p>优点：比起C-SCAN算法，进一步缩短寻道时间；</p><blockquote><p>本节注意：若无特别说明，SCAN就是LOOK，C-SCAN就是C-LOOK；</p></blockquote><h3 id="减少延迟时间的方法">减少延迟时间的方法</h3><p><img src="https://img.lishangcc.top//img/image-20220819232354521.png" alt="image-20220819232354521"></p><h3 id="磁盘的管理">磁盘的管理</h3><h4 id="磁盘初始化">磁盘初始化</h4><p>步骤：</p><p>①进行低级格式化（物理格式化），将磁盘的各个磁道划分扇区，一个扇区通常分为 头、数据区域、尾三个部分（头尾存一些管理扇区的数据）；</p><p>②将磁盘分区，每个分区由若干柱面组成，（即C盘、D盘这些）；</p><p>③逻辑格式化，创建文件系统，包括创建文件系统的根目录，初始化存储空间管理所用的数据结构（如：位示图、空闲分区表）；</p><h4 id="引导块">引导块</h4><blockquote><p>计算机开机时需要进行一系列初始化工作，这些工作通过初始化程序（自举程序）完成；</p></blockquote><p><code>自举装入程序</code>通常放在ROM中，ROM中的数据出厂时就写入了，并且不能再修改；</p><p><code>完整的自举程序</code>放在磁盘的启动块上，启动块位于磁盘的固定位置（拥有启动分区的磁盘称为启动磁盘or系统磁盘）；</p><p>开机时，计算机先运行<code>自举装入程序</code>，通过该程序找到引导块，将<code>完整的自举程序</code>读入内存，完成初始化；</p><h4 id="坏块的管理">坏块的管理</h4><blockquote><p>无法使用的扇区属于硬件故障，操作系统无法修复，应该将其标记处理；</p></blockquote><p>对于简单的磁盘，可以在逻辑格式化时，对整个磁盘进行坏块检查，标明哪些扇区是坏扇区（比如：在FAT表上标明），这种方式，坏块对操作系统不透明；</p><p>对于复杂的磁盘，磁盘控制器（磁盘设备的一个硬件）会维护一个坏块链表，会保留一些备用扇区用于替换坏块，这种方法称为<code>扇区备用</code>，此方法中的坏块对操作系统透明；</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 内存管理</title>
      <link href="/myblog/2022/08/15/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-08-15-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/myblog/2022/08/15/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-08-15-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="内存概念">内存概念</h2><h3 id="基础知识">基础知识</h3><p>创建进程首先要将程序和数据装入内存，将用户源程序变为可在内存中执行的程序，通常需要以下三步：</p><ol><li><code>编译</code>：由编译程序将用户源代码翻译成若干目标模块；</li><li><code>链接</code>：由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块；</li><li><code>装入</code>：有装入程序将装入模块装入内存运行；</li></ol><h4 id="三种链接方式">三种链接方式</h4><p><strong>①静态链接</strong></p><p>在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开；</p><p><strong>②装入时动态链接</strong></p><p>将用户源程序编译后所得的一组目标模块，在装入内存时，采用边装入边链接的方式，其优点是便于修改和更新，实现对目标模块的共享；</p><p><strong>③运行时动态链接</strong></p><p>在程序执行中需要该目标模块时，才对它进行链接，优点是加快装入进程，还可节省内存空间；</p><h4 id="三种装入方式">三种装入方式</h4><p><strong>①绝对装入</strong></p><p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码，</p><p>只适用于<code>单道程序环境</code>；</p><p><strong>②静态重定位(可重定位装入)</strong></p><p>多道程序环境下，多个目标模块的起始地址通常都从0开始，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址；装入内存时根据内存情况装入合适的位置，装入时对地址进行<code>重定位</code>，逻辑地址变换为物理地址；</p><p><img src="https://img.lishangcc.top//img/image-20220818145322025.png" alt="image-20220818145322025"></p><p><strong>③动态重定位(动态运行时重定位)</strong></p><p>程序在内存中若发生移动，则需要采用动态的装入方式，装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行；（因此，装入内存后的所有地址均为相对地址，所以需要一个重定位寄存器）</p><h3 id="内存管理">内存管理</h3><h4 id="进程的内存映像">进程的内存映像</h4><p>不同于存放在硬盘上的可执行文件，当一个程序调入内存运行时，就构成了进程的内存映像，包括以下几个要素：</p><ul><li><code>代码段</code>：程序的二进制代码；该段是只读的，可被多个进程共享；</li><li><code>数据段</code>：程序运行时加工处理的对象，包括全局变量和静态变量；</li><li><code>进程控制块(PCB)</code>：存放在系统区，用来控制和管理进程；</li><li><code>堆</code>：由程序员分配与释放，若不释放，程序结束时由操作系统回收，如：malloc、free；（分配方式：低地址→高地址）</li><li><code>栈</code>：编译器自动分配释放，用于实现函数调用；（分配方式：高地址→低地址）</li></ul><p><img src="https://img.lishangcc.top//img/image-20220818150955770.png" alt="image-20220818150955770"></p><h4 id="内存保护">内存保护</h4><p>确保每个进程都有一个单独的内存空间，内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响；一般有以下两种方法：</p><ul><li>在CPU中设置一对上、下限寄存器，存放进程的上、下限地址，进程的指令要访问某个地址时，CPU检查是否越界；</li><li>采用<code>重定位寄存器</code>（基址寄存器）和<code>界地址寄存器</code>进行越界检查，重定位寄存器存放进程的<code>起始物理地址</code>，界地址寄存器存放进程的<code>最大逻辑地址</code>；</li></ul><h3 id="覆盖与交换">覆盖与交换</h3><p><strong>覆盖技术</strong></p><p><code>设计思想</code>：将程序分为多个段（多个模块），常用的段常驻内存中，不常用的段在需要时调入内存；</p><p><img src="https://img.lishangcc.top//img/image-20220815171457942.png" alt="image-20220815171457942"></p><p>固定区中的程序段在运行过程中不会调入调出；</p><p>覆盖区中的程序段在运行过程中会根据需要调入调出；</p><blockquote><p>一个例子</p><p><img src="https://img.lishangcc.top//img/image-20220815171646011.png" alt="image-20220815171646011"></p><p>设A(main)为常用函数，B和C函数不同时调用，D只有在调用B函数时才能调用，E和F只有在调用C时才能调用，且E和F不能同时调用；</p><p>此时，可以为A函数占用的8K内存设定固定区，B和C中取内存空间最大值设置覆盖区（10K），D、E和F也一样取最大的值设置覆盖区（12K），这样总的物理内存仅需要30K；</p><p>分区依据：不能被同时访问的程序段共享一个覆盖区；覆盖区大小取决于这些程序段占用空间的最大值；</p></blockquote><p>缺点：对用户不透明，增加了用户编程负担；</p><p><strong>交换技术</strong></p><p><code>设计思想</code>：内存空间紧张时，系统将内存中某些进程暂时换出外存（进程的PCB会常驻内存，不会被换出外存，而是会加入到挂起队列中），把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）；</p><blockquote><p>换出外存等待的进程状态为<code>挂起状态</code>；</p><p>内存调度（中级调度），就是要决定哪个挂起状态的进程重新调入内存；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220815172831127.png" alt="image-20220815172831127"></p><ul><li><p><strong>Q：应该在外存(磁盘)的什么位置保持被换出的进程？</strong></p><p>A：具有交换功能的操作系统，通常把磁盘空间分为<code>文件区</code>和<code>对换区</code>两部分；<code>文件区</code>用于存放文件，主要追求<code>存储空间的利用率</code>，因此对文件区空间的管理采用<code>离散分配方式</code>；<code>对换区</code>空间只占磁盘空间一小部分，<code>被换出的进程存放在对换区</code>，由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要<code>追求换入换出速度</code>，通常采用<code>连续分配方式</code>，所以对换区的I/O速度比文件区的更快；</p></li><li><p><strong>Q：什么时候应该交换？</strong></p><p>A：交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停，如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程，如果缺页率下降，就可以暂停换出；</p></li><li><p><strong>Q：应该换出哪些进程？</strong></p></li><li><p>A：可以优先换出阻塞进程、优先级低的进程等；</p></li></ul><h3 id="连续分配管理方式">连续分配管理方式</h3><p>连续分配：用户进程分配的必须是一个连续的内存空间；</p><p>内部碎片：分配给某进程的内存空间中，有些部分没用上；</p><p>外部碎片：内存中某些空闲分区因太小而难以使用；</p><h4 id="单一连续分配">单一连续分配</h4><p>该方式中，内存分为系统区和用户区，内存中只能有一道用户程序，用户程序独占整个用户区空间；</p><p><img src="https://img.lishangcc.top//img/image-20220815183941542.png" alt="image-20220815183941542"></p><p>优点：实现简单，无外部碎片，可采用覆盖技术扩充内存；</p><p>缺点：只能用于单用户、单任务的操作系统，有内部碎片，存储器利用率极低；</p><h4 id="固定分区分配">固定分区分配</h4><p>将整个用户空间划分为若干个固定大小的分区，在每个分区中只能装入一道作业；</p><blockquote><p>两种方式：</p><p><code>分区大小相等</code>：缺乏灵活性，但很适用于用一台计算机控制多个相同对象的场合；</p><p><code>分区大小不同</code>：增加了灵活性，可以满足不同大小的进程的需求；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220815184345346.png" alt="image-20220815184345346"></p><p>需要建立<code>分区说明表</code>，实现各个分区的分配和回收，每个表项应包含：大小、起始地址、状态（是否已分配）；</p><p><img src="https://img.lishangcc.top//img/image-20220815184611367.png" alt="image-20220815184611367"></p><p>优点：实现简单，无外部碎片；</p><p>缺点：当用户程序太大时，可能所有分区均无法满足（可用覆盖技术解决）；依然会产生内部碎片，内存利用率低；</p><h4 id="动态分区分配">动态分区分配</h4><p>不会预先划分内存分区，而是进程装入内存时，根据进程大小动态地建立分区</p><p><img src="https://img.lishangcc.top//img/image-20220815200158122.png" alt="image-20220815200158122"></p><p>Q：系统用什么样的数据结构记录内存使用情况？</p><p><img src="https://img.lishangcc.top//img/image-20220815200413715.png" alt="image-20220815200413715"></p><p>无内部碎片，但有外部碎片（可通过&quot;紧凑&quot;技术解决）；</p><h3 id="动态分区分配算法">动态分区分配算法</h3><p>解决当很多个空闲分区都满足需求时，应该选择哪个分区进行分配。</p><h4 id="首次适应算法-First-Fit">首次适应算法(First Fit)</h4><p><code>算法思想</code>：每次从低地址开始查找，找到第一个满足大小的空闲分区；</p><p><code>实现</code>：空闲分区以<code>地址递增次序</code>排序；</p><h4 id="最佳适应算法-Best-Fit">最佳适应算法(Best Fit)</h4><p><code>算法思想</code>：优先使用小的内存空间，尽可能留下更多的大片空间；</p><p><code>实现</code>：空闲分区按<code>容量递增次序</code>排序；</p><p><code>缺点</code>：①会产生很多外部碎片；②算法开销大，回收分区后可能要对空闲分区队列重新排序；</p><h4 id="最坏适应算法-Worst-Fit">最坏适应算法(Worst Fit)</h4><p><code>算法思想</code>：优先使用最大的连续空闲区；</p><p><code>实现</code>：空闲分区按<code>容量递减次序</code>排序；</p><p><code>缺点</code>：①大的内存的空间被用完，导致大进程到来可能没有可用的内存分区；②算法开销大；回收分区后，可能要对空闲分区队列重新排序；</p><h4 id="邻近适应算法-Next-Fit">邻近适应算法(Next Fit)</h4><p><code>算法思想</code>：每次都从上次查找结束的位置开始检索，找到第一个满足大小的空闲分区；（首次适应算法的改进）</p><p><code>实现</code>：空闲分区按<code>地址递增次序</code>排列；</p><p><code>缺点</code>：可能使小进程占用大空间，从而减少大空间区域，使得大进程到来可能无可用空间；</p><h3 id="基本分页存储管理">基本分页存储管理</h3><h4 id="分页存储概念">分页存储概念</h4><p><code>页框</code>：将内存分为一个个大小相等的分区，每个分区就是一个&quot;页框&quot;（页框=内存块=物理块=物理页面=页帧）；</p><p><code>页框号</code>：每个页框都有一个编号，<code>页框号从0开始</code>；</p><p><code>页面</code>：将<code>进程的逻辑地址空间</code>也分为与<code>页框大小相等</code>的一个个部分，每个部分称为一个 “页面” 或 “页”，每个页面也有一个编号，即&quot;页号&quot;，页号也是从0开始；</p><p><img src="https://img.lishangcc.top//img/image-20220815205228393.png" alt="image-20220815205228393"></p><blockquote><p>操作系统以页框为单位为各个进程分配内存空间，进程的每个页面分别让入一个页框中，也就是说，<code>进程的页面与内存的页框有一一对应的关系</code>；</p><p>注：进程的最后一个页面可能没有一个页框那么大，所以分页存储可能产生内部碎片，所以页框不用设得太大；</p></blockquote><p><code>页表</code>：为了使操作系统能够知道进程每个页面在内存中的存放位置；</p><blockquote><ol><li>一个进程对应一张页表；</li><li>进程的每个页面对应一个页表项；</li><li>每个页表项由 页号 和 块号 组成；</li><li>页表记录进程页面和实际存放的内存块之间的映射关系；</li><li>每个页表项的长度是相同的；</li></ol></blockquote><p><img src="https://img.lishangcc.top//img/image-20220815205723511.png" alt="image-20220815205723511"></p><blockquote><p><strong>Eg：假如某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少为多少字节？</strong></p><p><img src="https://img.lishangcc.top//img/image-20220815205942385.png" alt="image-20220815205942385"></p><p>注：页号是隐含的，不占用空间；</p></blockquote><p><strong>如何实现地址的转换？</strong></p><p>页号 = 逻辑地址 / 页面长度；</p><p>页内偏移量 = 逻辑地址 % 页面长度；</p><p>物理地址 = 页面地址 + 页内偏移量；</p><blockquote><p>Q：如何访问逻辑地址A？</p><p>A：①确定逻辑地址A对应的页号P；②找到P号页面在内存中的起始地址（查页表）；③确定逻辑地址A的页内偏移量W；④逻辑地址A对应的物理地址 = P号页面在内存中的起始地址 + 页面偏移量W；</p><p>Eg：某计算机系统中，页面大小是50B，某进程逻辑地址空间大小为200B，逻辑地址110对应的页号、页内偏移量是多少？</p><p>答：页号 =110 / 50 = 2；页内偏移量 = 110 % 50 =10；</p></blockquote><p>使用二进制表示：</p><p><img src="C:/Users/LS/AppData/Roaming/Typora/typora-user-images/image-20220815211850182.png" alt="image-20220815211850182"></p><p>逻辑地址结构：</p><p><img src="https://img.lishangcc.top//img/image-20220815212039596.png" alt="image-20220815212039596"></p><h4 id="基本地址变换机构">基本地址变换机构</h4><p><code>页表寄存器（PTR）</code>：存放页表在内存中的<code>起始地址F</code>和<code>页表长度M</code>（这两个信息进程未执行时，存放在进程控制块PCB中，进程被调度时，放在页表寄存器中）；</p><p><strong>逻辑地址转换物理地址过程：</strong></p><p><img src="https://img.lishangcc.top//img/image-20220816221405387.png" alt="image-20220816221405387"></p><p>①计算页号P和页内偏移地址W；</p><p>②比较页号P和页表长度M，若P&gt;=M，则产生越界中断，否则继续执行；（页号从0开始，而页表长度至少是1，所以P=M也会越界）；</p><p>③页号P对应的页表项地址 = 页表起始地址F + 页号P * 页表项长度；取出该页表项内容b；</p><p>④计算 E = b * L + W，L为页面大小，用得到的物理地址E去访存；（如果内存块号、页面偏移量是用二进制表示，那么把二者拼接起来就是最终的物理地址）；</p><blockquote><p>例：若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E；</p><p>（等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位，页号2对应的内存块号为b = 8，将逻辑地址A=2500转换为物理地址E）</p><p><img src="https://img.lishangcc.top//img/image-20220817000357460.png" alt="image-20220817000357460"></p></blockquote><blockquote><p>形象理解：</p><p>一个进程可以理解为一行行文字的集合，存放在一本书中（内存），你要查找某一行，你得查找他在哪一页，并且自己记住在哪一行（偏移量），此时根据页号去翻目录找内存中的地址（页表），找到那一页（页框），根据偏移量定位那句话；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220817003703146.png" alt="image-20220817003703146"></p><h4 id="具有快表的地址变换机构">具有快表的地址变换机构</h4><p><code>快表(TLB)</code>：是一种访问速度比内存速度快很多的高速缓存（cache），用来存放最近访问的页表项的副本，可以加速地址变换的速度；</p><p><strong>引入快表的地址的变换过程</strong>：</p><p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较；</p><p>②如果找到匹配的页号，说明访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，将内存块号与页内偏移量拼接成物理地址，最后访问该物理地址对应的内存单元；（仅需一次访存）</p><p>③如果没有找到匹配页号，则需要访问内存中的页表；（需要两次访存）</p><blockquote><p><img src="https://img.lishangcc.top//img/image-20220817161055400.png" alt="image-20220817161055400"></p><p><img src="https://img.lishangcc.top//img/image-20220817161156935.png" alt="image-20220817161156935"></p></blockquote><p><strong>局部性原理</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817161332442.png" alt="image-20220817161332442"></p><p><strong>总结</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817161400323.png" alt="image-20220817161400323"></p><h4 id="两级页表">两级页表</h4><p><strong>单级页表存在的问题</strong></p><p>①页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框；</p><p>②没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某个特定的页面；</p><p><strong>两级页表结构</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817162646480.png" alt="image-20220817162646480"></p><p>（页表也会占用内存块，所以一级页表记录二级页表的内存块号）</p><blockquote><p>注意：</p><p>1.若采用多级页表机制，则各个页表的大小不能超过一个页面；</p><p><img src="https://img.lishangcc.top//img/image-20220817175807643.png" alt="image-20220817175807643"></p><p>2.多级页表的访存次数（假设没有快表机构）：N级页表访问一个逻辑地址需要N+1次访存；</p></blockquote><p><strong>总结</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817180559579.png" alt="image-20220817180559579"></p><h3 id="基本分段存储管理">基本分段存储管理</h3><blockquote><p>与分页最大的区别就是：离散分配时所分配地址空间的基本单位不同；</p></blockquote><p><strong>分段</strong></p><p>段式管理方式按照用户进程中的自然段划分逻辑空间；</p><p><img src="https://img.lishangcc.top//img/image-20220817203455318.png" alt="image-20220817203455318"></p><p><strong>段表</strong></p><p>每个进程都有一张逻辑空间与内存空间映射的段表，其中每个段表项对应进程的一段，段表项纪录该段在内存中的起始地址和段长；</p><p><img src="https://img.lishangcc.top//img/image-20220817203715894.png" alt="image-20220817203715894"></p><p><strong>地址转换</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817204052190.png" alt="image-20220817204052190"></p><p><strong>分页与分段的对比</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817204206213.png" alt="image-20220817204206213"></p><p><img src="https://img.lishangcc.top//img/image-20220817204630598.png" alt="image-20220817204630598"></p><h3 id="段页式管理方式">段页式管理方式</h3><p>段页式管理 = 分段 + 分页；</p><p><img src="https://img.lishangcc.top//img/image-20220817212312012.png" alt="image-20220817212312012"></p><p><strong>逻辑地址结构</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817212401799.png" alt="image-20220817212401799"></p><p><strong>段表和页表</strong></p><p>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成；</p><p>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成；</p><p><img src="https://img.lishangcc.top//img/image-20220817212642922.png" alt="image-20220817212642922"></p><p><strong>地址转换</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817212731502.png" alt="image-20220817212731502"></p><p><strong>总结</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817212754275.png" alt="image-20220817212754275"></p><h2 id="虚拟内存">虚拟内存</h2><h3 id="虚拟内存基本概念">虚拟内存基本概念</h3><p>虚拟存储技术基于局部性原理（时间局部性、空间局部性）；</p><blockquote><p>虚拟内存三个特征：</p><ul><li>多次性：</li><li>对换性：</li><li>虚拟性：</li></ul></blockquote><p><img src="https://img.lishangcc.top//img/image-20220817214147495.png" alt="image-20220817214147495"></p><h3 id="请求分页管理方式">请求分页管理方式</h3><blockquote><p>请求分页与基本分页的区别：</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行；</p><p>若内存不够，由操作系统负责将内存中暂时用不到的信息换出到外存；</p></blockquote><p><strong>页表机制</strong></p><p>在请求分页管理中，为了实现请求调页，操作系统需要知道每个页面是否调入内存；</p><p>当内存空间不够，要实现页面置换；</p><p><strong>请求分页存储管理页表</strong></p><p><img src="https://img.lishangcc.top//img/image-20220817232513540.png" alt="image-20220817232513540"></p><p><strong>缺页中断机构</strong></p><p>在请求分页系统中，每当要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存；</p><p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再唤醒放回就绪队列；</p><p>如果内存中有空闲块，则直接为进程分配一个空闲块，将所缺页面装入，并修改页表中相应的页表项；</p><p>如果没有空闲块，则由页面置换算法淘汰一个页面；</p><blockquote><p>缺页中断属于内中断（内部异常）；</p><p>一条指令执行期间，可能产生多次缺页中断；</p></blockquote><p><strong>地址变换机构</strong></p><ol><li>找到页表项检查页面是否在内存中；</li><li>若页面不在内存中，请求调页；</li><li>若内存空间不够，则需要换出页面；</li><li>页面调入内存后，需要修改相应页表项；</li></ol><blockquote><p>补充：</p><ul><li>只有写命令才需要修改 “修改位”，并且，一般只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表，这样以减少访存次数；</li><li>和普通中断处理一样，缺页中断也要保留CPU现场；</li><li>换入 换出页面都需要启动慢速的I/O操作；</li><li>页面调入内存后，需要修改慢表，同时也要将表项复制到快表中；</li></ul></blockquote><h3 id="页面置换算法">页面置换算法</h3><h4 id="最佳置换算法-OPT">最佳置换算法(OPT)</h4><p><code>算法思想</code>：每次选择淘汰的页面将是<code>以后再也不使用的</code>，或者`在最长时间内不再被访问的页面``，以保证最低的缺页率；</p><p><img src="https://img.lishangcc.top//img/image-20220817235128079.png" alt="image-20220817235128079"></p><blockquote><p>实际上，操作系统无法提前预判页面访问序列，因此这个算法是无法实现的；</p></blockquote><h4 id="先进先出置换算法-FIFO">先进先出置换算法(FIFO)</h4><p><code>算法思想</code>：淘汰的页面是<code>最早进入内存的页面</code>；</p><p><img src="https://img.lishangcc.top//img/image-20220817235518863.png" alt="image-20220817235518863"></p><blockquote><p>注意：若分配四个内存块时，上述序列会产生10次缺页次数；（Belady异常）</p><p><code>Belady异常</code>：当为进程分配的物理块数增大时，缺页次数不减反增的现象；</p><p>只有FIFO算法会产生Belady异常；</p><p>因为先进入的页面也有可能被经常访问，因此此算法性能比较差；</p></blockquote><h4 id="最近最久未使用置换算法-LRU">最近最久未使用置换算法(LRU)</h4><p><code>算法思想</code>：每次淘汰的页面是<code>最近最久未使用的页面</code>；</p><p><img src="https://img.lishangcc.top//img/image-20220818000147369.png" alt="image-20220818000147369"></p><blockquote><p>该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大；</p></blockquote><h4 id="时钟置换算法-CLOCK">时钟置换算法(CLOCK)</h4><p><code>算法思想</code>：为每个页面设置一个访问位，将内存中的页面都通过链接指针链接成一个循环队列，当某页被访问时，访问位置1，当需要淘汰一个页面时，只需检查页的访问位，是0，则该页换出，是1，则将其置0，并且暂不换出，继续检查下一个页面；若第一轮扫描中所有页面都是1，则进行第二轮检查（这一轮一定会有访问位为0的页面，因此该算法淘汰一个页面最多经过两轮扫描）；</p><h4 id="改进型时钟置换算法">改进型时钟置换算法</h4><p><img src="https://img.lishangcc.top//img/image-20220818001647270.png" alt="image-20220818001647270"></p><h4 id="算法总结">算法总结</h4><p><img src="https://img.lishangcc.top//img/image-20220818001729637.png" alt="image-20220818001729637"></p><h2 id="页面分配策略">页面分配策略</h2><p><code>驻留集</code>：指请求分页存储管理中给进程分配物理块的集合；</p><blockquote><p>在采用虚拟存储技术系统中，驻留集一般小于进程的总大小；</p><p>若驻留集太小，会导致缺页频繁；若驻留集太大，又会导致多道程序并发度下降；</p></blockquote><p><code>固定分配(驻留集大小不变)</code>：操作系统为每个进程分配一组固定数目的物理块，进程运行期间不变；</p><p><code>可变分配(驻留集大小可变)</code>：先为每个进程分配一定数目的物理块，进程运行期间，可根据情况增加或减少；</p><p><code>局部置换</code>：发生缺页时只能选择进程自己的物理块进行置换；</p><p><code>全局置换</code>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程；</p><p><img src="https://img.lishangcc.top//img/image-20220818123140889.png" alt="image-20220818123140889"></p><p><code>固定分配局部置换</code>：进程运行前就分配一定数量的物理块，缺页时只能换出进程自己的某一页；</p><p><code>可变分配全局置换</code>：只要缺页就分配新物理块，可能来自空闲物理块，也可能需要换出别的进程页面；</p><p><code>可变分配局部置换</code>：频繁缺页的进程，多分配一些物理块，缺页率很低的进程，回收一些物理块，直到缺页率合适；</p><p><code>抖动现象</code>：刚换出的页面又马上换入内存，刚刚换入的页面又马上换出外存，这种频繁的页面调度称为抖动；</p><blockquote><p>抖动的主要原因：进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块数不够）；</p></blockquote><p><code>工作集</code>：某段时间间隔内，进程实际访问页面的集合；一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页；</p><p><img src="https://img.lishangcc.top//img/image-20220818142416018.png" alt="image-20220818142416018"></p><h2 id="内存映射文件">内存映射文件</h2><p>内存映射文件——操作系统向上层程序员提供功能（系统调用）；</p><p>内存映射文件与虚拟内存相似，将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，而不必执行I/O操作，也无需对文件内容进行缓存处理，适合用来管理大尺寸文件；</p><p><img src="https://img.lishangcc.top//img/image-20220818143550104.png" alt="image-20220818143550104"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 进程与线程(下)</title>
      <link href="/myblog/2022/08/04/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-08-04-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B2/"/>
      <url>/myblog/2022/08/04/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-08-04-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<h2 id="调度的概念">调度的概念</h2><p><strong>高级调度（作业调度）</strong></p><p>按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程，每个作业只调入一次，调出一次；作业调入时会建立PCB，调出时才撤销PCB；</p><p><strong>中级调度（内存调度）</strong></p><blockquote><p>背景：内存不够时，可将某些进程的数据调出到外存，等内存空闲或者进程需要运行时再重新调入内存；展示调到外存等待的进程的状态为挂起状态，被挂起的进程PCB会被组织成挂起队列；</p></blockquote><p>按照某种策略决定将哪个处于挂起状态的进程重新调入内存，一个进程肯会多次调出、调入内存，因此中级调度发生的频率比高级调度高；</p><p><strong>初级调度（进程调度/处理机调度）</strong></p><p>按照某种策略从就绪队列中选取一个进程，将处理机分配给它；</p><p>进程调度是操作系统中<code>最基本的一种调度</code>，在一般的操作系统中都必须配置进程调度；</p><p>进程调度的频率很高；</p><p><strong>三者对比</strong></p><p><img src="https://img.lishangcc.top//img/image-20220804210956975.png" alt="image-20220804210956975"></p><h2 id="进程调度的时机">进程调度的时机</h2><p><strong>需要进行进程调度与切换的情况</strong></p><blockquote><p>当前运行的进程<code>主动放弃</code>处理机：</p><ul><li>进程正常终止；</li><li>运行过程中发生异常而终止；</li><li>进程主动请求阻塞（如：等待I/O）；</li></ul><p>当前运行的进程<code>被动放弃</code>处理机：</p><ul><li>分给进程的时间片用完；</li><li>有更紧急的事需要处理（如：I/O中断）；</li><li>有更高优先级的进程进入就绪队列；</li></ul></blockquote><p><strong>不能进行进程调度与切换的情况</strong></p><blockquote><ul><li>处理中断过程中；</li><li>进程在操作系统内核程序临界区中；</li><li>在原子操作过程中；</li></ul></blockquote><blockquote><p><strong>临界资源</strong>：一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源；</p><p><strong>临界区</strong>：访问临界资源的那段代码；</p></blockquote><h2 id="调度程序-调度器">调度程序(调度器)</h2><p>用于调度和分派CPU的组件称为调度程序，通常由三部分组成：排队器、分派器、上下文切换器；</p><p>就绪态与运行态之间的相互切换由调度程序引起；</p><p>调度程序决定：让谁运行（通过调度算法），运行多长时间（通过时间片大小）。</p><p>触发调度程序的事件：创建新进程、进程退出、运行进程阻塞、I/O中断发生（可能唤醒某些阻塞进程）。</p><p><strong>闲逛进程</strong>：调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程（idle）；</p><blockquote><p>闲逛进程特征：①优先级最低，②可以是0地址指令，占一个完整的指令周期，③能耗低；</p></blockquote><h2 id="调度算法">调度算法*</h2><blockquote><p>非剥夺调度方式（非抢占方式）：只允许进程主动放弃处理机，实现简单，系统开销小，但是无法及时处理紧急任务，适用于早期的批处理系统；</p><p>剥夺调度方式（抢占方式）：当一个进程正在处理机上执行时，如果有一个更重要的进程需要使用处理机，则立即暂停当前正在执行的进程，将处理机及时分配出去；适用于分时操作系统、实时操作系统；</p></blockquote><p>周转时间 = 完成时间 - 到达时间</p><p>带权周转时间 = 周转时间 / 运行时间</p><p>等待时间 = 周转时间 - 运行时间</p><h3 id="先来先服务（FCFS）">先来先服务（FCFS）</h3><p><strong>算法思想</strong>：出于&quot;公平&quot;角度考虑，类似于生活中排队买东西；</p><p><strong>算法规则</strong>：按照作业/进程到达的先后顺序进行服务；</p><p><strong>是否可抢占</strong>：非抢占式算法；</p><p><strong>优点</strong>：公平，算法实现简单；</p><p><strong>缺点</strong>：排在长进程(或作业)后面的短进程需要等待很长时间，<code>带权周转时间很大</code>，对长作业有利，对短作业不利；</p><p><strong>是否导致饥饿</strong>：不会；</p><h3 id="短作业优先（SJF）">短作业优先（SJF）</h3><blockquote><p>短作业优先（SJF）<br>短进程优先（SPF）<br>最短剩余时间优先（SRTN）</p></blockquote><p><strong>算法思想</strong>：追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间；</p><p><strong>算法规则</strong>：最短的作业/进程优先得到服务（所谓最短，指要求服务时间最短）；</p><p><strong>是否可抢占</strong>：SJF和SPF默认非抢占（SRTN抢占）；</p><p><strong>优点</strong>：<code>在所有进程同时可运行时</code>或<code>所有进程几乎同时到达</code>，最短的平均等待时间、平均周转时间；</p><p><strong>缺点</strong>：不公平，对短作业有利，对长作业不利，可能产生饥饿现象；另外运行时间由用户提供，不一定能做到真正的短作业优先；</p><p><strong>是否导致饥饿</strong>：会，如果不停有短作业到来，可能使长作业长时间得不到服务；</p><h3 id="高响应比优先（HRRN）">高响应比优先（HRRN）</h3><p><strong>算法思想</strong>：要综合考虑作业/进程的等待时间和要求服务时间；</p><p><strong>算法规则</strong>：在每次调度时，先计算各个作业/进程的响应比，选择响应比最高的服务；</p><blockquote><p>响应比 = (等待时间+要求服务时间) / 要求服务时间；</p></blockquote><p><strong>是否可抢占</strong>：非抢占；</p><p><strong>特点</strong>：综合考虑了等待时间和运行时间；</p><blockquote><ol><li>等待时间相同，要求服务时间短的优先；</li><li>要求服务时间相同，等待时间长的优先；</li><li>对于长作业，其响应比随着时间增加而增加，避免了饥饿现象；</li></ol></blockquote><p><strong>是否导致饥饿</strong>：不会；</p><h3 id="时间片轮转调度算法（RR）">时间片轮转调度算法（RR）</h3><p><strong>算法思想</strong>：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都得到响应；</p><p><strong>算法规则</strong>：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms），若进程未在一个时间片内执行完，则剥夺处理机，将进程放入就绪队列队尾；</p><blockquote><p>一般仅用于进程调度（因为只有作业放入内存并建立相应进程后，才能被分配处理机时间片）。</p></blockquote><p><strong>是否可抢占</strong>：抢占式；</p><p><strong>优点</strong>：公平，响应快，适用于分时操作系统；</p><p><strong>缺点</strong>：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度；</p><p><strong>是否导致饥饿</strong>：不会；</p><h3 id="优先级调度算法">优先级调度算法</h3><p><strong>算法思想</strong>：许多应用场景需要根据任务的紧急程度来决定处理顺序；</p><p><strong>算法规则</strong>：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程；</p><p><strong>是否可抢占</strong>：两者均有；</p><p><strong>优点</strong>：区分紧急程度，适用于实时操作系统；</p><p><strong>缺点</strong>：如果不停有优先级高的进程到来，可能导致饥饿；</p><p><strong>是否导致饥饿</strong>：会；</p><h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3><p><strong>算法思想</strong>：对其他调度的算法的折中权衡；</p><p><strong>算法规则</strong>：</p><ol><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大；</li><li>新进程到达时，先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程未结束，则进程进入下一级队列队尾，如果此时已在最后一级，则直接放入队尾；</li><li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片；</li></ol><p><strong>是否可抢占</strong>：抢占式；</p><p><strong>特点</strong>：综合了FCFS、RR、SPF的优点；</p><p><strong>是否导致饥饿</strong>：会；</p><h3 id="多级队列调度算法">多级队列调度算法</h3><p>设置多个就绪队列，将不同类型或性质的进程固定分配到不同的就绪队列，每个队列可以实施不同的调度算法。</p><h2 id="进程同步与互斥">进程同步与互斥</h2><p><strong>进程同步概念</strong>：进程同步是用来解决异步问题的，在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的制约关系，为了协调进程之间的相互制约关系，引入进程同步的概念；</p><blockquote><p>简单点理解：两个或多个进程需要按照某种顺序执行；</p></blockquote><p><strong>进程互斥概念</strong>：A进程访问某种临界资源，此时B也想访问该临界资源，进程B必须等待A访问完成后才能访问该临界资源；</p><blockquote><p>对临界资源的访问，必须互斥地进行，每个进程中，访问临界资源的那段代码称为<code>临界区</code>，临界资源的访问过程通常分为4个部分；</p><ol><li><code>进入区</code>：检查是否可以进入临界区，若可进入，则设置正在啊访问临界区的标志（即上锁）；</li><li><code>临界区</code>：访问临界资源的那段代码；</li><li><code>退出区</code>：负责解除正在访问临界资源的标志（即解锁）；</li><li><code>剩余区</code>：代码中的其余部分；</li></ol></blockquote><p>为禁止两个进程同时进入临界区，进程互斥应遵循以下原则：</p><ul><li><code>空闲让进</code>：临界区空闲时，可以允许一个请求进入临界区的进程立即进入；</li><li><code>忙则等待</code>：当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li><code>有限等待</code>：对请求访问的进程，应保证能在有限时间内进入临界区（防止饥饿）；</li><li><code>让权等待</code>：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待；</li></ul><h2 id="进程互斥的软件实现方式">进程互斥的软件实现方式</h2><h3 id="单标志法">单标志法</h3><p>两个进程在访问完临界区后会把该临界区的使用权转交给另一个进程（临界区的使用权只能由另一个进程赋予）；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：违背&quot;空闲让进&quot;原则（临界区的使用权只能由另一个进程赋予，若P0想访问临界区，必须在P1访问完临界区将turn改为0，但P1可能不打算进入临界区）；</p></blockquote><h3 id="双标志先检查法（先检查后上锁）">双标志先检查法（先检查后上锁）</h3><p>算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，在各个进程访问临界区前，先检查临界区资源是否被访问，若正在被访问则该进程需等待；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><blockquote><p>优点：不用交替进入，可连续使用；</p><p>缺点：Pi和Pj进程可能同时进入临界区，违背&quot;忙则等待&quot;原则（在Pi进程检查完后，可能会切换到Pj进程，此时两边的标志位均为上锁）；</p></blockquote><h3 id="双标志后检查法（先上锁后检查）">双标志后检查法（先上锁后检查）</h3><p>算法思想：先将自己的标志设置为true，再检查对方进程的状态标志；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：违背&quot;空闲让进&quot;和&quot;有限等待&quot;原则，会导致饥饿现象；即两个进程都争着访问临界资源，结果谁都进不了临界区；</p></blockquote><h3 id="Peterson算法">Peterson算法</h3><p>算法思想：如果双方都争着进入临界区，则让对方先访问；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：未遵循&quot;让权等待&quot;原则；若想要进入临界区的进程无法进入临界区，则会卡在while循环；</p></blockquote><h2 id="进程互斥的硬件实现">进程互斥的硬件实现</h2><h3 id="中断屏蔽方法">中断屏蔽方法</h3><p>利用&quot;开/关中断指令&quot;实现，在访问临界区前关中断，在访问临界区后开中断；</p><blockquote><p>优点：简单高效；</p><p>缺点：只适用于单处理机；只适用于操作系统内核进程，不适用于用户进程；</p></blockquote><h3 id="TestAndSet指令">TestAndSet指令</h3><p>这条指令用硬件实现，执行期间不允许被中断；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布尔型共享变量lock表示当前临界区是否被加锁；</span></span><br><span class="line"><span class="comment">//true已加锁，false未加锁；</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span> *lock)</span>&#123;</span><br><span class="line"><span class="type">bool</span> old;</span><br><span class="line">old = *lock;<span class="comment">//old存放lock原来的值；</span></span><br><span class="line">*lock = <span class="literal">true</span>;<span class="comment">//无论之前是否加锁，都将lock设为true；</span></span><br><span class="line"><span class="keyword">return</span> old;<span class="comment">//返回lock原来的值；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TestAndSet(&amp;lock));</span><br><span class="line">critical section;</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>通过old变量记录之前是否上锁，无论上锁与否都将进行上锁操作，若之前已上锁，TestAndSet上锁操作不影响当前状态，若之前未上锁，则TestAndSet上锁表示自己将要访问临界区；</p><h3 id="Swap指令">Swap指令</h3><p>这条指令也是用硬件实现，执行期间不允许被中断；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换两个变量的值</span></span><br><span class="line">Swap(<span class="type">bool</span> *a, <span class="type">bool</span> *b)&#123;</span><br><span class="line">    <span class="type">bool</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lock表示当前临界资源是否上锁</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(old == <span class="literal">true</span>)</span><br><span class="line">    Swap(&amp;lock, &amp;old);</span><br><span class="line">critical section;</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>Swap指令与TestAndSet指令逻辑上基本相同，通过old变量记录当前是否上锁，若old为true再将lock设置为true，最后再检查old，此时old为false则说明之前没有别的进程对临界区上锁，则跳出循环进入临界区；</p><blockquote><p>以上两种指令适用于多处理机环境，但不满足&quot;让权等待&quot;（若有进程正在访问临界区，则其他想要访问该临界区的进程会一直卡在while循环）；</p></blockquote><h2 id="互斥锁">互斥锁</h2><p>可以简单理解为一个布尔型的变量，表示当前已上锁或未上锁，进入临界区通过aquire()获得锁，退出临界区通过release()释放锁；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;<span class="comment">//获得锁</span></span><br><span class="line"><span class="keyword">while</span>(!available);<span class="comment">//判断当前所是否可用；</span></span><br><span class="line">available = <span class="literal">false</span>;<span class="comment">//修改为不可用状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">release()&#123;<span class="comment">//释放锁</span></span><br><span class="line">available = <span class="literal">true</span>;<span class="comment">//修改为可用状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：违反&quot;让权等待&quot;原则；</p></blockquote><h2 id="信号量机制">信号量机制</h2><p><code>信号量</code>：一个变量，用来表示系统中某种资源的数量；</p><p><code>原语</code>：一种特殊程序段，一气呵成执行，有开/关中断指令实现；</p><p><code>wait(S)和signal(S)原语</code>：也可分别写为P(S)、V(S)，信号量S作为传入参数；</p><h3 id="整型信号量">整型信号量</h3><p>对信号量的操作只有三种：①初始化；②P操作；③V操作；</p><p><img src="https://img.lishangcc.top//img/image-20220809152955572.png" alt="image-20220809152955572"></p><p><code>wait原语作用</code>：①循环检查当前资源是否够用，够用则跳出循环，不够用则循环到够用为止（违反&quot;让权等待&quot;原则）；②将资源分配给当前进程，即<code>系统资源数 - 1</code>;</p><p><code>signal原语作用</code>：将进程占用的系统资源归还，即<code>系统资源数 + 1</code>；</p><h3 id="记录型信号量">记录型信号量*</h3><blockquote><p>用于解决整型信号量中存在忙等待的问题；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220809154108883.png" alt="image-20220809154108883"></p><ul><li><strong>执行wait原语时</strong>，意味着<code>进程请求一个单位的资源</code>，资源数减1，若剩余资源不够分配（即S.value&lt;0），调用block原语，将会把进程从运行态变为阻塞态，并且把该进程挂到信号量S对应的等待队列中；</li><li><strong>执行signal原语时</strong>，意味着<code>释放一个单位的资源</code>，并且多了一个<code>当前剩余资源的判断</code>，资源数加1后若当前剩余资源&lt;=0，说明此时有其他进程正在等待使用该资源，则从信号量S对应的等待队列中<code>唤醒一个进程</code>，并将该进程<code>从阻塞态变为就绪态</code>；</li></ul><h2 id="用信号量实现进程互斥、同步、前驱关系">用信号量实现进程互斥、同步、前驱关系</h2><h3 id="信号量实现进程互斥">信号量实现进程互斥</h3><ol><li>分析并发进程关键活动，划定临界区；</li><li>设置<code>互斥信号量 mutex = 1</code>；</li><li>P、V操作成对出现，进入区P(mutex)，退出区V(mutex)；</li></ol><h3 id="信号量实现进程同步">信号量实现进程同步</h3><blockquote><p>进程同步：让各并发进程按要求有序推进；</p></blockquote><ol><li>分析需要同步的活动，即必须保证一前一后执行两个操作；</li><li>设置<code>同步信号量 S = 0</code>；</li><li>前V后P，在前操作之后执行V(S)，在后操作之前执行P(S)；</li></ol><h3 id="信号量实现前驱关系">信号量实现前驱关系</h3><p>本质即：多级同步问题；</p><p>如图，进程P1中有局代码S1，P2中有句代码S2…P6中有句代码S6，按如下前驱图执行（如S2要在S1后执行）；</p><p><img src="https://img.lishangcc.top//img/image-20220809171440391.png" alt="image-20220809171440391"></p><ol><li>分析问题，画出前驱图，每一对前驱关系看成一个同步问题；</li><li>为每一对前驱关系设置同步信号量，初值为0；</li><li>前V后P；</li></ol><p><strong>总结</strong></p><p><img src="https://img.lishangcc.top//img/image-20220809171921077.png" alt="image-20220809171921077"></p><h2 id="生产者-消费者">生产者-消费者</h2><p><code>问题描述</code>：系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品使用（产品可以理解为某种数据）；</p><p>生产者、消费者共享一个初始为空、大小为n的缓冲区；</p><p>缓冲区没满→生产者生产；</p><p>缓冲区没空→消费者消费；</p><p>缓冲区是临界资源，各进程必须<code>互斥访问</code>；</p><p><img src="https://img.lishangcc.top//img/image-20220809180423314.png" alt="image-20220809180423314"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥信号量，实现对缓冲区的互斥访问；</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//同步信号量，表示空闲缓冲区数量；</span></span><br><span class="line">semaphore empty = n;</span><br><span class="line"><span class="comment">//同步信号量，表示产品数量，也即非空缓冲区数量；</span></span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">producer()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">生产一个产品;</span><br><span class="line">P(empty);</span><br><span class="line">P(mutex);</span><br><span class="line">把产品放入缓冲区;</span><br><span class="line">V(mutex);</span><br><span class="line">V(full);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(full);</span><br><span class="line">P(mutex);</span><br><span class="line">从缓冲区取出产品;</span><br><span class="line">V(mutex);</span><br><span class="line">V(empty);</span><br><span class="line">使用产品;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少；</p><p>实现互斥P操作一定要在同步P操作之后，防止死锁；</p></blockquote><h2 id="多生产者-多消费者">多生产者-多消费者</h2><p><code>问题描述</code>：桌面上有一个盘子，每次只能放入一个水果，爸爸放苹果，妈妈放橘子，儿子只吃橘子，女儿只吃苹果，只有盘子空时，爸妈才能放一个水果，仅当盘子有自己需要的水果时，儿子或女儿可以取出水果；</p><p><img src="https://img.lishangcc.top//img/image-20220809233413458.png" alt="image-20220809233413458"></p><ul><li>互斥关系：对盘子（缓冲区）的访问是互斥的；</li><li>同步关系：父亲→女儿；母亲→儿子；女儿/儿子→父亲/母亲；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore plate = <span class="number">1</span>;</span><br><span class="line">semaphore apple = <span class="number">0</span>;</span><br><span class="line">semaphore orange = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dad()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">准备一个苹果;</span><br><span class="line">P(plate);</span><br><span class="line">P(mutex);</span><br><span class="line">将苹果放入盘子;</span><br><span class="line">V(mutex);</span><br><span class="line">V(apple);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mom()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">准备一个橘子;</span><br><span class="line">P(plate);</span><br><span class="line">P(mutex);</span><br><span class="line">将橘子放入盘子;</span><br><span class="line">V(mutex);</span><br><span class="line">V(orange);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">son()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(orange);</span><br><span class="line">P(mutex);</span><br><span class="line">取出盘子中的橘子;</span><br><span class="line">V(mutex);</span><br><span class="line">V(plate);</span><br><span class="line">吃橘子;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(apple);</span><br><span class="line">P(mutex);</span><br><span class="line">取出盘子中的苹果;</span><br><span class="line">V(mutex);</span><br><span class="line">V(plate);</span><br><span class="line">吃苹果;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析同步问题时，不能单从单个进程行为角度判断，而是应把&quot;一前一后&quot;发生的事情看成是事件的前后关系，如下图中间部分可以合成一个事件；</p><p><img src="https://img.lishangcc.top//img/image-20220810000815750.png" alt="image-20220810000815750"></p></blockquote><h2 id="吸烟者问题">吸烟者问题</h2><p><code>问题描述</code>：假设一个系统有<code>三个抽烟者进程</code>和<code>一个供应者进程</code>，每个抽烟者不停卷烟并抽掉它，卷起一支烟抽烟者需要三种材料：烟草、纸、胶水；三个抽烟者中，第一个拥有烟草，第二个有纸，第三个有胶水；供应者无限提供三种材料，每次将两种材料放桌子上，拥有足够材料的抽烟者卷一根烟并抽掉，此时向供应者发出完成信号，供应者会放另外两种材料在桌上，过程重复，使三个抽烟者轮流抽烟；</p><p><img src="https://img.lishangcc.top//img/image-20220810001329462.png" alt="image-20220810001329462"></p><ul><li>互斥关系：供应者与抽烟者访问桌子是互斥的(因为缓存容量为1，所以可以不单独设置mutex)；</li><li>同步关系：桌子组合1→第一个抽烟者；桌子组合2→第二个抽烟者；桌子组合3→第三个抽烟者；发出完成信号→供应者；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;</span><br><span class="line">semaphore offer2 = <span class="number">0</span>;</span><br><span class="line">semaphore offer3 = <span class="number">0</span>;</span><br><span class="line">semaphore finish = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;<span class="comment">//用于实现轮流抽烟</span></span><br><span class="line"></span><br><span class="line">provide()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            放组合<span class="number">1</span>;</span><br><span class="line">V(offer1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">            放组合<span class="number">2</span>;</span><br><span class="line">V(offer2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">            放组合<span class="number">3</span>;</span><br><span class="line">V(offer3);</span><br><span class="line">&#125;</span><br><span class="line">P(finish);</span><br><span class="line">i = (i+<span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(offer1);</span><br><span class="line">拿走组合<span class="number">1</span>;</span><br><span class="line">卷烟;</span><br><span class="line">抽烟;</span><br><span class="line">V(finish);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker2()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(offer2);</span><br><span class="line">拿走组合<span class="number">2</span>;</span><br><span class="line">卷烟;</span><br><span class="line">抽烟;</span><br><span class="line">V(finish);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker3()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(offer3);</span><br><span class="line">拿走组合<span class="number">3</span>;</span><br><span class="line">卷烟;</span><br><span class="line">抽烟;</span><br><span class="line">V(finish);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读者写者问题">读者写者问题</h2><p><code>问题描述</code>：有读者和写者两组并发进程，共享一个文件，要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件写信息；③任一写者完成操作前不允许其他读者或写者工作；④写者执行写操作前，应让已有读者或写者全部退出；</p><blockquote><p>与消费者进程不同，读者进程在读数据后并不会将数据清空，不会改变数据；因此多个读者可以同时访问数据；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220810002224226.png" alt="image-20220810002224226"></p><p>互斥关系：写进程—写进程；写进程—读进程；</p><p><code>count变量</code>：用于记录当前需要访问文件的<code>读进程</code>，因为只有第一个读进程进入需要加锁，最后一个读进程退出才会释放锁；</p><p><code>mutex信号量</code>：用于实现对count变量的互斥访问，因为如果两个读进程并发执行，则两个读进程可能均满足count=0，造成进程阻塞；</p><p><code>w信号量</code>：用于实现&quot;写优先&quot;，类似如果读进程一直在读或者发生阻塞，则也会造成写进程阻塞，可能导致饿死（但并不是真正的写优先，只是类似先来先服务原则，如果写进程来了，后面的读进程就别来了，先给写进程，原有的读进程还可以接着读，读完自己悄悄溜走）；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;<span class="comment">//互斥信号，实现对文件互斥访问；</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore w = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(w);</span><br><span class="line">P(rw);</span><br><span class="line">写文件;</span><br><span class="line">V(rw);</span><br><span class="line">V(w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(w);</span><br><span class="line">P(mutex);</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">P(rw);</span><br><span class="line">count++;</span><br><span class="line">V(w);</span><br><span class="line">读文件;</span><br><span class="line">P(mutex);</span><br><span class="line">count --;</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">V(rw);</span><br><span class="line">V(mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哲学家进餐问题">哲学家进餐问题</h2><p><code>问题描述</code>：一张圆桌坐着5名哲学家，每两个哲学家之间摆一根筷子，桌子中间有一碗米饭，哲学家要么思考要么进餐；思考时，并不影响他人；哲学家饥饿时，才试图拿起左、右两根筷子（一根一根拿起），如果筷子已在他人手上，则需要等待，哲学家只有同时拿起两根筷子才可以开始进餐，进餐完毕继续思考；</p><p><img src="https://img.lishangcc.top//img/image-20220809183928280.png" alt="image-20220809183928280"></p><p>该问题只有互斥关系；5位哲学家与左右临界对中间筷子的访问是互斥的；可以对哲学家和筷子分别编号；</p><p><code>方案一</code>：允许最多4个哲学家同时拿筷子，这样至少可以保证有一个哲学家是可以拿到左右两根筷子的；</p><p><code>方案二</code>：奇数号哲学家先拿左边再拿右边，偶数则相反，这样可以保证相邻两个哲学家想吃饭，一个能从吃，一个阻塞；</p><p><code>方案三</code>：自己看吧，难说，总之设置一个互斥信号量mutex，当拥有拿筷子的权利（获得锁），尽量此时拿到左右两支筷子，如有一支别人用，就等一下，别人用完马上拿过来，这时把锁释放了谁要吃谁拿，自己先吃着了；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案三</span></span><br><span class="line">semaphore chopsticks[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//互斥地取筷子</span></span><br><span class="line"></span><br><span class="line">Pi()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(mutex);</span><br><span class="line">P(chopstick[i]);</span><br><span class="line">P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">V(mutex);</span><br><span class="line">吃饭;</span><br><span class="line">V(chopstick[i]);</span><br><span class="line">V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">思考;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果遇到一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题思想；</p></blockquote><h2 id="管程">管程</h2><p>管程是一种特殊的软件模块，由以下部分组成：</p><ol><li>局部于管程的共享数据说明；（如生产者与消费者模型中的缓冲区，可以通过数据结构表示该缓冲区）</li><li>对该数据结构进行操作的一组过程；（过程可以理解为函数，即管程中需要有一组对1中数据结构进行操作的函数）</li><li>对局部于管程的共享数据设置初始值的语句；</li><li>管程需要有一个名字；</li></ol><p><strong>管程的基本特征</strong></p><ol><li>局部于管程的数据只能被局部于管程的过程所访问；</li><li>一个进程只能通过调用管程内的过程才能进入管程访问共享数据；</li><li>每次仅允许一个进程在管程内执行某个内部过程；</li></ol><p><img src="https://img.lishangcc.top//img/image-20220814223304127.png" alt="image-20220814223304127"></p><h2 id="死锁">死锁</h2><h3 id="死锁的概念">死锁的概念</h3><p><code>死锁</code>：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进现象；</p><p><code>饥饿</code>：由于长期得不到想要的资源，某进程无法向前推进的现象；</p><p><code>死循环</code>：某进程执行过程中一直跳不出某个循环的现象；</p><p><img src="https://img.lishangcc.top//img/image-20220814224450116.png" alt="image-20220814224450116"></p><p><strong>死锁产生条件</strong></p><p>必须同时满足以下四个条件：</p><ol><li><code>互斥条件</code>：只有对必须互斥使用的资源的争抢才会导致死锁；（如哲学家的筷子、打印机设备）（像内存、扬声器这种可以同时运行多个进程使用的资源不会导致死锁）；</li><li><code>不剥夺条件</code>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放；</li><li><code>请求和保持条件</code>：进程已经保持了至少一个资源，但又提出新的资源请求，而该资源有被其他进程占有，此时请求进程被阻塞，但又对自己已有资源保持不放；</li><li><code>循环等待条件</code>：存在一种进程资源的循环等待链，链中的每个进程已获得的资源同时被下一个进程所请求；</li></ol><blockquote><p>注意：发生死锁时一定有循环等待，但发生循环等待未必死锁；</p><p>如果同类资源数大于1，则即使有循环等待也未必死锁，但如果每类资源都资源1，那么循环等待必然死锁；</p></blockquote><p><strong>发生死锁的情况</strong></p><p>①对系统资源的竞争；②进程推进顺序非法；③信号量使用不当等；</p><h3 id="死锁的处理策略">死锁的处理策略</h3><ol><li>预防死锁：破坏死锁产生条件的一个或多个；</li><li>避免死锁：用某种方法防止系统进入不安全状态，如银行家算法；</li><li>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁；</li></ol><h4 id="预防死锁">预防死锁</h4><p><strong>1.破坏互斥条件</strong></p><p><img src="https://img.lishangcc.top//img/image-20220814234323245.png" alt="image-20220814234323245"></p><p>缺点：并不是所有的资源都可以改造成共享使用的资源，并且为了系统安全，往往需要保护这种互斥性，因此<code>很多时候无法破坏互斥条件</code>；</p><p><strong>2.破坏不剥夺条件</strong></p><p><img src="https://img.lishangcc.top//img/image-20220814234631296.png" alt="image-20220814234631296"></p><p>缺点：①实现复杂；②释放已获得资源可能造成前一阶段工作失效；③反复申请和释放资源会增加系统开销，降低系统吞吐量；④方案一意味着只要暂时等不到某个资源，之前获得的资源都需要放弃，以后再重新申请，如果一直发生则可能导致进程饥饿；</p><p><strong>3.破坏请求和保持条件</strong></p><p>可以采用静态分配方法，即进程在运行前，一次申请完所需的全部资源，在它的资源未满足前，不让它投入运行，一旦投入运行，这些资源就一直归它所要，该进程就不会请求别的资源了；</p><p>缺点：有些资源可能只需要用很短的时间，如果进程的整个运行期间都一直保持所有资源，就会造成严重的资源浪费，<code>资源利用率极低</code>，另外，该策略也可能<code>导致某些进程饥饿</code>；</p><p><strong>4.破坏循环等待条件</strong></p><p><img src="https://img.lishangcc.top//img/image-20220814235657281.png" alt="image-20220814235657281"></p><blockquote><p>①第二点缺点的解释：假设在实际使用过程中进程P3是先使用7号后使用5号，但根据编号递增顺序的要求，P3必须先申请使用5号，再申请使用7号，则在P3实际运行中5号某些时间是空闲的</p><p>②用户编程麻烦的原因：不同主机对不同设备的编号可能不同，但编号的不同会影响申请资源的顺序，即程序需要根据编号的不同而变化</p></blockquote><h4 id="避免死锁">避免死锁</h4><p><code>安全序列</code>：指系统如果按照这种序列分配资源，则每个进程都能顺利完成；只要能找出一个安全序列，系统就是安全状态，安全序列可能有多个；</p><blockquote><p>如果分配资源后，系统找不出任何一个安全序列，则系统进入不安全状态，意味着之后可能所有进程都无法顺利执行下去；</p><p>处于安全状态一定不会发生死锁，不安全状态未必发生死锁，但发生死锁一定在不安全状态；</p></blockquote><p><code>银行家算法</code>：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态；如果会进入不安全状态，则暂时不答应这次请求，让该进程阻塞等待；</p><p><img src="https://img.lishangcc.top//img/image-20220815132305555.png" alt="image-20220815132305555"></p><p>①已分配资源总和为{7,2,5}，用总数减去已分配的，剩余{3,3,2}，最多还需要资源满足的有P1和P3，因此加入安全序列；（先满足P1，而后P1归还资源（包括已分配的）再满足P3，P3又归还资源）此时剩余(2,0,0)+(2,1,1)+(3,3,2)=(7,4,3)</p><p>②此时还剩进程P0,P2,P4，按P0→P2→P4排序即可；</p><p>③最终安全序列{P1，P3，P0，P2，P4}；</p><p>下面为具体实现，慢慢看：</p><p><img src="https://img.lishangcc.top//img/image-20220815133455482.png" alt="image-20220815133455482"></p><p><img src="https://img.lishangcc.top//img/image-20220815133509205.png" alt="image-20220815133509205"></p><h4 id="死锁的检测和解除">死锁的检测和解除</h4><p><strong>1.死锁检测</strong></p><p>①用某种数据结构来保存资源的请求和分配信息；</p><blockquote><p><img src="https://img.lishangcc.top//img/image-20220815134547241.png" alt="image-20220815134547241"></p></blockquote><p>②提供一种算法，利用上述信息检测系统是否进入死锁状态；</p><blockquote><p>依次消除与不阻塞进程相连的边，直到无边可消；（不阻塞进程：其申请资源数还足够的进程）</p><p>死锁定理：若资源分配图是不可完全简化的，说明发生了死锁；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220815135035750.png" alt="image-20220815135035750"></p><blockquote><p>解释一下：</p><ol><li>P2向R1申请1个资源，而此时R1没有多余资源；</li><li>P1向R2申请一个资源，此时R2仍剩余1个资源，则分配出去，P1执行完后归还全部占有资源，此时R1拥有2个资源；</li><li>R1剩余的2个资源可以满足P2的1个资源申请请求，P2执行完也归还占有资源；</li><li>至此，全部边消除，所以P1和P2不会发生死锁；</li></ol></blockquote><p><img src="https://img.lishangcc.top//img/image-20220815135719090.png" alt="image-20220815135719090"></p><blockquote><p>该图中，仅有P3的线可以消除，归还R2一个资源后，其他P1和P2进程依然阻塞，所以必然发生死锁；</p></blockquote><p><strong>2.死锁的解除</strong></p><p><code>①资源剥夺法</code>：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程；但是应防止被挂起的进程长时间得不到资源而饿死；</p><p><code>②撤销进程法</code>：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源；实现简单，但付出代价也大；</p><p><code>③进程回退法</code>：让一个或多个死锁进程回退到足以避免死锁的地步，这要求系统记录进程历史信息，设置还原点；</p><blockquote><p>如何决定对哪个进程&quot;动手&quot;：</p><p>进程优先级；已执行多长时间；还要多久完成；进程已使用多少资源；进程是交互式还是批处理式的；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 进程与线程(上)</title>
      <link href="/myblog/2022/07/31/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-07-31-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B1/"/>
      <url>/myblog/2022/07/31/2022/408%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-07-31-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<h2 id="进程简述">进程简述</h2><blockquote><p>区别一下程序与进程：</p><p>程序：静态的，就是存放在磁盘里的可执行文件，如：QQ.exe；</p><p>进程：动态的，是程序一次执行过程，如：同时打开多个QQ程序（同一个程序多次执行会对应多个进程）；</p></blockquote><h3 id="进程实体的组成">进程实体的组成</h3><p>进程由<code>PCB</code>、<code>程序段</code>、<code>数据段</code>三部分组成；</p><p>PCB：介绍见下面；</p><p>程序段：程序的代码（指令序列）；</p><p>数据段：运行过程中产生的各种数据（如：程序中定义的变量）；</p><blockquote><p>PCB是给操作系统用的，程序段、数据段是给进程自己用的；</p><p>程序可被多个进程共享，即多个进程可以运行同一个程序；</p></blockquote><h3 id="进程控制块PCB">进程控制块PCB</h3><p>PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，回收其PCB；</p><p><strong>PCB保存的信息</strong></p><p><img src="https://img.lishangcc.top//img/image-20220801214628303.png" alt="image-20220801214628303"></p><h3 id="进程的特征">进程的特征</h3><ul><li><code>动态性（最基本特征）</code>：进程是程序的一次执行过程，动态地产生、变化和消亡；</li><li><code>并发性</code>：内存中有多个进程实体，各进程可并发执行；</li><li><code>独立性</code>：进程能独立运行、独立获得资源、独立接受调度的基本单位；</li><li><code>异步性</code>：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供进程同步机制解决异步问题；</li><li><code>结构性</code>：每个进程都会配置PCB，结构上看，进程由程序段、数据段、PCB组成；</li></ul><h2 id="进程的状态与转换">进程的状态与转换</h2><h3 id="进程的状态">进程的状态</h3><p>进程在其生命周期内，由于系统中各进程之间的相互制约及系统的运行环境的变化，使得进程的状态也在不断变化，一般认为进程有以下5种状态，其中中间三种为基本状态；</p><ul><li>创建态：程序正在被创建，尚未转到就绪态，创建进程需要多个步骤：</li><li>就绪态：进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行，系统中同一时间处于就绪状态的进程可能有多个，通常将它们排成一个队列；</li><li>运行态：进程正在处理机上运行，在单处理机中，每个时刻只有一个进程处于运行态；</li><li>阻塞态：又称等待态，进程执行过程中，可能因等待某一事件而暂停运行；</li><li>结束态：也称终止态，进程正在从系统中消失，可能是进程正常结束或其他原因退出运行；</li></ul><h3 id="状态的转换">状态的转换</h3><p>一般认为存在6种状态转换形式；</p><p><img src="https://img.lishangcc.top//img/image-20220801235933386.png" alt="image-20220801235933386"></p><p>**就绪态→运行态：**处于就绪态的进程被调度后，获得处理机资源，进程由就绪态转换为运行态；</p><p>**运行态→就绪态：**处于运行态的进程在时间片用完后，不得不让出处理机，从而进程由运行态转换为就绪态；</p><p>**运行态→阻塞态：**进程请求某一资源（如外设）的使用或等待某一事件的发生（如等待I/O操作的完成）时，运行态转换为阻塞态；</p><p>**阻塞态→就绪态：**进程等待的事件到来时，中断处理程序必须把相应进程的状态由阻塞态转换为就绪态；</p><h2 id="进程控制">进程控制</h2><p>进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能；</p><p>一般把进程控制的程序段称为原语，执行具有原子性，即执行期间不允许被中断；</p><p>可以用<code>关中断指令</code>和<code>开中断指令</code>这两个特权指令实现原子性；</p><h3 id="进程的创建">进程的创建</h3><p><img src="https://img.lishangcc.top//img/image-20220802100109849.png" alt="image-20220802100109849"></p><h3 id="进程的终止">进程的终止</h3><p><img src="https://img.lishangcc.top//img/image-20220802100148461.png" alt="image-20220802100148461"></p><h3 id="进程的阻塞和唤醒">进程的阻塞和唤醒</h3><p><img src="https://img.lishangcc.top//img/image-20220802100226334.png" alt="image-20220802100226334"></p><h3 id="进程的切换">进程的切换</h3><p><img src="https://img.lishangcc.top//img/image-20220802100315037.png" alt="image-20220802100315037"></p><h2 id="进程通信">进程通信</h2><p>进程间通信（IPC）：两个进程之间产生数据交互；</p><p>进程是分配系统资源的单位，因此各进程拥有的内存地址空间相互独立；</p><h3 id="共享存储">共享存储</h3><p>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换；一般有两种方式；</p><blockquote><p>为避免出错，各进程对共享空间的访问应该是互斥的，即如果一个进程正在访问共享空间，则其他进程不能访问；</p><p>各个进程可使用操作系统内核提供的同步互斥工具（如P、V操作）；</p></blockquote><p><strong>1.基于存储区共享</strong></p><p><img src="https://img.lishangcc.top//img/image-20220802104554051.png" alt="image-20220802104554051"></p><p>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统，这种方式速度很快，是一种高级通信方式；</p><p><strong>2.基于数据结构共享</strong></p><p><img src="https://img.lishangcc.top//img/image-20220802120252857.png" alt="image-20220802120252857"></p><p>比如共享空间里只能放一个长度为10的数组，这种方式速度慢，限制多，是一种低级通信方式；</p><h3 id="消息传递">消息传递</h3><p>进程间的数据交换以<code>格式化的消息</code>（Message）为单位，进程通过操作系统提供的<code>发送消息/接收消息</code>两个原语进行数据交换；一般也有两种方式；</p><p><strong>1.直接通信方式</strong></p><p>点名道姓的形式说明我是谁，我要发给谁；</p><p><img src="https://img.lishangcc.top//img/image-20220802121001891.png" alt="image-20220802121001891"></p><p><strong>2.间接通信方式</strong></p><p>以&quot;信箱&quot;作为中间实体进行消息传递；</p><p><img src="https://img.lishangcc.top//img/image-20220802120800991.png" alt="image-20220802120800991"></p><h3 id="管道通信">管道通信</h3><p>&quot;管道&quot;是一个特殊的共享文件，又名pipe文件，用于连接一个读进程一个写进程，以实现它们之间的通信；</p><p><img src="https://img.lishangcc.top//img/image-20220802190017105.png" alt="image-20220802190017105"></p><ul><li>管道只能采用半双工通信，即某一时间段内只能实现单向的传输，如果要实现双向同时通信，则需要设置两个管道；</li><li>各进程要互斥地访问管道（由操作系统实现）；</li><li>当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程；</li><li>当管道读空时，读进程将阻塞，直到写进程往管道写入新数据，即可唤醒读进程；</li><li>管道中的数据一旦读出，就彻底消失，因此当多个进程读同一个管道时，可能会错乱，对此一般有两种解决方案：①一个管道运行多个写进程，一个读进程（这里只说一种）；</li><li>只要管道没空，读进程就可以从管道读数据；只要管道没满，写进程就可以往管道写数据；</li></ul><h2 id="线程简述">线程简述</h2><h3 id="线程的概念">线程的概念</h3><p>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐率；</p><p>引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能；</p><p><img src="https://img.lishangcc.top//img/image-20220802191538760.png" alt="image-20220802191538760"></p><p>可以把线程理解为轻量级进程；</p><p>线程是一个基本的CPU的执行单元，也是程序执行流的最小单位；</p><p>引入线程后，不仅是进程之间可以并发，进程内的各线程自己也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务；</p><p>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间都是分配给进程的），线程则作为处理机的分配单元；</p><h3 id="线程带来的变化">线程带来的变化</h3><p><img src="https://img.lishangcc.top//img/image-20220802191755499.png" alt="image-20220802191755499"></p><blockquote><p>理解一下运行环境：</p><p>假设去图书馆看书，桌子=处理机，人=进程，看不同的书=线程；<br>切换进程运行环境：有一个不认识的人要用桌子，此时你需要把书搬走，他把自己的书放到桌子上；<br>同一进程内线程切换：你的舍友要用你的桌子，而你们所学相同，则你不用把书搬走；</p></blockquote><h3 id="线程的属性">线程的属性</h3><ul><li>线程是处理机调度的单位；</li><li>多CPU计算机中，各个线程可占用不同的CPU；</li><li>每个线程都有一个线程ID、线程控制块（TCB）；</li><li>线程也有就绪、阻塞、运行三种基本状态；</li><li>线程几乎不拥有系统资源；</li><li>同一线程的不同线程间共享进程的资源；</li><li>由于共享内存地址空间，同一进程中的线程通信甚至不需要系统干预；</li><li>同一进程中的线程切换，不会引起进程切换；</li><li>不同进程中的线程切换，会引起进程切换；</li><li>切换同进程内的线程，系统开销很小；</li><li>切换进程，系统开销较大；</li></ul><h3 id="线程的实现方式">线程的实现方式</h3><p>分两类：用户级线程（ULT）、内核级线程（KLT）；</p><p><strong>1.用户级线程(ULT)</strong></p><p>在用户级线程中，有关线程管理（创建、撤销、切换等）的所有工作都由应用程序在用户空间中完成，内核意识不存在；</p><p>对于设置了用户级线程的系统，其调度仍以进程为单位进行；</p><p><img src="https://img.lishangcc.top//img/image-20220803150841465.png" alt="image-20220803150841465"></p><p>从代码角度看，线程就是一段代码逻辑，此段代码可看作三个&quot;线程&quot;，这个循环体就是一个简易的&quot;线程库&quot;；</p><p><img src="https://img.lishangcc.top//img/image-20220803151952517.png" alt="image-20220803151952517"></p><blockquote><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高；</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度并不高，多个线程不可在多核处理机上并行运行；</p></blockquote><p><strong>2.内核级线程(KLT)</strong></p><p>大多数现代操作系统都实现了内核级线程，如：Windows、Linux；</p><p>内核级线程的管理工作由操作系统内核完成，包括线程调度、切换；操作系统会为每个内核级线程建立相应TCP（线程控制块），通过TCP对线程进行管理；</p><p><img src="https://img.lishangcc.top//img/image-20220803153019916.png" alt="image-20220803153019916"></p><blockquote><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可在多核处理机上并行执行；</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理成本高，开销大；</p></blockquote><h3 id="多线程模型">多线程模型</h3><p>有些系统同时支持用户线程和内核线程，由于用户线程和内核线程连接方式的不同，从而形成三种不同的多线程模型；</p><blockquote><p>可以这么理解：</p><p>用户级线程是&quot;代码逻辑&quot;的载体；<br>内核级线程是&quot;运行机会&quot;的载体；<br>一段&quot;代码逻辑&quot;只有获得&quot;运行机会&quot;才能被CPU执行；</p></blockquote><p><strong>一对一模型</strong></p><p>一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程；</p><p><img src="https://img.lishangcc.top//img/image-20220803172111702.png" alt="image-20220803172111702"></p><blockquote><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可在多核处理机上并行执行；</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大；</p></blockquote><p><strong>多对一模型</strong></p><p>多个用户级线程映射到一个内核级线程，且一个进程只被分配一个内核级线程；</p><p><img src="https://img.lishangcc.top//img/image-20220803172349524.png" alt="image-20220803172349524"></p><blockquote><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高；</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行；</p><p><strong>注意：操作系统只看得见内核级线程，因此只有内核级线程才是处理机分配的单位；</strong></p></blockquote><p><strong>多对多模型</strong></p><p>n个用户级线程映射到m个内核级线程(n&gt;=m)，每个用户进程对应m个内核级线程；</p><p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销大的缺点；</p><p><img src="https://img.lishangcc.top//img/image-20220803172729910.png" alt="image-20220803172729910"></p><h3 id="线程的状态与转换">线程的状态与转换</h3><p>与进程一样，各线程之间也存在共享资源和相互合作的制约关系，致使线程在运行时也具有间断性，相应的，线程在运行时，也具有下面三种基本状态：</p><ul><li><code>执行状态</code>：线程已获得处理机而正在运行；</li><li><code>就绪状态</code>：线程已具备各种执行条件，只需再获得CPU便可立即执行；</li><li><code>阻塞状态</code>：线程在执行中因某事件受阻而处于暂停状态；</li></ul><p><img src="https://img.lishangcc.top//img/image-20220803183231274.png" alt="image-20220803183231274"></p><blockquote><p>线程三种基本状态的转换与进程的状态转换一样，参考上面的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章总线</title>
      <link href="/myblog/2022/07/27/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-27-%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%80%BB%E7%BA%BF/"/>
      <url>/myblog/2022/07/27/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-27-%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="总线概述">总线概述</h2><p>总线是一组能为多个部件<code>分时</code> <code>共享</code>的公共信息传送线路；</p><p><img src="https://img.lishangcc.top//img/image-20220729134130819.png" alt="image-20220729134130819"></p><blockquote><p>为什么要用总线？</p><p>早期计算机外部设备少时大多采用分散连接方式，不易实现随时增减外部设备；<br>为了更好解决I/O设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接</p></blockquote><p>分时：同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时的向总线发送信息；</p><p>共享：总线上可以挂接多个部件，各个部件之间互相交换信息都快通过这组线路分时共享，多个部件可同时从总线上接收相同的信息；</p><h3 id="总线的特性">总线的特性</h3><ul><li>机械特性：尺寸、形状、管脚数、排列顺序；</li><li>电气特性：传输方向和有效的电平范围；</li><li>功能特性：每根传输线的功能（地址、数据、控制）；</li><li>时间特性：信号的时序关系；</li></ul><h3 id="总线的数据传输格式">总线的数据传输格式</h3><h4 id="串行总线">串行总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729134955144.png" alt="image-20220729134955144"></p><p>优点：只需要一个条传输线，成本低廉，广泛应用于长距离传输；应用于计算机内部时，可以节省布线空间；</p><p>缺点：在数据发送和接收时，要进行拆卸和装配，要考虑串行-并行转换的问题；</p><h4 id="并行总线">并行总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729135144434.png" alt="image-20220729135144434"></p><p>优点：总线的逻辑时序比较简单，电路实现起来比较容易；</p><p>缺点：信号线数量多，占用更多的布线空间；远距离传输成本高；</p><h3 id="总线按功能分类">总线按功能分类</h3><h4 id="片内总线">片内总线</h4><p>片内总线是芯片内部的总线，它是CPU芯片内部<code>寄存器</code>和<code>寄存器</code>、<code>寄存器</code>与<code>ALU</code>之间的公共连接线；</p><h4 id="系统总线">系统总线</h4><p>是计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线；</p><p>按系统总线传输信息内容的不同，又可分为3类：<code>数据总线</code>、<code>地址总线</code>、<code>控制总线</code>；</p><p><strong>数据总线（DB）</strong>：传输各功能部件之间的数据信息，包括指令、操作数；位数（根数）与<code>机器字长</code>、<code>存储字长</code>有关，<code>双向</code>；</p><p><strong>地址总线（AB）</strong>：传输地址信息，包括主存单元或I/O端口的地址，位数（根数）与<code>主存地址空间大小</code>及<code>设备数量</code>有关，<code>单向</code>；</p><p><strong>控制总线（CB）</strong>：传输控制信息，一根控制线传输一个信号，有出：CPU送出的控制命令；有入：主存（或外设）返回CPU的反馈信号；</p><h4 id="通信总线">通信总线</h4><p>通信总线用于计算机系统之间或计算机系统与其他系统（如：远程通信设备、测试设备）之间信息传递的总线，也称外部总线；</p><h3 id="系统总线的结构">系统总线的结构</h3><h4 id="单总线">单总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729140252228.png" alt="image-20220729140252228"></p><p>单总线结构将CPU、主存、I/O设备（通过I/O接口）都挂载一组总线上，运行I/O设备之间、I/O设备与主存之间交换信息；</p><blockquote><p>优点：结构简单，成本低，易于接入新设备；</p><p>缺点：带宽低，负载重，多个部件只能争用唯一总线，且不支持并发传送操作；</p></blockquote><h4 id="双总线">双总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729140722038.png" alt="image-20220729140722038"></p><p>双总线结构有两条总线，一条是<code>主存总线</code>，用于CPU、主存和通道之间进行数据传送；另一条是<code>I/O总线</code>，用于多个设备与通道之间进行数据传送；</p><blockquote><p>一些概念</p><p>通道：具有特殊功能的处理器，能对I/O设备进行统一管理，通道程序存放在主存中；</p></blockquote><blockquote><p>优点：将较低速的I/O设备从单总线上分离出来，实现存储器总线和I/O总线的分离；</p><p>缺点：需要增加通道等硬件设备；</p></blockquote><h4 id="三总线">三总线</h4><p><img src="https://img.lishangcc.top//img/image-20220729141117455.png" alt="image-20220729141117455"></p><p>三条总线结构是计算机系统各部件之间采用3条各自独立的总线来构成信息通路，3条总线分别为：<code>主存总线</code>、<code>I/O总线</code>、<code>直接内存访问DMA总线</code>；</p><blockquote><p>优点：提高了I/O设备的性能，使其更快响应命令，提高系统的吞吐量；</p><p>缺点：系统工作效率较低；</p></blockquote><h2 id="总线性能指标">总线性能指标</h2><p><strong>总线传输周期（总线周期）</strong></p><p>一次总线操作所需的时间（包括<code>申请阶段</code>、<code>寻址阶段</code>、<code>传输阶段</code>和<code>结束阶段</code>），通常由若干个总线时钟周期构成；</p><p><strong>总线时钟周期</strong></p><p>即机器的时钟周期；计算机系统有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制；</p><p><strong>总线的工作频率</strong></p><p>总线上各种操作的频率，为总线周期的倒数；理解：1秒内传送几次数据；</p><p><strong>总线的时钟频率</strong></p><p>即机器的时钟频率，为时钟周期的倒数；</p><p><strong>总线宽度</strong></p><p>又称总线位宽，它是总线上同时能够传输的数据位数，通常指数据总线的根数，如32根又称32位总线；</p><p><strong>总线带宽</strong></p><p>可理解为总线的最大数据传输率，即单位时间内总线上最多可传输数据的位数；通常以每秒传送信息的字节数来衡量，即 字节/秒（B/s）表示；</p><blockquote><p>总线带宽 = 总线工作频率 × （总线宽度/8）（B/s）</p></blockquote><p><strong>总线复用</strong></p><p>指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息；</p><p><strong>信号线数</strong></p><p>地址总线、数据总线、控制总线，3种总线数的总和称为信号线数；</p><h2 id="总线操作和定时">总线操作和定时</h2><p><strong>总线周期的四个阶段</strong></p><ol><li><code>申请分配阶段</code>：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者，也可将此阶段细分为传输请求和总线仲裁两个阶段；</li><li><code>寻址阶段</code>：获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，启动参与本次传输的从模块；</li><li><code>传输阶段</code>：主模块和从模块进行数据交换，可单向或双向进行数据传送；</li><li><code>结束阶段</code>：主模块的有关信息均从系统总线上撤除，让出总线使用权；</li></ol><h3 id="总线定时">总线定时</h3><p>指总线在双方交换数据的过程中，需要时间上配合关系的控制，这种控制称为总线定时，它的实质是一种协议；</p><h4 id="同步通信">同步通信</h4><p>也叫同步定时方式，由采用一个<code>统一时钟</code>来协调发送和接收双方的传送定时关系；</p><blockquote><p>假设：CPU作为主设备，某个输入设备作为从设备；</p><p><img src="https://img.lishangcc.top//img/image-20220729164450433.png" alt="image-20220729164450433"></p><ol><li>CPU在T1时刻的上升沿给出地址信息；</li><li>在T2上升沿给出读命令（低电平有效），与地址信息相符合的输入设备按命令进行一系列的内部操作，且必须在T3的上升沿之前将CPU所需的数据送到数据总线上；</li><li>CPU在T3时钟周期内，将数据线上的信息传送到其内部寄存器中；</li><li>CPU在T4上升沿撤销读命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动；</li></ol><p>注：如果从设备跟不上节奏，在T3给不出数据，就哦豁了；</p></blockquote><p>若干个时钟产生相等的时间间隔，每个间隔构成一个总线周期；</p><p>在一个总线周期中，发送方和接收方可进行一次数据传送；</p><p>因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始；</p><blockquote><p>优点：传送速度快快，具有较高的传输速率，总线控制逻辑简单；</p><p>缺点：自从设备属于强制性同步，不能及时进行数据通信的有效性检验，可靠性较差；</p><p>适用：同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统；</p></blockquote><h4 id="异步通信">异步通信</h4><p>也叫异步定时方式，其没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方制约的&quot;握手&quot;信号来实现定时控制；</p><p>主设备提出交换信息的请求信号，经接口传送到从设备，从设备接到主设备的请求后，通过接口想主设备发出回答信号；</p><p>根据&quot;请求&quot;和&quot;回答&quot;信号的撤销是否互锁，分为以下3种类型：</p><p><strong>1.不互锁方式</strong></p><blockquote><p>特点：速度最快，可靠性最差；</p></blockquote><p>主设备发出&quot;请求&quot;信号后，不必等到接收设备的&quot;回答&quot;信号，而是经过一段时间后，便撤销&quot;请求&quot;信号；</p><p>而从设备在接到&quot;请求&quot;信号后，发出&quot;回答&quot;信号，并经过一段时间，自动撤销&quot;回答&quot;信号，双方不存在互锁关系；</p><p><strong>2.半互锁方式</strong></p><p>主设备发出&quot;请求&quot;信号后，必须待接到从设备的&quot;回答&quot;信号后，才撤销&quot;请求&quot;信号，有互锁关系；</p><p>而从设备在接到&quot;请求&quot;信号后，发出&quot;回答&quot;信号，但不必等待主设备&quot;请求&quot;信号撤销，而是隔一段时间后自动撤销&quot;回答&quot;信号，这里不存在互锁关系；</p><p><strong>3.全互锁方式</strong></p><blockquote><p>特点：最可靠，速度最慢；</p></blockquote><p>主设备发出&quot;请求&quot;信号后，必须待从设备&quot;回答&quot;后，才撤销&quot;请求&quot;信号；</p><p>从设备发出&quot;回答&quot;信号后，必须待获知主设备&quot;请求&quot;信号已撤销后，在撤销其&quot;回答&quot;信号；</p><blockquote><p>异步定时方式</p><p>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠的进行信息交换，自动适应时间的配合；</p><p>缺点：比同步控制方式复杂，速度也比同步定时方式慢；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章中央处理器</title>
      <link href="/myblog/2022/07/22/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-22-%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/myblog/2022/07/22/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-22-%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="CPU概述">CPU概述</h2><p>CPU由<code>运算器</code>和<code>控制器</code>组成；</p><p>运算器：对数据进行加工；</p><p>控制器：协调并控制计算机各部件执行程序的指令序列，包括：取指令、分析指令、执行指令；</p><h3 id="运算器基本结构">运算器基本结构</h3><ol><li><strong>算术逻辑单元（ALU）</strong>：进行算术/逻辑运算；</li><li><strong>暂存寄存器</strong>：暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏原有内容；暂存寄存器对程序员是透明的（即不可见）；</li><li><strong>累加寄存器（ACC）</strong>：一个通用寄存器，用于暂时存放ALU的运算结果信息，可以作为加法运算的一个输入端；</li><li><strong>通用寄存器</strong>：用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息；</li><li><strong>程序状态寄存器（PSW）</strong>：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如：溢出标志OF、符号标志SF、零标志ZF、进位标志CF；</li><li><strong>移位器</strong>：对操作数或运算结果进行移位操作运算；</li><li><strong>计数器（CT）</strong>：控制乘除运算的操作步数（乘除结果也是由多次加减得来）；</li></ol><h3 id="控制器基本结构">控制器基本结构</h3><ol><li><strong>程序计数器（PC）</strong>：用于指出下一条指令在主存中的存放地址，PC有自增的功能；</li><li><strong>指令寄存器（IR）</strong>：保存当前正在执行的那条指令；</li><li><strong>指令译码器</strong>：仅对操作码字段进行译码，向控制器提供特定的操作信号；</li><li><strong>存储器地址寄存器（MAR）</strong>：存放要访问的主存单位的地址；</li><li><strong>存储器数据寄存器（MDR）</strong>：存放向主存写入的信息或从主存读出的信息；</li><li><strong>时序系统</strong>：用于产生各种时序信号，由统一时钟（CLOCK）分频得到；</li><li><strong>微操作信号发生器</strong>：根据IR的内容（指令）、PSW的状态信息及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种；</li></ol><h3 id="CPU基本结构">CPU基本结构</h3><p><img src="https://img.lishangcc.top//img/image-20220723000539085.png" alt="image-20220723000539085"></p><p>红框：用户可见；</p><p>灰框：用户不可见；</p><h3 id="CPU功能">CPU功能</h3><ol><li>指令控制</li><li>操作控制</li><li>时间控制</li><li>数据加工</li><li>中断处理</li></ol><h2 id="指令的执行">指令的执行</h2><h3 id="指令周期数据流">指令周期数据流</h3><p>CPU从主存中每取出并执行一条指令所需的全部时间；</p><p>指令周期常常用<code>若干机器周期</code>表示，机器周期又叫CPU周期；</p><p>一个机器周期又包含<code>若干时钟周期</code>（CPU操作的最基本单位）；</p><p>每个指令周期内机器周期可以不相等，每个机器周期内的时钟周期也可以不相等；</p><p><img src="https://img.lishangcc.top//img/image-20220724002535067.png" alt="image-20220724002535067"></p><h3 id="指令周期流程">指令周期流程</h3><p><img src="https://img.lishangcc.top//img/image-20220723185713352.png" alt="image-20220723185713352"></p><ul><li>取指周期：取指令；</li><li>间址周期：取有效地址，只在间接寻址有；</li><li>执行周期：取操作数；</li><li>中断周期：保存程序断点；</li></ul><blockquote><p>每个周期都有CPU访存操作；</p><p>为判断指令处于哪个周期，可设置相应触发器：FE（置1，取指周期）、IND（置1，间址周期）、EX（置1，执行周期）、INT（置1，中断周期）；</p></blockquote><h4 id="取指周期">取指周期</h4><ol><li>当前指令地址送至存储器地址寄存器，记：（PC）→MAR；</li><li>控制单元（CU）发出控制信号，经控制总线传到主存，读信号为例，记：1→R；</li><li>将MAR所指主存中的内容经数据总线送入MDR，记：M（MAR）→MDR；</li><li>将MDR中的内容（此时是指令）送入IR，记：（MDR）→IR；</li><li>CU发出控制信号，形成下一条指令地址，记：（PC）+1→PC；</li></ol><p><img src="https://img.lishangcc.top//img/image-20220723092248358.png" alt="image-20220723092248358"></p><h4 id="间址周期">间址周期</h4><p>指令采用间接寻址才有；</p><ol><li>将指令的地址码送入MAR，记：Ad（IR）→MAR 或 Ad（MDR）→MAR；</li><li>CU发出控制信号，启动主存做读操作，记：1→R；</li><li>将MAR所指主存中的内容经数据总线送入MDR，记：M（MAR）→MDR；</li><li>将有效地址送至指令的地址码字段，记：（MDR）→Ad（IR）；</li></ol><p><img src="https://img.lishangcc.top//img/image-20220723093028670.png" alt="image-20220723093028670"></p><h4 id="执行周期">执行周期</h4><p>根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果，不同指令的执行周期不同，因此没有统一的数据流向；</p><h4 id="中断周期">中断周期</h4><p>中断：暂停当前任务去完成其他任务，为了能够恢复当前任务，需保存断点；</p><p>一般使用堆栈来保存断点，<strong>这里用SP表示栈顶地址</strong>，假设SP指向栈顶元素，进栈操作是先修改指针，后存入数据；</p><ol><li>CU控制将SP减1，修改后的地址送入MAR，记：（SP）-1→SP，（SP）→MAR；（本质上是将断点存入某个存储单元，假设其地址为a，记：a→MAR）；</li><li>CU发出控制信号，启动主存做<code>写操作</code>，记：1→W；</li><li>将断点（PC的内容）送入MDR，记：（PC）→MDR；</li><li>CU控制将终端服务程序的入口地址（由向量地址形成部件产生）送入PC，记：向量地址→PC；</li></ol><blockquote><p>理解一下：若某程序发生中断，之后将会执行新程序，执行完新程序后，根据中断时压入堆栈的栈顶元素恢复PC的值以找到之前的程序；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220723184459107.png" alt="image-20220723184459107"></p><h2 id="数据通路">数据通路</h2><p>即数据在功能部件之间传送的路径；</p><p>考法：给一条指令，分析各阶段的微操作序列和控制信号；</p><h3 id="CPU内部单总线方式">CPU内部单总线方式</h3><blockquote><p>扩展一下：</p><p><strong>内部总线</strong>：指同一部件，如CPU内部连接各寄存器及运算部件之间的总线；</p><p><strong>系统总线</strong>：指同一台计算机系统的各部件，如CPU、内存、通道、各类I/O接口之间相互连接的总线；</p></blockquote><ol><li><p><strong>寄存器之间数据传送</strong></p><p><code>比如把PC内容送至MAR</code>，实现传送操作的流程及控制信号为：</p><ul><li><p><code>(PC)→Bus</code>PCout有效，PC内容送总线（Bus为总线的意思）；</p></li><li><p><code>Bus→MAR</code>MARin有效，总线内容送MAR；</p></li></ul></li><li><p><strong>主存与CPU之间数据传送</strong></p><p><code>比如CPU从主存读取指令</code>，实现传送操作的流程及控制信号为：</p><ul><li><code>(PC)→Bus→MAR</code>PCout和MARin有效，现行指令地址传给MAR；</li><li><code>1→R </code>                            CU发出读命令（通过控制总线发出）；</li><li><code>MEM（MAR）→MDR</code>     MDRin有效；</li><li><code>MDR→Bus→IR </code>           MDRout和IRin有效，现行指令传给IR；</li></ul></li><li><p><strong>执行算术或逻辑运算</strong></p><p><code>比如一条加法指令</code>，微操作序列及控制信号为：</p><ul><li><p><code>Ad(IR)→Bus→MAR</code>MDRout和MARin有效；</p></li><li><p><code>1→R</code>CU发出读命令；</p></li><li><p><code>MEN(MAR)→数据线→MDR</code>MDRin有效；</p></li><li><p><code>MDR→Bus→Y</code>MDRout和Yin有效，操作数传给Y；</p></li><li><p><code>(ACC)+(Y)→Z</code>ACCout和ALUin有效，CU向ALU发送加命令；</p></li><li><p><code>Z→ACC</code>Zout和ACCin有效，结果传给ACC；</p></li></ul><blockquote><p>例题</p><p>如图所示的单总线结构，分析指令ADD（R0），R1的指令流程和控制信号；</p><p><img src="https://img.lishangcc.top//img/image-20220724100852572.png" alt="image-20220724100852572"></p><p><strong>取指周期</strong>：公共操作</p><table><thead><tr><th style="text-align:center">时序</th><th style="text-align:center">微操作</th><th style="text-align:center">有效控制信号</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">(PC)→MAR</td><td style="text-align:center">PCout，MARin</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">M(MAR)→MDR<br />(PC)+1→PC</td><td style="text-align:center">MemR，MARout，MDRinE</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">(MDR)→IR</td><td style="text-align:center">MDRout，IRin</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">指令译码</td><td style="text-align:center">-</td></tr></tbody></table><p><strong>间址周期</strong>：完成取数操作，被加数在主存中，加数已放在寄存器R1中；（题目中R0带括号，表示存的是一个地址，即采用间接寻址，被加数在其所指向的地址中，而R1不带括号，即加数直接存在寄存器R1中）</p><table><thead><tr><th style="text-align:center">时序</th><th style="text-align:center">微操作</th><th style="text-align:center">有效控制信号</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">(R0)→MAR</td><td style="text-align:center">R0out，MARin</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">M(MAR)→MDR</td><td style="text-align:center">MemR，MARout，MDRinE</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">(MDR)→Y<br /># Y为暂存寄存器</td><td style="text-align:center">MDRout，Yin</td></tr></tbody></table><p><strong>执行周期</strong>：最终结果放在主存中，即R0所指地址中；</p><table><thead><tr><th style="text-align:center">时序</th><th style="text-align:center">微操作</th><th style="text-align:center">有效控制信号</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">(R1)+(Y)→Z</td><td style="text-align:center">R1out，ALUin，CU向ALU发ADD控制信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">(Z)→MDR</td><td style="text-align:center">Zout，MDRin</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">(MDR)→M(MAR)</td><td style="text-align:center">MemW，MDRoutE，MARout</td></tr></tbody></table></blockquote></li></ol><h3 id="专用数据通路方式">专用数据通路方式</h3><h2 id="控制器设计">控制器设计</h2><h3 id="硬布线控制器">硬布线控制器</h3><p><img src="https://img.lishangcc.top//img/image-20220724111051638.png" alt="image-20220724111051638"></p><p>取指周期微操作时序安排</p><p>间址周期微操作时序安排</p><p>执行周期微操作时序安排</p><h3 id="微程序控制器">微程序控制器*</h3><p><code>微程序</code>设计思想：将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令；</p><p>这些微程序可以存放在一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的命令；</p><blockquote><p><code>程序</code>：由指令序列组成；</p><p><code>微程序</code>：由微指令序列组成，每一种指令对应一个微程序；</p><p>指令是对程序执行步骤的描述；</p><p>微指令是对指令执行步骤的描述；</p><p>指令是对微指令功能的封装；</p><p>微命令与微操作一一对应；</p><p>微指令中可能包含多个微命令；</p></blockquote><h4 id="微指令的设计">微指令的设计</h4><blockquote><p>探讨：①微指令的具体格式应该怎么设计？②如何根据微指令发出相应的微命令？</p></blockquote><ul><li><p><strong>水平型微指令</strong>*</p><p>一条微指令能定义多个可并行的微命令；</p><blockquote><p>优点：微程序短，执行速度快；</p><p>缺点：微指令长，编写微程序麻烦；</p></blockquote></li><li><p><strong>垂直型微指令</strong></p><p>一条微指令只能定义一个微命令，由微操作码字段规定具体功能；</p></li><li><p><strong>混合型微指令</strong></p></li></ul><h4 id="微指令的编码方式">微指令的编码方式</h4><h5 id="直接编码">直接编码</h5><p>控制字段中每一位代表一个微操作命令；</p><p><img src="https://img.lishangcc.top//img/image-20220725102750205.png" alt="image-20220725102750205"></p><blockquote><p>优点：简单、直观，执行速度快，操作并行性好；</p><p>缺点：微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控存容量极大；</p></blockquote><h5 id="字段直接编码">字段直接编码</h5><p>将微指令的控制字段分成若干段，把互斥性微命令组合在同一个字段中，把相容性微命令组合在不同字段中，每个字段独立编码，每种编码代表一个微命令，且各字段编码含义单独定义，与其他字段无关；</p><blockquote><p>微指令字段分段原则：</p><ol><li>互斥性微命令分在同一段内，相容性微命令分在不同段内；</li><li>每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性；</li><li>一般每个小段还要留出一个状态，表示本字段不发出任何微命令；<br>如：某字段长度为3位，最多只能表示7个互斥的微命令，通常留000表示不操作；</li></ol></blockquote><p><img src="https://img.lishangcc.top//img/image-20220725103700386.png" alt="image-20220725103700386"></p><blockquote><p>优点：可以缩短微指令字长；</p><p>缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢；</p></blockquote><blockquote><p>例题：某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用<code>字段直接编码法</code>，共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有多少位?</p><p>答：3+2+4+3+3=15位</p><p>（若采用直接编码发誓，则需要控制字段33位）</p></blockquote><h5 id="字段间编码">字段间编码</h5><p>一个字段的某些微命令需要另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，因此称为字段间编码，又称隐式编码；</p><h4 id="微程序控制单元的设计">微程序控制单元的设计</h4><p>设计步骤：</p><ol><li>分析每个阶段的微操作序列</li><li>写出对应机器指令的微操作命令及节拍</li><li>确定微指令格式</li><li>编写微指令码点</li></ol><h2 id="指令流水线">指令流水线</h2><blockquote><p>为什么引入流水线结构？</p><p>有哪些结构？</p><p>会产生什么问题？</p></blockquote><p>一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成，如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线；</p><h3 id="流水线的表示方法">流水线的表示方法</h3><p><strong>指令执行过程图</strong></p><p><img src="https://img.lishangcc.top//img/image-20220725114055994.png" alt="image-20220725114055994"></p><p><strong>时空图</strong>*</p><p><img src="https://img.lishangcc.top//img/image-20220725114203623.png" alt="image-20220725114203623"></p><blockquote><p>横坐标：时间，分割成长度相等的时间段T；</p><p>纵坐标：空间，表示当前指令所处的功能部件；</p></blockquote><h3 id="流水线的性能指标">流水线的性能指标</h3><p><code>吞吐率TP</code>：在单位时间内流水线所完成的任务数量，或是输出结构的数量；</p><blockquote><p>设任务数为n，处理完n个任务所用时间为Tk；</p><p>TP=n / TK；</p></blockquote><p><code>加速比S</code>：完成同一批任务，不使用流水线所用时间与使用流水线所用时间之比；</p><blockquote><p>设T0表示不使用流水线时的执行时间，即顺序执行所用时间，Tk表示使用流水线时的执行时间；</p><p>S=T0 / Tk；</p></blockquote><p><code>效率E</code>：流水线的设备利用率；</p><blockquote><p>时空图上，效率为：完成n个任务占用的时空区有效面积与n个任务所用时间与k个流水段所围成的时空区总面积之比；</p><p>E = n个任务占用的时空区有效面积 / n个任务所用时间与k个流水段所围成的时空区总面积 = T0 / (k*Tk)；</p><p><img src="https://img.lishangcc.top//img/image-20220725115310781.png" alt="image-20220725115310781"></p></blockquote><h3 id="流水线影响因素">流水线影响因素</h3><p><strong>结构相关（资源冲突）</strong></p><p>由于多条指令在同一时刻争用同一资源而形成的冲突；</p><blockquote><p>解决办法：</p><ol><li>后一相关指令暂停一周期；</li><li>资源重复配置：数据存储器+指令存储器；</li></ol></blockquote><p><strong>数据相关（数据冲突）</strong>*</p><p>在一个程序中，存在必须等前一条指令执行完成才能执行后一条指令的情况，这两条指令即为数据相关；</p><blockquote><p>解决办法：</p><ol><li>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行；可分为<code>硬件阻塞</code>和<code>软件插入“NOP”</code>两种方法；</li><li>数据旁路技术（转发机制）；</li><li>编译优化：通过编译器调整指令顺序来解决数据相关；</li></ol></blockquote><p><strong>控制相关（控制冲突）</strong></p><p>当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关；</p><p>（理解：当程序执行一条判断语句时，条件满足PC值发生改变，而在判断条件执行过程中，程序会继续顺序取指令，而结果又没有用到）</p><blockquote><p>解决办法：</p><ol><li>转移指令分支预测：简单预测（永远才true或false）、动态预测（根据历史情况动态调整）；</li><li>预取转移成功和不成功两个控制流方向上的目标指令；</li><li>加快和提前形成条件码；</li><li>提高转移方向的猜准率；（第一种的优化）</li></ol></blockquote><h3 id="五段式指令流水线">五段式指令流水线</h3><p>一条指令执行过程分为如下5个阶段：</p><ol><li>IF：取指</li><li>ID：译码&amp;取数</li><li>EX：执行</li><li>MEM：访存</li><li>WB：写回寄存器</li></ol><p><img src="https://img.lishangcc.top//img/image-20220725154525714.png" alt="image-20220725154525714"></p><p>流水线每一个功能段部件后面都有一个<code>缓冲寄存器</code>，或称为<code>锁存器</code>，作用是保存本流水段的执行结果，供下一流水段使用；</p><blockquote><p>考试中常见的五类指令：</p><p>运算类指令、LOAD指令、STORE指令、条件转移指令、无条件转移指令；</p><p>通常，RISC处理器只有<code>取数LOAD</code>和<code>存数STORE</code>指令才能访问主存；</p></blockquote><p><strong>运算类指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：取出操作数至ID段锁存器；</li><li>EX：运算，将结果存入EX段锁存器；</li><li>M：空段；</li><li>WB：将运算结果写回指定寄存器；</li></ol><table><thead><tr><th style="text-align:center">指令举例</th><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">加法指令（两个寄存器相加）</td><td style="text-align:center">ADD Rs，Rd</td><td style="text-align:center">(Rs)+(Rd)→Rd</td></tr><tr><td style="text-align:center">加法指令（寄存器与立即数相机）</td><td style="text-align:center">ADD #996，Rd</td><td style="text-align:center">996+(Rd)→Rd</td></tr><tr><td style="text-align:center">算术左移指令</td><td style="text-align:center">SHL Rd</td><td style="text-align:center">(Rd)&lt;&lt;&lt;2→Rd</td></tr></tbody></table><p><strong>取数LOAD指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：将基址寄存器的值放到锁存器A，将偏移量的值放到Imm；</li><li>EX：运算，得到有效地址；</li><li>M：从数据Cache中取数并放入锁存器；</li><li>WB：将取出的数写回寄存器；</li></ol><table><thead><tr><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">LOAD Rd，996(Rs)</td><td style="text-align:center">(996+(Rs))→Rd</td></tr><tr><td style="text-align:center">LOAD Rd，mem</td><td style="text-align:center">(mem)→Rd</td></tr></tbody></table><p><strong>存数STORE指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：将基址寄存器的值放到锁存器A，将偏移量的值放到Imm，将要存的数放到B；</li><li>EX：运算，得到有效地址，并将锁存器B的内容放到锁存器Store；</li><li>M：写入数据Cache；</li><li>WB：空段；</li></ol><table><thead><tr><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">STORE Rs，996(Rd)</td><td style="text-align:center">Rs→(996+(Rd))</td></tr><tr><td style="text-align:center">STORE Rs，mem</td><td style="text-align:center">Rs→(mem)</td></tr></tbody></table><p><strong>条件转移指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：进行比较的两个数放入锁存器A、B；偏移量放入Imm；</li><li>EX：运算，比较两个数；</li><li>M：将目标PC值写回PC；</li><li>WB：空段；</li></ol><table><thead><tr><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">beq Rs，Rt，#偏移量</td><td style="text-align:center">若(Rs)==(Rt)，则(PC)+指令字长+(偏移量×指令字长)→PC；否则(PC)+指令字长→PC；</td></tr><tr><td style="text-align:center">bne Rs，Rt，#偏移量</td><td style="text-align:center">若(Rs)!=(Rt)，则(PC)+指令字长+(偏移量×指令字长)→PC；否则(PC)+指令字长→PC；</td></tr></tbody></table><p><strong>无条件转移指令</strong></p><ol><li>IF：根据PC从指令Cache取指令至IF段的锁存器；</li><li>ID：偏移量放入Imm；</li><li>EX：将目标PC值写回PC；</li><li>M：空段；</li><li>WB：空段；</li></ol><table><thead><tr><th style="text-align:center">汇编格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">jmp #偏移量</td><td style="text-align:center">(PC)+指令字长+(偏移量×指令字长)→PC；</td></tr></tbody></table><blockquote><p>例题：假设某指令流水线采用“按序发射，按序完成”方式，没有采用转发技术处理数据相关，并且同一寄存器的读和写操作不能在同一个时钟周期内进行。若高级语言程序中某赋值语句为x=a+b，x、a和b均为int型变量，它们的存储单元地址分别表示为[x]、[a]和[b]。该语句对应的指令序列及其在指令流中的执行过程如下图所示。</p><p><img src="https://img.lishangcc.top//img/image-20220725173148839.png" alt="image-20220725173148839"></p><p><img src="https://img.lishangcc.top//img/image-20220725173202613.png" alt="image-20220725173202613"></p><p><strong>分析这4条指令执行过程中I3的ID段和I4的IF段被阻塞的原因各是什么？</strong></p><p>答：①I3与I1和I2存在数据相关；②I4的IF段必须在I3进入ID段后才能开始，否则会覆盖IF段锁存器的内容；</p><p>记住：只有上一条指令进入ID段后，下一条指令才能开始IF段，否则会覆盖IF段锁存器的内容；</p></blockquote><h2 id="多处理器系统">多处理器系统</h2><p>基于指令流的数量和数据流的数量，将计算机体系结构分为SISD、SIMD、MISD和MIMD四类；常规单处理器属于SISD，常规多处理器属于MIMD；</p><p><strong>单指令流单数据流（SISD）结构</strong></p><p>SISD是传统的串行计算机结构，这种计算机通常仅包含一个处理器，一个存储器；处理器在一段时间内仅执行一条指令，按指令流规定的顺序串行执行指令流中的若干条指令；</p><p><strong>多指令多数据流（MIMD）结构</strong></p><p>同时执行多条指令分别处理多个不同的数据，MIMD分为<code>多计算机系统</code>和<code>多处理器系统</code>；</p><p><code>多计算机系统</code>中，每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，不能通过存取指令来访问不同节点的私有存储器，而要通过消息传递进行数据传送，也称<code>消息传递MIMD</code>；</p><p><code>多处理器系统</code>是共享存储多处理器（SMP）系统的简称，他具有共享的单一地址空间，通过存取指令访问系统中所有存储器，也称<code>共享存储MIMD</code>；</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章指令系统</title>
      <link href="/myblog/2022/07/12/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-12-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/myblog/2022/07/12/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-12-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="指令概念">指令概念</h2><h3 id="指令基本格式">指令基本格式</h3><p>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码，一条指令包括**操作码字段（OP）<strong>和</strong>地址码字段（A）**两部分，一条指令可能包含多个地址码，<strong>根据地址码数目不同</strong>，可以将指令分为零地址指令、一地址指令、二地址指令……</p><blockquote><p>理解一下：</p><p>操作码：用户要干什么；地址码：对谁进行操作；</p></blockquote><p><strong>零地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712165522481.png" alt="image-20220712165522481"></p><ol><li>不需要操作数，如空操作、停机、关中断等指令；</li><li>堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果可压回栈顶；</li></ol><p><strong>一地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712165859828.png" alt="image-20220712165859828"></p><ol><li><p>只需要操作数，如加1、减1、取反、求补等；</p><blockquote><p>指令含义：OP(A1)→A1；</p><p>完成一条指令需要3次访存：取指→读A1→写A1；</p></blockquote></li><li><p>需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC）；</p><blockquote><p>指令含义：(ACC)OP(A1)→ACC；</p><p>完成一条指令需要2次访存：取指→读A1；</p></blockquote><blockquote><p>注：A1指某个主存地址（类比C语言指针）；（A1）表示A1所指向的地址中的内容（指针所指位置的内容）。</p></blockquote></li></ol><p><strong>二地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712203945428.png" alt="image-20220712203945428"></p><p>常用于需要两个操作数的算术运算、逻辑运算相关指令；</p><blockquote><p>指令含义：（A1）OP（A2）→A1；</p><p>完成一条指令需要4次访存：取指→读A1→读A2→写A1；</p></blockquote><p><strong>三地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712204145875.png" alt="image-20220712204145875"></p><p>常用于需要两个操作数的算术运算、逻辑运算相关指令；</p><blockquote><p>指令含义：（A1）OP（A2）→A3</p><p>完成一条指令需要4次访存：取指→读A1→读A2→写A3；</p></blockquote><p><strong>四地址指令</strong></p><p><img src="https://img.lishangcc.top//img/image-20220712204325040.png" alt="image-20220712204325040"></p><p>正常情况下：取指令之后PC+1，指向下一条指令；</p><p>四地址指令：执行指令后，将PC的值修改为A4所指地址（与前面不同的是PC不是简单的+1，而是可以跳着指向其他地址）；</p><blockquote><p>指令含义：（A1）OP（A2）→A3，A4=下一条将要执行指令的地址；</p><p>完成一条指令需要4次访存：取指→读A1→读A2→写A3；</p></blockquote><h3 id="指令分类">指令分类</h3><p><strong>按指令长度分类</strong></p><ul><li>定长指令字结构：指令系统中所有指令的长度都相等；</li><li>变长指令字结构：指令系统中各种指令的长度不等；</li></ul><blockquote><p>一些概念：</p><p>指令字长：一条指令的总长度；</p><p>机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（与ALU相关）；</p><p>存储字长：一个存储单元中的二进制代码位数（与MDR位数同）；</p><p><strong>指令字长会影响取指令所需时间</strong>，如：机器字长=存储字长=16bit，则存取一条双字长指令需要2次访存；</p></blockquote><p><strong>按操作码长度分类</strong></p><ul><li>定长操作码：指令系统中所有指令的操作码长度相同；</li><li>可变长（扩展）操作码：指令系统中各指令的操作码长度可变；</li></ul><p><strong>按操作类型分类</strong></p><ul><li>数据传送类：CPU、主存之间的数据传送；</li><li>运算类：算数逻辑操作、移位操作；</li><li>程序控制类：改变程序执行流；</li><li>输入输出类：CPU、IO设备之间的数据传送；</li></ul><h3 id="扩展操作码指令格式">扩展操作码指令格式</h3><blockquote><p>定长指令字结构+可变长操作码；</p><p>不同地址数的指令使用不同长度的操作码；</p></blockquote><p>在扩展操作码指令格式时，需注意：</p><ol><li>不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分相同；（类比哈夫曼树）</li><li>各指令的操作码一定不能重复；</li><li>通常情况下，使用频率较高的指令，分配较短的操作码；使用频率较低的指令，分配较长的操作码；</li></ol><p>例：设指令字长固定为16位，试设计一套指令系统满足：</p><ol><li>有15条三地址指令</li><li>有12条二地址指令</li><li>有62条一地址指令</li><li>有32条零地址指令</li></ol><p><img src="https://img.lishangcc.top//img/image-20220713203433455.png" alt="image-20220713203433455"></p><p>设地址长度为n，上一层留出m种状态，下一层可扩展出<strong>m×2^n</strong>种状态；</p><p><img src="https://img.lishangcc.top//img/image-20220713203911765.png" alt="image-20220713203911765"></p><h2 id="指令寻址">指令寻址</h2><p>指令地址：下一条欲执行指令的地址（由程序计数器PC给出），分为顺序寻址、跳跃寻址；</p><h2 id="数据寻址">数据寻址*</h2><p>数据寻址：确定<strong>本条指令</strong>的<strong>地址码指明的真实地址</strong>；</p><h3 id="直接寻址">直接寻址</h3><p>指令字中的形式地址A就是操作数的真实地址EA，即EA=A；</p><p><strong>指令执行过程</strong>：</p><ol><li>取指令，访存1次；</li><li>执行指令：访存1次；</li></ol><blockquote><p>优点：简单，指令执行阶段进访问一次主存，不需专门计算操作数的地址；</p><p>缺点：A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改；</p></blockquote><h3 id="间接寻址">间接寻址</h3><p>指令的地址字段给出的形式地址不是操作数的真实地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=（A）；</p><p><img src="https://img.lishangcc.top//img/image-20220713213733162.png" alt="image-20220713213733162"></p><blockquote><p>优点：可扩大寻址范围（有效地址EA的位数大于形式地址A的位数）；便于编址程序；</p><p>缺点：指令的执行阶段要多次访存（一次间址需要两次访存，多次寻址需根据存储字的最高位确定几次访存）；</p></blockquote><h3 id="寄存器寻址">寄存器寻址</h3><p>在指令字中直接给出操作数所在的寄存器编号，即EA=Ri，其操作数在由Ri所指的寄存器内；</p><p><img src="https://img.lishangcc.top//img/image-20220713214909570.png" alt="image-20220713214909570"></p><p><strong>指令执行过程</strong>：</p><ol><li>取指令：访存1次；</li><li>执行指令：访存0次；</li></ol><blockquote><p>优点：指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快，支持向量/矩阵运算；</p><p>缺点：寄存器价格昂贵，计算机中寄存器个数有限；</p></blockquote><h3 id="寄存器间接寻址">寄存器间接寻址</h3><p>寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=（Ri）；</p><p><img src="https://img.lishangcc.top//img/image-20220713215413969.png" alt="image-20220713215413969"></p><p><strong>指令执行过程</strong>：</p><ol><li>取指令：访存1次；</li><li>执行指令：访存1次；</li></ol><blockquote><p>特点：与一般间接寻址相比，速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）；</p></blockquote><h3 id="隐含寻址">隐含寻址</h3><p>不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址；</p><p><img src="https://img.lishangcc.top//img/image-20220713215714829.png" alt="image-20220713215714829"></p><blockquote><p>优点：有利于缩短指令字长；</p><p>缺点：需增加存储操作数或隐含地址的硬件；</p></blockquote><h3 id="立即寻址">立即寻址</h3><p>形式地址A就是操作数本身，又称为立即数，一般采用补码形式；</p><p><strong>指令执行过程</strong>：</p><ol><li>取指令：访存1次；</li><li>执行指令：访存0次；</li></ol><blockquote><p>优点：指令执行阶段不访问只存，指令执行时间最短；</p><p>缺点：A的位数限制了立即数的范围，如果A的位数为n，且立即数采用补码时，可表示数据的范围为：<img src="https://img.lishangcc.top//img/image-20220713220248342.png" alt="image-20220713220248342"></p></blockquote><p><img src="C:/Users/LS/AppData/Roaming/Typora/typora-user-images/image-20220713220329465.png" alt="image-20220713220329465"></p><h3 id="偏移寻址">偏移寻址</h3><ul><li>基址寻址：以程序的起始存放地址作为 “起点”；EA=(BR)+A</li><li>变址寻址：程序员自己决定从哪里作为 “起点”；EA=(IX)+A</li><li>相对寻址：以程序计数器PC所指地址作为 “起点”；EA=(PC)+A</li></ul><blockquote><p>区别在于偏移的起点不一样；</p></blockquote><h4 id="基址寻址">基址寻址</h4><p>将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=（BR）+A；</p><p><img src="https://img.lishangcc.top//img/image-20220718000025191.png" alt="image-20220718000025191"></p><h4 id="变址寻址">变址寻址</h4><p>有效地址EA等于 指令字中的形式地址A与变址寄存器IX的内容相加之和，即 EA=（IX）+A，其中IX可为变址寄存器（专用），也可用通用寄存器作为变址寄存器；</p><p>变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）；</p><blockquote><p>数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序；</p></blockquote><h4 id="相对地址">相对地址</h4><p>把程序计数器PC的内容加上指令格式的形式地址A而形成操作数的有效地址，即EA=（PC）+A，其中A是相对于PC所指地址的位移量，可正可负，补码表示；</p><p><img src="https://img.lishangcc.top//img/image-20220719203907752.png" alt="image-20220719203907752"></p><h3 id="堆栈寻址">堆栈寻址</h3><p>操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址；</p><p>堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）；</p><h3 id="总结">总结</h3><p><img src="https://img.lishangcc.top//img/image-20220719220113005.png" alt="image-20220719220113005"></p><h2 id="高级语言与机器级代码">高级语言与机器级代码</h2><blockquote><p>考法：</p><ol><li>给出某段简单程序的C语言、汇编语言、机器语言的表示，能结合C语言看懂汇编语言关键语句（常见指令、选择结构、循环结构、函数调用）；</li><li>汇编语言、机器语言一一对应，要能结合汇编语言分析机器语言指令的格式、寻址方式；</li></ol></blockquote><h3 id="X86汇编语言指令">X86汇编语言指令</h3><p>指令的作用：1.改变程序执行流；2.处理数据；</p><p>指令的格式：操作码 + 地址码；</p><p><img src="https://img.lishangcc.top//img/image-20220720000851416.png" alt="image-20220720000851416"></p><p><strong>mov指令</strong></p><p>mov 目的操作数d，源操作数s</p><p>mov指令功能：将源操作数s复制到目的操作数d所指的位置；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax, ebx#将寄存器ebx的值复制到寄存器eax</span><br><span class="line">mov eax, 5#将立即数5复制到寄存器eax</span><br><span class="line">mov eax，dword ptr[af996h]#将内存地址af996h所指的32bit值复制到寄存器eax</span><br><span class="line">mov byte ptr[af996h]，5#将立即数5复制到内存地址af996h所指的一字节中</span><br></pre></td></tr></table></figure><blockquote><p><strong>1.如何指明内存的读写长度：</strong></p><p>dword ptr——双字，32bit<br>word ptr——单字，16bit<br>byte ptr——字节，8bit</p><p><strong>2.X86架构CPU有哪些寄存器：</strong></p><p><img src="https://img.lishangcc.top//img/image-20220719221038865.png" alt="image-20220719221038865"></p></blockquote><h3 id="循环语句的机器表示">循环语句的机器表示</h3><h2 id="CISC和RISC">CISC和RISC</h2><p><strong>CISC：Complex Instruction Set Computer</strong></p><p>一条指令完成一个复杂的基本功能；</p><p>代表：X86架构，主要用于笔记本、台式机等；</p><p>理解：程序+各种库和函数；</p><p><strong>RISC：Reduced Instruction Set Computer</strong></p><p>一条指令完成一个基本动作，多条指令组合完成一个复杂的基本功能；</p><p>代表：ARM架构，主要用于手机、平板；</p><p>理解：原生程序；</p><p><img src="https://img.lishangcc.top//img/image-20220722001624790.png" alt="image-20220722001624790"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章存储系统</title>
      <link href="/myblog/2022/07/04/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-04-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/myblog/2022/07/04/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-04-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><h3 id="存储器的层次化结构">存储器的层次化结构</h3><p><img src="https://img.lishangcc.top//img/image-20220704200541476.png" alt="image-20220704200541476"></p><p><img src="https://img.lishangcc.top//img/image-20220704200853790.png" alt="image-20220704200853790"></p><ul><li>辅存中的数据要调入主存后才能被CPU访问；</li><li><strong>主存—辅存</strong>：实现虚拟存储系统，解决主存容量不够的问题；</li><li><strong>Cache—主存</strong>：解决主存与CPU速度不匹配的问题；</li></ul><h3 id="存储器的分类">存储器的分类</h3><p><strong>按层次</strong></p><ul><li><strong>高速缓存</strong>（Cache）：可直接被CPU读写；</li><li><strong>主存储器</strong>（主存）：可直接被CPU读写；</li><li><strong>辅助存储器</strong>（辅存、外存）</li></ul><p><strong>按存储介质</strong></p><ul><li><strong>半导体存储器</strong>：主存、Cache；</li><li><strong>磁表面存储器</strong>：磁盘、磁带；</li><li><strong>光存储器</strong>：光盘；</li></ul><p><strong>按存取方式</strong></p><ul><li><strong>随机存储存储器（RAM）</strong>：读写任何一个存储单元所需时间都相同，与存储单元所在的物理位置无关；（如：内存条）</li><li><strong>顺序存储存储器（SAM）</strong>：读写一个存储单元所需时间取决于存储单元所在的物理位置；（如：磁带）</li><li><strong>直接存储存储器（DAM）</strong>：既有随机存取特性，也有顺序存取特性；先直接选取信息所在区域，然后按顺序方式存取；（如：机械硬盘）</li></ul><p><strong>按信息的可更改性</strong></p><ul><li><strong>读写存储器</strong>：即可读，也可写；（如：磁盘、内存、Cache）</li><li><strong>只读存储器（ROM）</strong>：只能读，不能写；（如：实体音乐专辑、电影光碟）（事实上现在很多ROM也可以多次读写，只是比较麻烦）</li></ul><p><strong>按信息的可保存性</strong></p><ul><li><strong>易失性存储器</strong>：断电后，存储信息消失的存储器；（主存、Cache）</li><li><strong>非易失性存储器</strong>：断电后，信息依然保持的存储器；（磁盘、光盘）</li><li><strong>破坏性读出</strong>：信息读出后，原存储信息被破坏；（如DRAM芯片）</li><li><strong>非破坏性读出</strong>：与上相反；（如SRAM芯片、磁盘、光盘）</li></ul><h3 id="存储器的性能指标">存储器的性能指标</h3><ol><li>存储容量：存储字数×字长（如1M×8位）（主存储器中的MDR反映存储字长）</li><li>单位成本：每位价格=总成本/中容量；</li><li>存储速度：数据传输率=数据的宽度/存储周期；（数据的宽度即存储字长）</li></ol><blockquote><p><strong>存取时间</strong>（Ta）：存储时间是指从启动一次存储器操作到完成该操作所经历的时间；分为读出时间和写入时间；</p><p><strong>存取周期</strong>（Tm）：又称<strong>读写周期</strong>或<strong>访问周期</strong>，他是指存储器进行一次完整的读写操作所需的全部时间，即<strong>连续两次独立地访问存储操作之间所需的最小时间间隔</strong>；</p><p><strong>主存带宽</strong>（Bm）：又称<strong>数据传输率</strong>，表示每秒从主存进出信息的最大数量，单位：字/秒、字节/秒（B/s）、位/秒（b/s）；</p></blockquote><p><img src="https://img.lishangcc.top//img/image-20220704215754963.png" alt="image-20220704215754963"></p><h2 id="主存储器的基本组成">主存储器的基本组成</h2><blockquote><ul><li>存储体：也称存储矩阵，由多个存储单元组成，存储单元由存储元组成；</li><li>MAR：n位地址对应2^n个存储单元；</li><li>MDR</li></ul></blockquote><p><img src="https://img.lishangcc.top//img/image-20220705202715405.png" alt="image-20220705202715405"></p><p>总容量=存储单元个数×存储字长</p><p>片选线：一个内存条内可能含有多块存储芯片，由片选片选择哪块芯片；</p><p>金属引脚：地址线+数据线+片选线+读/写控制线；</p><h3 id="SRAM和DRAM">SRAM和DRAM</h3><blockquote><ul><li>DRAM（动态RAM）：用于主存；</li><li>SRAM（静态RAM）：用于Cache；</li></ul></blockquote><table><thead><tr><th style="text-align:center">类型特点</th><th style="text-align:center">SRAM</th><th style="text-align:center">DRAM</th></tr></thead><tbody><tr><td style="text-align:center">存储信息</td><td style="text-align:center">触发器</td><td style="text-align:center">电容</td></tr><tr><td style="text-align:center">破坏性读出</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">读出后是否需要重写</td><td style="text-align:center">不用</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">运行速度</td><td style="text-align:center">快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">集成度</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">发热量</td><td style="text-align:center">大</td><td style="text-align:center">小</td></tr><tr><td style="text-align:center">存储成本</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">易失/非易失性存储器</td><td style="text-align:center">易失</td><td style="text-align:center">易失</td></tr><tr><td style="text-align:center">是否需要刷新</td><td style="text-align:center">不需要（只要不断电，触发器状态就不会改变）</td><td style="text-align:center">需要（电容内的电荷一般只能维持2ms，因此需要刷新）</td></tr><tr><td style="text-align:center">送行列地址</td><td style="text-align:center">同时送</td><td style="text-align:center">分两次送</td></tr></tbody></table><h4 id="DRAM的刷新">DRAM的刷新</h4><p><strong>刷新周期</strong>：一般为2ms；</p><p><strong>每次刷新多少存储单元</strong>：以行为单位，每次刷新一行存储单元；</p><p><strong>存储器的简单模型</strong>（仅用行地址）：会产生有<strong>2^n</strong>根选通线；</p><p><strong>存储器的优化模型</strong>（用行列地址）：一半行地址，一半列地址；会产生**2×2^(n/2)**根选通线；</p><p><strong>如何刷新</strong>：有硬件支持，读出一行的信息后重新写入，占用一个存取周期；</p><p><strong>什么时候刷新</strong>：</p><blockquote><p>假设DRAM内部结构排列成128×128的形式，存取周期0.5us（微秒），2ms内共 2ms/0.5us=4000个周期；</p></blockquote><p>有以下三种思路，其中第三种好；</p><p><img src="https://img.lishangcc.top//img/image-20220705205604290.png" alt="image-20220705205604290"></p><h3 id="只读存储器ROM">只读存储器ROM</h3><blockquote><p>非易失性，断电后数据不会丢失，通常有以下5种，MROM、PROM、EPROM、闪存、SSD；</p></blockquote><p><strong>MROM——掩膜式只读存储器</strong>：由厂家直接写入，后期不可修改；</p><p>PROM——可编程只读存储器：用户可用专门的写入器写入信息，但也只可以写一次；</p><p><strong>EPROM——可擦除可编程只读存储器</strong>：允许用户写入信息，之后可用某种方法擦除数据，可进行多次重写；</p><p><strong>Flash Memory——闪存</strong>：如：U盘、SD卡，断电后也可保存信息，可多次擦除和重写；<br>注意：闪存的写速度要比读速度慢；</p><p><strong>SSD——固态硬盘</strong>：</p><p>由 <strong>控制单元</strong> + <strong>存储单元</strong> （Flash芯片）构成，与闪存的核心区别在于控制单元不一样，但存储介质都类似；</p><h3 id="主存储器与CPU连接">主存储器与CPU连接</h3><p>现在的计算机主要采用以下模式：</p><p><img src="https://img.lishangcc.top//img/image-20220705211324114.png" alt="image-20220705211324114"></p><h4 id="增加主存的存储字长——位扩展">增加主存的存储字长——位扩展</h4><p>主存的位数未用满CPU提供的接口，即MDR；</p><p><img src="https://img.lishangcc.top//img/image-20220705220444207.png" alt="image-20220705220444207"></p><h4 id="增加主存的存储字数——字扩展">增加主存的存储字数——字扩展</h4><p>主存的地址数未用满CPU提供的接口，即MAR；</p><p><img src="https://img.lishangcc.top//img/image-20220705215116296.png" alt="image-20220705215116296"></p><p><strong>线选法</strong>：如上图所示，A14和A13只能为01或10，不能为00或11，因此n条线只有n个选片信号；</p><p><img src="https://img.lishangcc.top//img/image-20220705215001799.png" alt="image-20220705215001799"></p><p><strong>译码片选法</strong>：n条线，2^n个选片信号；（如：1—2译码器（直接用一个非门即可）、2—4译码器、3—8译码器）</p><h4 id="主存容量扩展——字位同时扩展">主存容量扩展——字位同时扩展</h4><p><img src="https://img.lishangcc.top//img/image-20220705215604248.png" alt="image-20220705215604248"></p><p>如上图所示：16K×4位→64K×8位；</p><h2 id="双端口RAM和多模块存储器">双端口RAM和多模块存储器</h2><h3 id="双端口RAM">双端口RAM</h3><p><img src="https://img.lishangcc.top//img/image-20220706210343131.png" alt="image-20220706210343131"></p><blockquote><p>作用：优化多核CPU访问同一根内存条的速度；</p></blockquote><p>两个端口对同一主存的操作有4种情况，其中只有前2种可行（类似于操作系统中 “读者-写者问题” ）：</p><ul><li>两个端口同时对不同的地址单元存取数据；</li><li>两个端口同时对同一地址单元读出数据；</li><li>两个端口同时对同一地址单元写入数据；（写入错误）</li><li>两个端口同时对同一地址单元，一个写入，，一个读出；（读出错误）</li></ul><h3 id="多体并行存储器">多体并行存储器</h3><p>特点：每个模块都有相同的容量和存取速度；各模块都有独立的读写控制电路、地址寄存器和数据寄存器，他们既能并行工作，又能交叉工作；</p><p><strong>高位交叉编址的多体存储器</strong>：地址编号竖着编；</p><p><img src="https://img.lishangcc.top//img/image-20220706212435663.png" alt="image-20220706212435663"></p><p><strong>低位交叉编址的多体存储器</strong>：地址编号横着编；</p><p><img src="https://img.lishangcc.top//img/image-20220706212518149.png" alt="image-20220706212518149"></p><blockquote><p>例：假设每个存储体存取周期为T，存取时间为r，T=4r，若连续访问00000,00001,00010,00011,00100；</p><p><strong>高位交叉编址</strong>耗时如图所示：</p><p><img src="https://img.lishangcc.top//img/image-20220706212913484.png" alt="image-20220706212913484"></p><p>因为在同一存储体内，所以需要等一次存取之后需要等其恢复了才能进行下一次存取；<br>所以其耗时为5T；（若连续取n个存储字，耗时nT）</p><p><strong>低位交叉编址</strong>耗时如图所示：</p><p><img src="https://img.lishangcc.top//img/image-20220706213741018.png" alt="image-20220706213741018"></p><p>因为连续的存储字存储在不同的存储体中，所以在第一个存储体中取完数据后，其恢复期间便可向下一个存储体中的存储单元取数据；<br>耗时T+4r=2T；（连续取n个存储字，耗时T+（n-1）r）</p></blockquote><p>这种低位交叉编址应该取几个&quot;体&quot;呢？（两种说法，但结果一样）</p><blockquote><ol><li>存取周期为T，<strong>存取时间</strong>为r，为了使其工作不间断，应保证模块数 <strong>m&gt;=T/r</strong>；</li><li>存取周期为T，<strong>总线传输周期</strong>为r，为了使其工作不间断，应保证模块数 <strong>m&gt;=T/r</strong>；</li></ol></blockquote><h3 id="单体多字存储器">单体多字存储器</h3><p>相当于把上述多个体合成一整个，每次只能同时取m个字（一取取一整行），不能单独取其中某个字，这种方式灵活性比较差。</p><h2 id="磁盘存储器">磁盘存储器</h2><h3 id="磁盘设备组成">磁盘设备组成</h3><ol><li><p>存储区域</p><p>一块硬盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分若干个扇区（也称块），扇区是磁盘读写的最小单位，</p><p><img src="https://img.lishangcc.top//img/image-20220706222339850.png" alt="image-20220706222339850"></p></li><li><p>硬盘存储器</p><p>硬盘存储器有磁盘驱动器、磁盘控制器和盘片组成；</p><p>磁盘驱动器：核心部件是磁头组件和盘片组件；</p><p>磁盘控制器：是硬盘存储器和主机的接口；</p></li></ol><h3 id="磁盘的性能指标">磁盘的性能指标*</h3><ol><li><p><strong>磁盘的容量</strong>：一个磁盘所能存储的字节总数；</p></li><li><p><strong>记录密度</strong>：记录密度是指盘片单位面积上记录的二进制的信息量，通常以<strong>道密度</strong>、<strong>位密度</strong>和<strong>面密度</strong>表示；</p><blockquote><p>道密度：沿磁盘半径方向上单位长度的磁道数；</p><p>位密度：磁道单位长度上能记录的二进制代码位数；</p><p>面密度：位密度和道密度的乘积；</p><p>注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息量越多，故每个磁道的位密度都不同，越靠内侧的磁道位密度越大；</p></blockquote></li><li><p><strong>平均存取时间（常考）</strong>：</p><p>平均存取时间=寻道时间（磁头移动到目的磁道）+旋转延迟时间（磁头定位到所在扇区）+传输时间（传输数据所花费的时间）；</p><p><img src="https://img.lishangcc.top//img/image-20220707205658498.png" alt="image-20220707205658498"></p><blockquote><p>有的可能还要求加上磁盘控制器延迟时间；</p></blockquote></li><li><p><strong>数据传输率</strong>：磁盘存储器在单位时间内向主机传送数据的字节数；</p><blockquote><p>假设磁盘转数为r（转/秒），每条磁道容量为N个字节，则数据传输率为D=rN；</p></blockquote></li></ol><h3 id="磁盘地址">磁盘地址*</h3><p><img src="https://img.lishangcc.top//img/image-20220707210320188.png" alt="image-20220707210320188"></p><blockquote><p>若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码；</p><p>2bit驱动器号，8bit磁道号，4bit盘面号，4bit扇区号；</p></blockquote><h3 id="硬盘的工作工程">硬盘的工作工程</h3><p>主要操作有<strong>寻址</strong>、<strong>读盘</strong>、<strong>写盘</strong>，每个操作对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字；</p><p>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据；</p><h3 id="磁盘阵列（RAID）">磁盘阵列（RAID）*</h3><p>将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性；</p><p>RAID有以下分级，编号越大越可靠；</p><ul><li><p>RAID0：无冗余和无校验的磁盘阵列；</p><blockquote><p>RAID0把连续多个数据块交替存放在不同物理磁盘扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但<strong>RAID0没有容错能力</strong>；</p></blockquote></li><li><p>RAID1：镜像磁盘阵列；</p><blockquote><p>RAID1是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可从另一磁盘中读取数据；而两个磁盘当一个磁盘使用，意味着<strong>容量减少一半</strong>；</p></blockquote></li><li><p>RAID2：采用纠错的海明码的磁盘阵列；</p></li><li><p>RAID3：位交叉奇偶校验的磁盘阵列；</p></li><li><p>RAID4：块交叉奇偶校验的磁盘阵列；</p></li><li><p>RAID5：无独立校验的奇偶校验磁盘阵列；</p></li></ul><h2 id="固态硬盘SSD">固态硬盘SSD</h2><p><strong>固态硬盘的结构</strong></p><p><img src="https://img.lishangcc.top//img/image-20220707220032183.png" alt="image-20220707220032183"></p><p>块大小：16KB—512KB，页大小：512B—4KB；</p><p><img src="https://img.lishangcc.top//img/image-20220707215832601.png" alt="image-20220707215832601"></p><h2 id="Cache基本概念">Cache基本概念</h2><h3 id="局部性原理">局部性原理</h3><p><strong>空间局部性</strong>：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的；（如：数组元素、顺序执行的指令代码）</p><p><strong>时间局部性</strong>：在最近的未来要用到的信息，很可能是现在正在使用的信息；（循环结构的指令代码）</p><p>基础局部性原理，可以吧CPU目前访问的地址周围的部分数据放到Cache中。</p><blockquote><p>如何界定局部性原理中的“周围”呢？</p><p>将主存的存储空间分块，如：每1KB为一块；主存与Cache之间以“块”为单位进行数据交换；</p><p><img src="https://img.lishangcc.top//img/image-20220708213012930.png" alt="image-20220708213012930"></p></blockquote><h3 id="性能分析">性能分析</h3><p><img src="https://img.lishangcc.top//img/image-20220708205052300.png" alt="image-20220708205052300"></p><p>设tc为访问一次Cache所需时间，tm为访问一次主存所需时间；</p><p><strong>命中率H</strong>：CPU欲访问的信息已在Cache中的比率；</p><p><strong>缺失率</strong>：M=1-H；</p><p><strong>系统的平均访问时间</strong>：</p><p>1.先访问Cache，若Cache未命中再访问主存<img src="https://img.lishangcc.top//img/image-20220708205511524.png" alt="image-20220708205511524"></p><p>2.同时访问Cache和主存，若Cache命中则立即停止访问主存<img src="https://img.lishangcc.top//img/image-20220708205825593.png" alt="image-20220708205825593"></p><blockquote><p>例：假设Cache的速度是主存的5倍，且Cache的命中率为95%，则采用Cache后，存储器性能提高多少？</p><p>解：设Cache的存取周期为t，则主存的存取周期为5t；<br><strong>若Cache和主存同时访问</strong>，命中时访问时间为t，未命中时访问时间为5t；<br>平均访问时间：0.95×t+0.05×5t=1.2t；<br>性能提升：5t/1.2t=4.17倍；</p><p><strong>若先访问Cache再访问主存</strong>，命中时访问时间为t，未命中时访问时间为t+5t；<br>平均访问时间：0.95×t+0.05×6t=1.25t；<br>性能提升：5t/1.25t=4倍；</p></blockquote><h3 id="Cache与主存的映射方式">Cache与主存的映射方式</h3><blockquote><p>解决：如何区分Cache与主存的数据块的对应关系。</p></blockquote><blockquote><p>假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B；</p></blockquote><h4 id="全相联映射">全相联映射</h4><p>主存块可以放在Cache的任意位置；</p><p><img src="https://img.lishangcc.top//img/image-20220712114033399.png" alt="image-20220712114033399"></p><p><img src="https://img.lishangcc.top//img/image-20220712113050720.png" alt="image-20220712113050720"></p><p>主存地址共28位，其中主存块号22位，块内地址6位；</p><p>若CPU访问主存地址1…1101 001110：</p><ul><li>主存地址的前22位，对比Cache中所有块的标记；</li><li>若标记匹配且有效位为1，则Cache命中，访问块内地址为001110单元；</li><li>若未命中或有效位为0，则正常访问主存；</li></ul><blockquote><p>优点：Cache存储空间利用充分，命中率高；</p><p>缺点：查找标记最慢，有可能需要对比所有行的标记；</p></blockquote><h4 id="直接映射">直接映射</h4><p>每个主存块只能放到一个特定的位置；</p><p><strong>Cache块号=主存块号%Cache总块数</strong>；</p><p><img src="https://img.lishangcc.top//img/image-20220712115149596.png" alt="image-20220712115149596"></p><p>与上题一样，22位主存块号（其中19位标记，3位行号），6位块内地址；</p><p>（题目中Cache总块数为8，所以主存块号%2^3相当于留下主存块号后三位二进制数）</p><p>若CPU访问主存地址0…01000 001110：</p><ul><li>根据主存块号的后3位确定Cache行；</li><li>若主存块号的前19位与Cache标记匹配且有效位为1，则Cache命中，访问块内地址为001110的单元；</li><li>若为命中或有效位为0，则正常访问主存；</li></ul><blockquote><p>优点：对于任意一个地址，只需对比一个标记，速度最快；</p><p>缺点：Cache存储空间利用不充分，命中率低；</p></blockquote><h4 id="组相联映射">组相联映射</h4><p>Cache块分为若干组，每个主存块可放到特定分组中的任意一个位置；</p><p><strong>所属分组=主存块号%分组数</strong>；</p><p><img src="https://img.lishangcc.top//img/image-20220712142106447.png" alt="image-20220712142106447"></p><p>22位主存块号（20位标记，2位组号），6位块内地址；</p><p>CPU访问主存地址1…1101 001110：</p><ul><li>根据主存块号的后2位，确定所属分组号；</li><li>若主存块号的前20位与分组内的某个标记匹配，且有效位为1，则Cache命中，访问块内地址001110的单元；</li><li>若未命中或有效位为0，则正常访问主存；</li></ul><blockquote><p>优点：另外两种方式的折中，<strong>综合效果较好</strong>；</p><p>术语：n路组相联映射——每n个Cache行为一组；</p></blockquote><h3 id="Cache替换算法">Cache替换算法</h3><blockquote><p>解决：如果Cache满了怎么办？</p></blockquote><ul><li><strong>全相联映射</strong>：Cache完全满了才需要替换，需要在全局中选择替换哪一块；</li><li><strong>直接映射（无需考虑替换算法）</strong>：如果对应位置非空，则毫无选择地直接替换；</li><li><strong>组相联映射</strong>：分组内满了才需要替换，需要在分组内选择替换哪一块；</li></ul><h4 id="随机算法（RAND）">随机算法（RAND）</h4><p>若Cache已满，则随机选择一块替换；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p><img src="https://img.lishangcc.top//img/image-20220712142841936.png" alt="image-20220712142841936"></p><p>特点：实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定；</p></blockquote><h4 id="先进先出算法（FIFO）">先进先出算法（FIFO）</h4><p>若Cache已满，则替换最先被调入Cache的块；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p><img src="https://img.lishangcc.top//img/image-20220712143022549.png" alt="image-20220712143022549"></p><p>特点：也是实现简单，但依然没考虑局部性原理，最先被调入Cache的块也有可能是被频繁访问的，而且可能出现抖动现象；</p></blockquote><blockquote><p><strong>抖动现象</strong>：频繁的换入换出现象（刚被替换的块很快又被调入）；</p></blockquote><h4 id="近期最少使用（LRU）">近期最少使用（LRU）*</h4><p>为每一个Cache块设置一个计数器，用于记录每个Cache块已经有多久没被访问了，当Cache满后，<strong>替换计数器最大的</strong>；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p>步骤：</p><ol><li>命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变；</li><li>未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1；</li><li>未命中且无空闲行时，计数值最大的信息块被淘汰，新装行的块的计数器置0，其余全加1；</li></ol><p><img src="https://img.lishangcc.top//img/image-20220712143554578.png" alt="image-20220712143554578"></p><p>（Cache块的总数为2^n，则计数器只需n位）</p><p>特点：基于局部性原理，LRU算法的实际运行效果优秀，Cache命中率高；若被频繁访问的主存块数量 &gt; Cache行的数量，则可能发生抖动现象；</p></blockquote><h4 id="最不经常使用（LFU）">最不经常使用（LFU）</h4><p>为每一个Cache块设置一个计数器，用于记录每个Cache块被访问过几次，当Cache满后，<strong>替换计数器最小的</strong>；</p><blockquote><p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p><p>步骤：<br>新调入的块计数器=0，之后每访问一次计数器+1，需要替换时，选择计数器最小的一行；</p><p><img src="https://img.lishangcc.top//img/image-20220712144015714.png" alt="image-20220712144015714"></p><p>特点：曾经被经常访问的主存块在未来不一定会用到，并没有很好的遵循局部性原理，因此实际效果不如LRU；</p></blockquote><h3 id="Cache写策略">Cache写策略</h3><blockquote><p>解决：CPU如果修改了Cache中的数据副本，如何确保主存中数据母本的一致性？</p></blockquote><h4 id="写命中">写命中</h4><p><strong>写回法</strong>：当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存；</p><blockquote><p>减少了访存次数，但存在数据不一致的隐患；</p></blockquote><p><strong>全写法</strong>：当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲；</p><blockquote><p>访存次数增加，速度变慢，但更能保证数据一致性；</p><p>使用写缓存，CPU写的速度很快，若写操作不频繁，则效果很好；若写操作频繁，则可能因为写缓存饱和而发生阻塞；</p></blockquote><h4 id="写不命中">写不命中</h4><p><strong>写分配法</strong>：当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改，通常<strong>搭配写回法使用</strong>；</p><p><strong>非写分配法</strong>：当CPU对Cache写不命中时，只写入内存，不调入Cache，通常<strong>搭配写全法使用</strong>；</p><blockquote><p>多级Cache</p><p>现代计算机通常采用多级Cache结构，各级Cache之间通常采用“全写法+非写分配法”，Cache和主存之间通常采用“写回法+写分配法”；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法</title>
      <link href="/myblog/2022/03/15/2022-03-15-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/myblog/2022/03/15/2022-03-15-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Java</button></li><li class="tab"><button type="button" data-href="#test-3">C</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/myblog/2022/03/02/hello-world/"/>
      <url>/myblog/2022/03/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
