<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第三章存储系统 | Licc's Blog</title><meta name="keywords" content="计算机组成原理"><meta name="author" content="Licc"><meta name="copyright" content="Licc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基本概念 存储器的层次化结构    辅存中的数据要调入主存后才能被CPU访问； 主存—辅存：实现虚拟存储系统，解决主存容量不够的问题； Cache—主存：解决主存与CPU速度不匹配的问题；  存储器的分类 按层次  高速缓存（Cache）：可直接被CPU读写； 主存储器（主存）：可直接被CPU读写； 辅助存储器（辅存、外存）  按存储介质  半导体存储器：主存、Cache； 磁表面存储器：磁盘、磁">
<meta property="og:type" content="article">
<meta property="og:title" content="第三章存储系统">
<meta property="og:url" content="https://lishangcc.github.io/myblog/2022/07/04/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-04-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Licc&#39;s Blog">
<meta property="og:description" content="基本概念 存储器的层次化结构    辅存中的数据要调入主存后才能被CPU访问； 主存—辅存：实现虚拟存储系统，解决主存容量不够的问题； Cache—主存：解决主存与CPU速度不匹配的问题；  存储器的分类 按层次  高速缓存（Cache）：可直接被CPU读写； 主存储器（主存）：可直接被CPU读写； 辅助存储器（辅存、外存）  按存储介质  半导体存储器：主存、Cache； 磁表面存储器：磁盘、磁">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lishangcc.github.io/myblog/img/background/hexoimg1.png">
<meta property="article:published_time" content="2022-07-04T12:00:00.000Z">
<meta property="article:modified_time" content="2022-07-14T14:32:41.861Z">
<meta property="article:author" content="Licc">
<meta property="article:tag" content="计算机组成原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lishangcc.github.io/myblog/img/background/hexoimg1.png"><link rel="shortcut icon" href="/myblog/img/favicon2.png"><link rel="canonical" href="https://lishangcc.github.io/myblog/2022/07/04/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-04-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/myblog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/myblog/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第三章存储系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-14 22:32:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/myblog/css/custom.css"><link rel="stylesheet" href="/myblog/css/colorbg.css"><meta name="generator" content="Hexo 5.4.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/myblog/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/myblog/archives/"><div class="headline">文章</div><div class="length-num">6</div></a></div><div class="data-item"><a href="/myblog/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div><div class="data-item"><a href="/myblog/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/myblog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/myblog/img/background/hexoimg1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/myblog/">Licc's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/myblog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第三章存储系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-04T12:00:00.000Z" title="发表于 2022-07-04 20:00:00">2022-07-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-14T14:32:41.861Z" title="更新于 2022-07-14 22:32:41">2022-07-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/myblog/categories/408/">408</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/myblog/categories/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第三章存储系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="基本概念">基本概念</h2>
<h3 id="存储器的层次化结构">存储器的层次化结构</h3>
<p><img src="https://img.lishangcc.top//img/image-20220704200541476.png" alt="image-20220704200541476"></p>
<p><img src="https://img.lishangcc.top//img/image-20220704200853790.png" alt="image-20220704200853790"></p>
<ul>
<li>辅存中的数据要调入主存后才能被CPU访问；</li>
<li><strong>主存—辅存</strong>：实现虚拟存储系统，解决主存容量不够的问题；</li>
<li><strong>Cache—主存</strong>：解决主存与CPU速度不匹配的问题；</li>
</ul>
<h3 id="存储器的分类">存储器的分类</h3>
<p><strong>按层次</strong></p>
<ul>
<li><strong>高速缓存</strong>（Cache）：可直接被CPU读写；</li>
<li><strong>主存储器</strong>（主存）：可直接被CPU读写；</li>
<li><strong>辅助存储器</strong>（辅存、外存）</li>
</ul>
<p><strong>按存储介质</strong></p>
<ul>
<li><strong>半导体存储器</strong>：主存、Cache；</li>
<li><strong>磁表面存储器</strong>：磁盘、磁带；</li>
<li><strong>光存储器</strong>：光盘；</li>
</ul>
<p><strong>按存取方式</strong></p>
<ul>
<li><strong>随机存储存储器（RAM）</strong>：读写任何一个存储单元所需时间都相同，与存储单元所在的物理位置无关；（如：内存条）</li>
<li><strong>顺序存储存储器（SAM）</strong>：读写一个存储单元所需时间取决于存储单元所在的物理位置；（如：磁带）</li>
<li><strong>直接存储存储器（DAM）</strong>：既有随机存取特性，也有顺序存取特性；先直接选取信息所在区域，然后按顺序方式存取；（如：机械硬盘）</li>
</ul>
<p><strong>按信息的可更改性</strong></p>
<ul>
<li><strong>读写存储器</strong>：即可读，也可写；（如：磁盘、内存、Cache）</li>
<li><strong>只读存储器（ROM）</strong>：只能读，不能写；（如：实体音乐专辑、电影光碟）（事实上现在很多ROM也可以多次读写，只是比较麻烦）</li>
</ul>
<p><strong>按信息的可保存性</strong></p>
<ul>
<li><strong>易失性存储器</strong>：断电后，存储信息消失的存储器；（主存、Cache）</li>
<li><strong>非易失性存储器</strong>：断电后，信息依然保持的存储器；（磁盘、光盘）</li>
<li><strong>破坏性读出</strong>：信息读出后，原存储信息被破坏；（如DRAM芯片）</li>
<li><strong>非破坏性读出</strong>：与上相反；（如SRAM芯片、磁盘、光盘）</li>
</ul>
<h3 id="存储器的性能指标">存储器的性能指标</h3>
<ol>
<li>存储容量：存储字数×字长（如1M×8位）（主存储器中的MDR反映存储字长）</li>
<li>单位成本：每位价格=总成本/中容量；</li>
<li>存储速度：数据传输率=数据的宽度/存储周期；（数据的宽度即存储字长）</li>
</ol>
<blockquote>
<p><strong>存取时间</strong>（Ta）：存储时间是指从启动一次存储器操作到完成该操作所经历的时间；分为读出时间和写入时间；</p>
<p><strong>存取周期</strong>（Tm）：又称<strong>读写周期</strong>或<strong>访问周期</strong>，他是指存储器进行一次完整的读写操作所需的全部时间，即<strong>连续两次独立地访问存储操作之间所需的最小时间间隔</strong>；</p>
<p><strong>主存带宽</strong>（Bm）：又称<strong>数据传输率</strong>，表示每秒从主存进出信息的最大数量，单位：字/秒、字节/秒（B/s）、位/秒（b/s）；</p>
</blockquote>
<p><img src="https://img.lishangcc.top//img/image-20220704215754963.png" alt="image-20220704215754963"></p>
<h2 id="主存储器的基本组成">主存储器的基本组成</h2>
<blockquote>
<ul>
<li>存储体：也称存储矩阵，由多个存储单元组成，存储单元由存储元组成；</li>
<li>MAR：n位地址对应2^n个存储单元；</li>
<li>MDR</li>
</ul>
</blockquote>
<p><img src="https://img.lishangcc.top//img/image-20220705202715405.png" alt="image-20220705202715405"></p>
<p>总容量=存储单元个数×存储字长</p>
<p>片选线：一个内存条内可能含有多块存储芯片，由片选片选择哪块芯片；</p>
<p>金属引脚：地址线+数据线+片选线+读/写控制线；</p>
<h3 id="SRAM和DRAM">SRAM和DRAM</h3>
<blockquote>
<ul>
<li>DRAM（动态RAM）：用于主存；</li>
<li>SRAM（静态RAM）：用于Cache；</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">类型特点</th>
<th style="text-align:center">SRAM</th>
<th style="text-align:center">DRAM</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">存储信息</td>
<td style="text-align:center">触发器</td>
<td style="text-align:center">电容</td>
</tr>
<tr>
<td style="text-align:center">破坏性读出</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">读出后是否需要重写</td>
<td style="text-align:center">不用</td>
<td style="text-align:center">需要</td>
</tr>
<tr>
<td style="text-align:center">运行速度</td>
<td style="text-align:center">快</td>
<td style="text-align:center">慢</td>
</tr>
<tr>
<td style="text-align:center">集成度</td>
<td style="text-align:center">低</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:center">发热量</td>
<td style="text-align:center">大</td>
<td style="text-align:center">小</td>
</tr>
<tr>
<td style="text-align:center">存储成本</td>
<td style="text-align:center">高</td>
<td style="text-align:center">低</td>
</tr>
<tr>
<td style="text-align:center">易失/非易失性存储器</td>
<td style="text-align:center">易失</td>
<td style="text-align:center">易失</td>
</tr>
<tr>
<td style="text-align:center">是否需要刷新</td>
<td style="text-align:center">不需要（只要不断电，触发器状态就不会改变）</td>
<td style="text-align:center">需要（电容内的电荷一般只能维持2ms，因此需要刷新）</td>
</tr>
<tr>
<td style="text-align:center">送行列地址</td>
<td style="text-align:center">同时送</td>
<td style="text-align:center">分两次送</td>
</tr>
</tbody>
</table>
<h4 id="DRAM的刷新">DRAM的刷新</h4>
<p><strong>刷新周期</strong>：一般为2ms；</p>
<p><strong>每次刷新多少存储单元</strong>：以行为单位，每次刷新一行存储单元；</p>
<p><strong>存储器的简单模型</strong>（仅用行地址）：会产生有<strong>2^n</strong>根选通线；</p>
<p><strong>存储器的优化模型</strong>（用行列地址）：一半行地址，一半列地址；会产生**2×2^(n/2)**根选通线；</p>
<p><strong>如何刷新</strong>：有硬件支持，读出一行的信息后重新写入，占用一个存取周期；</p>
<p><strong>什么时候刷新</strong>：</p>
<blockquote>
<p>假设DRAM内部结构排列成128×128的形式，存取周期0.5us（微秒），2ms内共 2ms/0.5us=4000个周期；</p>
</blockquote>
<p>有以下三种思路，其中第三种好；</p>
<p><img src="https://img.lishangcc.top//img/image-20220705205604290.png" alt="image-20220705205604290"></p>
<h3 id="只读存储器ROM">只读存储器ROM</h3>
<blockquote>
<p>非易失性，断电后数据不会丢失，通常有以下5种，MROM、PROM、EPROM、闪存、SSD；</p>
</blockquote>
<p><strong>MROM——掩膜式只读存储器</strong>：由厂家直接写入，后期不可修改；</p>
<p>PROM——可编程只读存储器：用户可用专门的写入器写入信息，但也只可以写一次；</p>
<p><strong>EPROM——可擦除可编程只读存储器</strong>：允许用户写入信息，之后可用某种方法擦除数据，可进行多次重写；</p>
<p><strong>Flash Memory——闪存</strong>：如：U盘、SD卡，断电后也可保存信息，可多次擦除和重写；<br>
注意：闪存的写速度要比读速度慢；</p>
<p><strong>SSD——固态硬盘</strong>：</p>
<p>由 <strong>控制单元</strong> + <strong>存储单元</strong> （Flash芯片）构成，与闪存的核心区别在于控制单元不一样，但存储介质都类似；</p>
<h3 id="主存储器与CPU连接">主存储器与CPU连接</h3>
<p>现在的计算机主要采用以下模式：</p>
<p><img src="https://img.lishangcc.top//img/image-20220705211324114.png" alt="image-20220705211324114"></p>
<h4 id="增加主存的存储字长——位扩展">增加主存的存储字长——位扩展</h4>
<p>主存的位数未用满CPU提供的接口，即MDR；</p>
<p><img src="https://img.lishangcc.top//img/image-20220705220444207.png" alt="image-20220705220444207"></p>
<h4 id="增加主存的存储字数——字扩展">增加主存的存储字数——字扩展</h4>
<p>主存的地址数未用满CPU提供的接口，即MAR；</p>
<p><img src="https://img.lishangcc.top//img/image-20220705215116296.png" alt="image-20220705215116296"></p>
<p><strong>线选法</strong>：如上图所示，A14和A13只能为01或10，不能为00或11，因此n条线只有n个选片信号；</p>
<p><img src="https://img.lishangcc.top//img/image-20220705215001799.png" alt="image-20220705215001799"></p>
<p><strong>译码片选法</strong>：n条线，2^n个选片信号；（如：1—2译码器（直接用一个非门即可）、2—4译码器、3—8译码器）</p>
<h4 id="主存容量扩展——字位同时扩展">主存容量扩展——字位同时扩展</h4>
<p><img src="https://img.lishangcc.top//img/image-20220705215604248.png" alt="image-20220705215604248"></p>
<p>如上图所示：16K×4位→64K×8位；</p>
<h2 id="双端口RAM和多模块存储器">双端口RAM和多模块存储器</h2>
<h3 id="双端口RAM">双端口RAM</h3>
<p><img src="https://img.lishangcc.top//img/image-20220706210343131.png" alt="image-20220706210343131"></p>
<blockquote>
<p>作用：优化多核CPU访问同一根内存条的速度；</p>
</blockquote>
<p>两个端口对同一主存的操作有4种情况，其中只有前2种可行（类似于操作系统中 “读者-写者问题” ）：</p>
<ul>
<li>两个端口同时对不同的地址单元存取数据；</li>
<li>两个端口同时对同一地址单元读出数据；</li>
<li>两个端口同时对同一地址单元写入数据；（写入错误）</li>
<li>两个端口同时对同一地址单元，一个写入，，一个读出；（读出错误）</li>
</ul>
<h3 id="多体并行存储器">多体并行存储器</h3>
<p>特点：每个模块都有相同的容量和存取速度；各模块都有独立的读写控制电路、地址寄存器和数据寄存器，他们既能并行工作，又能交叉工作；</p>
<p><strong>高位交叉编址的多体存储器</strong>：地址编号竖着编；</p>
<p><img src="https://img.lishangcc.top//img/image-20220706212435663.png" alt="image-20220706212435663"></p>
<p><strong>低位交叉编址的多体存储器</strong>：地址编号横着编；</p>
<p><img src="https://img.lishangcc.top//img/image-20220706212518149.png" alt="image-20220706212518149"></p>
<blockquote>
<p>例：假设每个存储体存取周期为T，存取时间为r，T=4r，若连续访问00000,00001,00010,00011,00100；</p>
<p><strong>高位交叉编址</strong>耗时如图所示：</p>
<p><img src="https://img.lishangcc.top//img/image-20220706212913484.png" alt="image-20220706212913484"></p>
<p>因为在同一存储体内，所以需要等一次存取之后需要等其恢复了才能进行下一次存取；<br>
所以其耗时为5T；（若连续取n个存储字，耗时nT）</p>
<p><strong>低位交叉编址</strong>耗时如图所示：</p>
<p><img src="https://img.lishangcc.top//img/image-20220706213741018.png" alt="image-20220706213741018"></p>
<p>因为连续的存储字存储在不同的存储体中，所以在第一个存储体中取完数据后，其恢复期间便可向下一个存储体中的存储单元取数据；<br>
耗时T+4r=2T；（连续取n个存储字，耗时T+（n-1）r）</p>
</blockquote>
<p>这种低位交叉编址应该取几个&quot;体&quot;呢？（两种说法，但结果一样）</p>
<blockquote>
<ol>
<li>存取周期为T，<strong>存取时间</strong>为r，为了使其工作不间断，应保证模块数 <strong>m&gt;=T/r</strong>；</li>
<li>存取周期为T，<strong>总线传输周期</strong>为r，为了使其工作不间断，应保证模块数 <strong>m&gt;=T/r</strong>；</li>
</ol>
</blockquote>
<h3 id="单体多字存储器">单体多字存储器</h3>
<p>相当于把上述多个体合成一整个，每次只能同时取m个字（一取取一整行），不能单独取其中某个字，这种方式灵活性比较差。</p>
<h2 id="磁盘存储器">磁盘存储器</h2>
<h3 id="磁盘设备组成">磁盘设备组成</h3>
<ol>
<li>
<p>存储区域</p>
<p>一块硬盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分若干个扇区（也称块），扇区是磁盘读写的最小单位，</p>
<p><img src="https://img.lishangcc.top//img/image-20220706222339850.png" alt="image-20220706222339850"></p>
</li>
<li>
<p>硬盘存储器</p>
<p>硬盘存储器有磁盘驱动器、磁盘控制器和盘片组成；</p>
<p>磁盘驱动器：核心部件是磁头组件和盘片组件；</p>
<p>磁盘控制器：是硬盘存储器和主机的接口；</p>
</li>
</ol>
<h3 id="磁盘的性能指标">磁盘的性能指标*</h3>
<ol>
<li>
<p><strong>磁盘的容量</strong>：一个磁盘所能存储的字节总数；</p>
</li>
<li>
<p><strong>记录密度</strong>：记录密度是指盘片单位面积上记录的二进制的信息量，通常以<strong>道密度</strong>、<strong>位密度</strong>和<strong>面密度</strong>表示；</p>
<blockquote>
<p>道密度：沿磁盘半径方向上单位长度的磁道数；</p>
<p>位密度：磁道单位长度上能记录的二进制代码位数；</p>
<p>面密度：位密度和道密度的乘积；</p>
<p>注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息量越多，故每个磁道的位密度都不同，越靠内侧的磁道位密度越大；</p>
</blockquote>
</li>
<li>
<p><strong>平均存取时间（常考）</strong>：</p>
<p>平均存取时间=寻道时间（磁头移动到目的磁道）+旋转延迟时间（磁头定位到所在扇区）+传输时间（传输数据所花费的时间）；</p>
<p><img src="https://img.lishangcc.top//img/image-20220707205658498.png" alt="image-20220707205658498"></p>
<blockquote>
<p>有的可能还要求加上磁盘控制器延迟时间；</p>
</blockquote>
</li>
<li>
<p><strong>数据传输率</strong>：磁盘存储器在单位时间内向主机传送数据的字节数；</p>
<blockquote>
<p>假设磁盘转数为r（转/秒），每条磁道容量为N个字节，则数据传输率为D=rN；</p>
</blockquote>
</li>
</ol>
<h3 id="磁盘地址">磁盘地址*</h3>
<p><img src="https://img.lishangcc.top//img/image-20220707210320188.png" alt="image-20220707210320188"></p>
<blockquote>
<p>若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码；</p>
<p>2bit驱动器号，8bit磁道号，4bit盘面号，4bit扇区号；</p>
</blockquote>
<h3 id="硬盘的工作工程">硬盘的工作工程</h3>
<p>主要操作有<strong>寻址</strong>、<strong>读盘</strong>、<strong>写盘</strong>，每个操作对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字；</p>
<p>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据；</p>
<h3 id="磁盘阵列（RAID）">磁盘阵列（RAID）*</h3>
<p>将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性；</p>
<p>RAID有以下分级，编号越大越可靠；</p>
<ul>
<li>
<p>RAID0：无冗余和无校验的磁盘阵列；</p>
<blockquote>
<p>RAID0把连续多个数据块交替存放在不同物理磁盘扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但<strong>RAID0没有容错能力</strong>；</p>
</blockquote>
</li>
<li>
<p>RAID1：镜像磁盘阵列；</p>
<blockquote>
<p>RAID1是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可从另一磁盘中读取数据；而两个磁盘当一个磁盘使用，意味着<strong>容量减少一半</strong>；</p>
</blockquote>
</li>
<li>
<p>RAID2：采用纠错的海明码的磁盘阵列；</p>
</li>
<li>
<p>RAID3：位交叉奇偶校验的磁盘阵列；</p>
</li>
<li>
<p>RAID4：块交叉奇偶校验的磁盘阵列；</p>
</li>
<li>
<p>RAID5：无独立校验的奇偶校验磁盘阵列；</p>
</li>
</ul>
<h2 id="固态硬盘SSD">固态硬盘SSD</h2>
<p><strong>固态硬盘的结构</strong></p>
<p><img src="https://img.lishangcc.top//img/image-20220707220032183.png" alt="image-20220707220032183"></p>
<p>块大小：16KB—512KB，页大小：512B—4KB；</p>
<p><img src="https://img.lishangcc.top//img/image-20220707215832601.png" alt="image-20220707215832601"></p>
<h2 id="Cache基本概念">Cache基本概念</h2>
<h3 id="局部性原理">局部性原理</h3>
<p><strong>空间局部性</strong>：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的；（如：数组元素、顺序执行的指令代码）</p>
<p><strong>时间局部性</strong>：在最近的未来要用到的信息，很可能是现在正在使用的信息；（循环结构的指令代码）</p>
<p>基础局部性原理，可以吧CPU目前访问的地址周围的部分数据放到Cache中。</p>
<blockquote>
<p>如何界定局部性原理中的“周围”呢？</p>
<p>将主存的存储空间分块，如：每1KB为一块；主存与Cache之间以“块”为单位进行数据交换；</p>
<p><img src="https://img.lishangcc.top//img/image-20220708213012930.png" alt="image-20220708213012930"></p>
</blockquote>
<h3 id="性能分析">性能分析</h3>
<p><img src="https://img.lishangcc.top//img/image-20220708205052300.png" alt="image-20220708205052300"></p>
<p>设tc为访问一次Cache所需时间，tm为访问一次主存所需时间；</p>
<p><strong>命中率H</strong>：CPU欲访问的信息已在Cache中的比率；</p>
<p><strong>缺失率</strong>：M=1-H；</p>
<p><strong>系统的平均访问时间</strong>：</p>
<p>1.先访问Cache，若Cache未命中再访问主存<img src="https://img.lishangcc.top//img/image-20220708205511524.png" alt="image-20220708205511524"></p>
<p>2.同时访问Cache和主存，若Cache命中则立即停止访问主存<img src="https://img.lishangcc.top//img/image-20220708205825593.png" alt="image-20220708205825593"></p>
<blockquote>
<p>例：假设Cache的速度是主存的5倍，且Cache的命中率为95%，则采用Cache后，存储器性能提高多少？</p>
<p>解：设Cache的存取周期为t，则主存的存取周期为5t；<br>
<strong>若Cache和主存同时访问</strong>，命中时访问时间为t，未命中时访问时间为5t；<br>
平均访问时间：0.95×t+0.05×5t=1.2t；<br>
性能提升：5t/1.2t=4.17倍；</p>
<p><strong>若先访问Cache再访问主存</strong>，命中时访问时间为t，未命中时访问时间为t+5t；<br>
平均访问时间：0.95×t+0.05×6t=1.25t；<br>
性能提升：5t/1.25t=4倍；</p>
</blockquote>
<h3 id="Cache与主存的映射方式">Cache与主存的映射方式</h3>
<blockquote>
<p>解决：如何区分Cache与主存的数据块的对应关系。</p>
</blockquote>
<blockquote>
<p>假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B；</p>
</blockquote>
<h4 id="全相联映射">全相联映射</h4>
<p>主存块可以放在Cache的任意位置；</p>
<p><img src="https://img.lishangcc.top//img/image-20220712114033399.png" alt="image-20220712114033399"></p>
<p><img src="https://img.lishangcc.top//img/image-20220712113050720.png" alt="image-20220712113050720"></p>
<p>主存地址共28位，其中主存块号22位，块内地址6位；</p>
<p>若CPU访问主存地址1…1101 001110：</p>
<ul>
<li>主存地址的前22位，对比Cache中所有块的标记；</li>
<li>若标记匹配且有效位为1，则Cache命中，访问块内地址为001110单元；</li>
<li>若未命中或有效位为0，则正常访问主存；</li>
</ul>
<blockquote>
<p>优点：Cache存储空间利用充分，命中率高；</p>
<p>缺点：查找标记最慢，有可能需要对比所有行的标记；</p>
</blockquote>
<h4 id="直接映射">直接映射</h4>
<p>每个主存块只能放到一个特定的位置；</p>
<p><strong>Cache块号=主存块号%Cache总块数</strong>；</p>
<p><img src="https://img.lishangcc.top//img/image-20220712115149596.png" alt="image-20220712115149596"></p>
<p>与上题一样，22位主存块号（其中19位标记，3位行号），6位块内地址；</p>
<p>（题目中Cache总块数为8，所以主存块号%2^3相当于留下主存块号后三位二进制数）</p>
<p>若CPU访问主存地址0…01000 001110：</p>
<ul>
<li>根据主存块号的后3位确定Cache行；</li>
<li>若主存块号的前19位与Cache标记匹配且有效位为1，则Cache命中，访问块内地址为001110的单元；</li>
<li>若为命中或有效位为0，则正常访问主存；</li>
</ul>
<blockquote>
<p>优点：对于任意一个地址，只需对比一个标记，速度最快；</p>
<p>缺点：Cache存储空间利用不充分，命中率低；</p>
</blockquote>
<h4 id="组相联映射">组相联映射</h4>
<p>Cache块分为若干组，每个主存块可放到特定分组中的任意一个位置；</p>
<p><strong>所属分组=主存块号%分组数</strong>；</p>
<p><img src="https://img.lishangcc.top//img/image-20220712142106447.png" alt="image-20220712142106447"></p>
<p>22位主存块号（20位标记，2位组号），6位块内地址；</p>
<p>CPU访问主存地址1…1101 001110：</p>
<ul>
<li>根据主存块号的后2位，确定所属分组号；</li>
<li>若主存块号的前20位与分组内的某个标记匹配，且有效位为1，则Cache命中，访问块内地址001110的单元；</li>
<li>若未命中或有效位为0，则正常访问主存；</li>
</ul>
<blockquote>
<p>优点：另外两种方式的折中，<strong>综合效果较好</strong>；</p>
<p>术语：n路组相联映射——每n个Cache行为一组；</p>
</blockquote>
<h3 id="Cache替换算法">Cache替换算法</h3>
<blockquote>
<p>解决：如果Cache满了怎么办？</p>
</blockquote>
<ul>
<li><strong>全相联映射</strong>：Cache完全满了才需要替换，需要在全局中选择替换哪一块；</li>
<li><strong>直接映射（无需考虑替换算法）</strong>：如果对应位置非空，则毫无选择地直接替换；</li>
<li><strong>组相联映射</strong>：分组内满了才需要替换，需要在分组内选择替换哪一块；</li>
</ul>
<h4 id="随机算法（RAND）">随机算法（RAND）</h4>
<p>若Cache已满，则随机选择一块替换；</p>
<blockquote>
<p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p>
<p><img src="https://img.lishangcc.top//img/image-20220712142841936.png" alt="image-20220712142841936"></p>
<p>特点：实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定；</p>
</blockquote>
<h4 id="先进先出算法（FIFO）">先进先出算法（FIFO）</h4>
<p>若Cache已满，则替换最先被调入Cache的块；</p>
<blockquote>
<p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p>
<p><img src="https://img.lishangcc.top//img/image-20220712143022549.png" alt="image-20220712143022549"></p>
<p>特点：也是实现简单，但依然没考虑局部性原理，最先被调入Cache的块也有可能是被频繁访问的，而且可能出现抖动现象；</p>
</blockquote>
<blockquote>
<p><strong>抖动现象</strong>：频繁的换入换出现象（刚被替换的块很快又被调入）；</p>
</blockquote>
<h4 id="近期最少使用（LRU）">近期最少使用（LRU）*</h4>
<p>为每一个Cache块设置一个计数器，用于记录每个Cache块已经有多久没被访问了，当Cache满后，<strong>替换计数器最大的</strong>；</p>
<blockquote>
<p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p>
<p>步骤：</p>
<ol>
<li>命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变；</li>
<li>未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1；</li>
<li>未命中且无空闲行时，计数值最大的信息块被淘汰，新装行的块的计数器置0，其余全加1；</li>
</ol>
<p><img src="https://img.lishangcc.top//img/image-20220712143554578.png" alt="image-20220712143554578"></p>
<p>（Cache块的总数为2^n，则计数器只需n位）</p>
<p>特点：基于局部性原理，LRU算法的实际运行效果优秀，Cache命中率高；若被频繁访问的主存块数量 &gt; Cache行的数量，则可能发生抖动现象；</p>
</blockquote>
<h4 id="最不经常使用（LFU）">最不经常使用（LFU）</h4>
<p>为每一个Cache块设置一个计数器，用于记录每个Cache块被访问过几次，当Cache满后，<strong>替换计数器最小的</strong>；</p>
<blockquote>
<p>例：设总共有4个Cache块，初始整个Cache为空，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}</p>
<p>步骤：<br>
新调入的块计数器=0，之后每访问一次计数器+1，需要替换时，选择计数器最小的一行；</p>
<p><img src="https://img.lishangcc.top//img/image-20220712144015714.png" alt="image-20220712144015714"></p>
<p>特点：曾经被经常访问的主存块在未来不一定会用到，并没有很好的遵循局部性原理，因此实际效果不如LRU；</p>
</blockquote>
<h3 id="Cache写策略">Cache写策略</h3>
<blockquote>
<p>解决：CPU如果修改了Cache中的数据副本，如何确保主存中数据母本的一致性？</p>
</blockquote>
<h4 id="写命中">写命中</h4>
<p><strong>写回法</strong>：当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存；</p>
<blockquote>
<p>减少了访存次数，但存在数据不一致的隐患；</p>
</blockquote>
<p><strong>全写法</strong>：当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲；</p>
<blockquote>
<p>访存次数增加，速度变慢，但更能保证数据一致性；</p>
<p>使用写缓存，CPU写的速度很快，若写操作不频繁，则效果很好；若写操作频繁，则可能因为写缓存饱和而发生阻塞；</p>
</blockquote>
<h4 id="写不命中">写不命中</h4>
<p><strong>写分配法</strong>：当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改，通常<strong>搭配写回法使用</strong>；</p>
<p><strong>非写分配法</strong>：当CPU对Cache写不命中时，只写入内存，不调入Cache，通常<strong>搭配写全法使用</strong>；</p>
<blockquote>
<p>多级Cache</p>
<p>现代计算机通常采用多级Cache结构，各级Cache之间通常采用“全写法+非写分配法”，Cache和主存之间通常采用“写回法+写分配法”；</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Licc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lishangcc.github.io/myblog/2022/07/04/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-04-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">https://lishangcc.github.io/myblog/2022/07/04/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-04-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lishangcc.github.io/myblog" target="_blank">Licc's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/myblog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></div><div class="post_share"><div class="social-share" data-image="/myblog/img/background/hexoimg1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/myblog/2022/03/15/2022-03-15-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="/myblog/img/background/hexoimg5.jpg" onerror="onerror=null;src='/myblog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">十大排序算法</div></div></a></div><div class="next-post pull-right"><a href="/myblog/2022/07/12/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-12-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"><img class="next-cover" src="/myblog/img/background/hexoimg9.jpg" onerror="onerror=null;src='/myblog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第四章指令系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/myblog/2022/07/12/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-12-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" title="第四章指令系统"><img class="cover" src="/myblog/img/background/hexoimg9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-12</div><div class="title">第四章指令系统</div></div></a></div><div><a href="/myblog/2022/07/27/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-27-%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%80%BB%E7%BA%BF/" title="第六章总线"><img class="cover" src="/myblog/img/background/hexoimg8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-27</div><div class="title">第六章总线</div></div></a></div><div><a href="/myblog/2022/07/22/2022/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2022-07-22-%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" title="第五章中央处理器"><img class="cover" src="/myblog/img/background/hexoimg1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-22</div><div class="title">第五章中央处理器</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">存储器的层次化结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">存储器的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.3.</span> <span class="toc-text">存储器的性能指标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">2.</span> <span class="toc-text">主存储器的基本组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SRAM%E5%92%8CDRAM"><span class="toc-number">2.1.</span> <span class="toc-text">SRAM和DRAM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DRAM%E7%9A%84%E5%88%B7%E6%96%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">DRAM的刷新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8ROM"><span class="toc-number">2.2.</span> <span class="toc-text">只读存储器ROM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.3.</span> <span class="toc-text">主存储器与CPU连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E4%B8%BB%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8%E5%AD%97%E9%95%BF%E2%80%94%E2%80%94%E4%BD%8D%E6%89%A9%E5%B1%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">增加主存的存储字长——位扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E4%B8%BB%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8%E5%AD%97%E6%95%B0%E2%80%94%E2%80%94%E5%AD%97%E6%89%A9%E5%B1%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">增加主存的存储字数——字扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95%E2%80%94%E2%80%94%E5%AD%97%E4%BD%8D%E5%90%8C%E6%97%B6%E6%89%A9%E5%B1%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">主存容量扩展——字位同时扩展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM%E5%92%8C%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">双端口RAM和多模块存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM"><span class="toc-number">3.1.</span> <span class="toc-text">双端口RAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">多体并行存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">单体多字存储器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">磁盘存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%AE%BE%E5%A4%87%E7%BB%84%E6%88%90"><span class="toc-number">4.1.</span> <span class="toc-text">磁盘设备组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">4.2.</span> <span class="toc-text">磁盘的性能指标*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%9C%B0%E5%9D%80"><span class="toc-number">4.3.</span> <span class="toc-text">磁盘地址*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">硬盘的工作工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%EF%BC%88RAID%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">磁盘阵列（RAID）*</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98SSD"><span class="toc-number">5.</span> <span class="toc-text">固态硬盘SSD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.</span> <span class="toc-text">Cache基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">6.2.</span> <span class="toc-text">性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache%E4%B8%8E%E4%B8%BB%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">Cache与主存的映射方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="toc-number">6.3.1.</span> <span class="toc-text">全相联映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84"><span class="toc-number">6.3.2.</span> <span class="toc-text">直接映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="toc-number">6.3.3.</span> <span class="toc-text">组相联映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">Cache替换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95%EF%BC%88RAND%EF%BC%89"><span class="toc-number">6.4.1.</span> <span class="toc-text">随机算法（RAND）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">6.4.2.</span> <span class="toc-text">先进先出算法（FIFO）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%91%E6%9C%9F%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%EF%BC%88LRU%EF%BC%89"><span class="toc-number">6.4.3.</span> <span class="toc-text">近期最少使用（LRU）*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%B8%8D%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%EF%BC%88LFU%EF%BC%89"><span class="toc-number">6.4.4.</span> <span class="toc-text">最不经常使用（LFU）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache%E5%86%99%E7%AD%96%E7%95%A5"><span class="toc-number">6.5.</span> <span class="toc-text">Cache写策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%91%BD%E4%B8%AD"><span class="toc-number">6.5.1.</span> <span class="toc-text">写命中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E4%B8%8D%E5%91%BD%E4%B8%AD"><span class="toc-number">6.5.2.</span> <span class="toc-text">写不命中</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Licc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">漫漫人生，唯有热爱，可抵岁月漫长~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/myblog/js/utils.js"></script><script src="/myblog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/myblog/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>